<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports" : {
		"three" : "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.min.js",
		"utils" : "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/utils/BufferGeometryUtils.js",
		"basic" : "./basic-functions.js",
		"sound" : "./sound-effect.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';
import {
	getResource,
	postResource,
	getParam,
	DEBUG,
	COLOR,
	randomString,
	snapToNotch,
	snapToPI,
	snapTo05PI,
	createPeriodicSin,
	createPeriodicCos,
	pseudoMessageDigest1,
	pseudoMessageDigest2,
	beep,
	isEmulated,
	throttling,
	thresholding,
	debouncing,
	nonReentrantAsync,
	autoTransition,
	makeSpeaker,
	startDialog,
	factoryBuilder,
	arrRand,
	arrTrim,
	cEase,
	cApproximateMap,
	cApproximateSet,
	cCyclicMap,
	cCyclicValues,
	forEachCombination,
	cChart,
	clipArea,
	clipClearArea,
	fillRoundRect,
	XYZ,
	VEC3,
	DIRECTION,
	ndcFromEvent,
	ndcToAbs,
	getWorldVec3,
	getWorldUp,
	instanceInAncestor,
	lookAtWithoutRotation,
	safeMergeGeometry,
	makeTrapezoidGeometryParts,
	trapezoidGeometryUtil,
	roundBoxGeometry,
	roundRegularBoxGeometry,
	roundTrapezoidGeometry,
	capsuleConfigure,
	customCapsuleGeometry,
	cSphericalWorld
} from 'basic';
import * as SOUND from 'sound';

/*
	(1) cAbstractPart

	SkinnedMesh
	|
	+-- in_geometry
	|
	+-- receiver to get raycast after bent ( not visible )
	|	|
	|	+-- ExtrudeGeometry
	|
	+-- receiver to bend ( not visible )
		|
		+-- SphereGeometry
		|
		+-- CircleGeometry for positive side
		|
		+-- CircleGeometry doe negative side
*/

class cAbstractPart extends THREE.SkinnedMesh {
	static #debug = false;
	static #materialVisible = new THREE.MeshNormalMaterial();
	static #materialOpacity = new THREE.MeshNormalMaterial({transparent : true, opacity : 0.3});
	static #cacheKeys = {
		BOUNDING_BOX : Symbol(),
		DRAGGING_POS : Symbol(),
		RCV_DRAGGING : Symbol(),
		RCV_RELEASED : Symbol(),
		INTERLOCKING : Symbol(),
		MATERIALBKUP : Symbol()
	};
	static operatingLayer = 1;
	static #activateReceiver(in_receiver, in_activate) {
		if (in_activate) {
			in_receiver.raycast = THREE.Mesh.prototype.raycast;
			if (cAbstractPart.#debug) {
				in_receiver.visible = true;
			}
		} else {
			in_receiver.raycast = () => {};
			if (cAbstractPart.#debug) {
				in_receiver.visible = false;
			}
		}
	}
	static #getLength(in_box) {
		return in_box.max.y - in_box.min.y;
	}
	static #getCircumfRect(in_box) {
		return {
			w : in_box.max.x - in_box.min.x,
			h : in_box.max.z - in_box.min.z
		};
	}
	get #length() {
		return cAbstractPart.#getLength(this.#getCache('BOUNDING_BOX'));
	}
	get #circumfRect() {
		return cAbstractPart.#getCircumfRect(this.#getCache('BOUNDING_BOX'));
	}
	#getCache(in_key) {
		return this.userData[cAbstractPart.#cacheKeys[in_key]];
	}
	#setCache(in_key, in_value) {
		this.userData[cAbstractPart.#cacheKeys[in_key]] = in_value;
	}
	static #makeSkeleton(in_boneCnt, in_notch) {
		const bones = [];
		for (let i = 0; i < in_boneCnt; i++) {
			bones[i] = new THREE.Bone();
			if (i > 0) {
				bones[i].position.z = in_notch;
				bones[i - 1].add(bones[i]);
			}
		}
		return new THREE.Skeleton(bones);
	}
	static #setSkin(in_geometry, in_notch) {
		const skin = {
			indices : [],
			weights : []
		};
		for (let i = 0; i < in_geometry.attributes.position.count; i++) {
			const posV3 = (new THREE.Vector3()).fromBufferAttribute(in_geometry.attributes.position, i);
			const boneIndex = Math.round(posV3.z / in_notch);
			skin.indices.push(boneIndex, -1, -1, -1);
			skin.weights.push(1, 0, 0, 0);
		}
		in_geometry.setAttribute('skinIndex', new THREE.Uint16BufferAttribute(skin.indices, 4));
		in_geometry.setAttribute('skinWeight', new THREE.Float32BufferAttribute(skin.weights, 4));
	}
	#configureDraggingRcv() {
		const parts = [];
		const receivingRatio = 3;
		parts.push(new THREE.CircleGeometry(this.#length * receivingRatio));
		/*
			*** NOTE ***
			as CircleGeometry can't catch raycast from opposite side,
			use rotated CircleGeometry in addition.
		*/
		parts.push((new THREE.CircleGeometry(this.#length * receivingRatio)).rotateX(Math.PI));
		parts.push(new THREE.SphereGeometry(this.#length));
		const mesh = new THREE.Mesh(safeMergeGeometry(parts), cAbstractPart.#materialOpacity);
		mesh.visible = false;
		mesh.layers.set(cAbstractPart.operatingLayer);
		this.#setCache('RCV_DRAGGING', mesh);
		this.add(mesh);
	}
	#configureReleasedRcv() {
		const geometry = this.#makeRoughGeometry();
		const mesh = new THREE.Mesh(geometry, cAbstractPart.#materialVisible);
		mesh.visible = false;
		this.#setCache('RCV_RELEASED', mesh);
		this.add(mesh);
	}
	#configureReceiver() {
		this.#configureDraggingRcv();
		this.#configureReleasedRcv();
	}
	resetDraggingRcv() {
		/*
			*** NOTE ***
			cached DRAGGING_POS should be cloned.
			it should not be changed during dragging.
		*/
		const dragging = this.#getCache('RCV_DRAGGING');
		dragging.lookAt(this.#getCache('DRAGGING_POS'));
	}
	activateDraggingRcv(in_vec3) {
		// RCV_DRAGGING : ON
		const dragging = this.#getCache('RCV_DRAGGING');
		cAbstractPart.#activateReceiver(dragging, true);
		this.#setCache('DRAGGING_POS', in_vec3.clone());
		this.resetDraggingRcv();
		// RCV_RELEASED : OFF
		const released = this.#getCache('RCV_RELEASED');
		cAbstractPart.#activateReceiver(released, false);
	}
	activateReleasedRcv() {
		// RCV_DRAGGING : OFF
		const dragging = this.#getCache('RCV_DRAGGING');
		cAbstractPart.#activateReceiver(dragging, false);
		// RCV_RELEASED : ON
		const released = this.#getCache('RCV_RELEASED');
		cAbstractPart.#activateReceiver(released, true);
		/*
			*** NOTE ***
			vertices of SkinnedMesh.geometry will not be changed after moving bones.
			because of it, SkinnedMesh.geometry can't catch raycasting properly.
			so, to catch raycasting, rough formed geometry is attached.
		*/
		released.geometry.dispose();
		released.geometry = this.#makeRoughGeometry();
	}
	constructor(in_geometry, in_boneCnt) {
		/*
			*** NOTE ***
			as in_geometry may not have parameters.height, boundingBox is needed.
			in addition, without clone(), boundingBox will be changed after rotateX().
			to #makeRoughGeometry(), and to moreShrink(), boundingBox will be used.
		*/
		in_geometry.computeBoundingBox();
		const box = in_geometry.boundingBox.clone();
		const length = cAbstractPart.#getLength(box);
		/*
			when using lookAt() / bendAt(),
			make the direction of bones be afected.
			as a default, object is set as lookAt(0, 0, 1) of local coordinate

			object (before) :

			     y    
			     |   /
			     |  /
			     | /
			    ###
			 ---#*#---x
			    /##
			   / |
			  /  |
			 /
			z : lookAt(0, 0, 1)

			object (after) :

			     y
			     |  /
			     | /
			     |/
			 ---#*#---x
			   ###
			  ###|
			  /  |
			 /
			z : lookAt(0, 0, 1)
		*/
		in_geometry.translate(0, length / 2, 0);
		in_geometry.rotateX(Math.PI / 2);
		/*
			as bone does not have length, but it is a point, ...
			+---+---+---+---+ : in_boneCnt = 5 ( segument count = 4 )
		*/
		const notch = length / (in_boneCnt - 1);
		const skeleton = cAbstractPart.#makeSkeleton(in_boneCnt, notch);
		cAbstractPart.#setSkin(in_geometry, notch);
		if (cAbstractPart.#debug) {
			super(in_geometry, cAbstractPart.#materialOpacity);
		} else {
			super(in_geometry, cAbstractPart.#materialVisible);
		}
		this.#setCache('BOUNDING_BOX', box);
		this.#setCache('INTERLOCKING', Symbol());
		this.add(skeleton.bones[0]);
		this.bind(skeleton);
		this.#configureReceiver();
		this.activateReleasedRcv();
	}
	get #interlockings() {
		const objects = [this];
		this.skeleton.bones.forEach(in_bone => {
			in_bone.children.forEach(in_child => {
				if (in_child.userData.group === this.#getCache('INTERLOCKING')) {
					objects.push(in_child);
				}
			});
		});
		return objects;
	}
	cloneGeometry(in_local = true) {
		const parts = [];
		this.#interlockings.forEach(in_obj => {
			let part;
			if ((in_obj instanceof cAbstractPart) && in_obj.isBent()) {
				part = in_obj.makeBentGeometry();
			} else {
				part = in_obj.geometry.clone();
			}
			const keep = ['position', 'normal'];
			for (const attribute in part.attributes) {
				if (!keep.includes(attribute)) {
					part.deleteAttribute(attribute);
				}
			}
			part.applyMatrix4(in_obj.matrixWorld);
			parts.push(part);
		});
		const merged = safeMergeGeometry(parts);
		if (in_local) {
			merged.applyMatrix4(new THREE.Matrix4().copy(this.matrixWorld).invert());
		}
		return merged;
	}
	#resetInterlockingMaterials(in_material) {
		this.#interlockings.forEach(in_obj => {
			if ((in_obj instanceof cAbstractPart) && (in_obj !== this)) {
				in_obj.resetMaterial(in_material);
			} else {
				in_obj.material = in_material;
			}
		});
	}
	resetMaterial(in_material) {
		this.highlight(false);
		this.#resetInterlockingMaterials(in_material);
	}
	highlight(in_highlight, in_strengthen = 0.2) {
		let cache = this.#getCache('MATERIALBKUP');
		if (in_highlight) {
			if (cache) {
				// already highlighted
				return false;
			} else {
				cache = {original : this.material, cloned : this.material.clone()};
				cache.cloned.color = cache.cloned.color.lerp(new THREE.Color(0xffffff), in_strengthen);
				this.#resetInterlockingMaterials(cache.cloned);
				this.#setCache('MATERIALBKUP', cache);
				return true;
			}
		} else {
			if (cache) {
				this.#resetInterlockingMaterials(cache.original);
				this.#setCache('MATERIALBKUP', null);
				cache.cloned.dispose();
				return true;
			} else {
				// already normal
				return false;
			}
		}
	}
	get #boneCnt() {
		return this.skeleton.bones.length;
	}
	#boneWorldPosition(in_index) {
		const bones = this.skeleton.bones;
		return bones[in_index].getWorldPosition(VEC3());
	}
	#boneAnchorWorldPosition() {
		return this.#boneWorldPosition(0);
	}
	#boneMovingWorldPosition() {
		return this.#boneWorldPosition(this.#boneCnt - 1);
	}
	#updatedBentBones(in_dstV3) {
		const updated = in_dstV3 ? true : false;
		const anchor = this.#boneAnchorWorldPosition();
		const moving = this.#boneMovingWorldPosition();
		let delta = VEC3();
		if (updated) {
			delta = delta.subVectors(in_dstV3, moving);
		}
		const bent = {
			posArr : [],
			dirArr : []
		};
		for (let i = 0; i < this.#boneCnt; i++) {
			const boneSrcV3 = this.#boneWorldPosition(i);
			if (updated) {
				const factor = i / (this.#boneCnt - 1);
				const boneDelta = (VEC3()).lerp(delta, factor ** 2);
				bent.posArr[i] = boneSrcV3.add(boneDelta);
			} else {
				bent.posArr[i] = boneSrcV3;
			}
			if (i === 0) {
				bent.dirArr[i] = (VEC3()).subVectors(moving, anchor).normalize();
			} else {
				bent.dirArr[i] = (VEC3()).subVectors(bent.posArr[i], bent.posArr[i - 1]).normalize();
			}
		}
		return bent;
	}
	#currentBentBones() {
		return this.#updatedBentBones(null);
	}
	#makeRoughGeometry() {
		const thickness = 0.5;
		// shape
		const w = this.#circumfRect.w * thickness;
		const h = this.#circumfRect.w * thickness;
		const shape = new THREE.Shape();
		shape.moveTo(w / 2 * -1, h / 2 * -1);
		shape.lineTo(w / 2 * +1, h / 2 * -1);
		shape.lineTo(w / 2 * +1, h / 2 * +1);
		shape.lineTo(w / 2 * -1, h / 2 * +1);
		shape.lineTo(w / 2 * -1, h / 2 * -1);
		// path
		const bent = this.#currentBentBones();
		const inverse = new THREE.Matrix4();
		inverse.copy(this.matrixWorld).invert();
		bent.posArr.map(in_pos => {
			return in_pos.applyMatrix4(inverse);
		});
		const path = new THREE.CatmullRomCurve3(bent.posArr);
		// extrude
		const extrudeSettings = {
			steps : Math.max(5, Math.ceil((this.#boneCnt - 1) / 5)),
			bevelEnabled : false,
			extrudePath : path
		};
		return new THREE.ExtrudeGeometry(shape, extrudeSettings);
	}
	makeBentGeometry() {
		const attr = this.geometry.attributes;
		const toLocalPos = new THREE.Matrix4().copy(this.matrixWorld).invert();
		const toLocalNrm = new THREE.Matrix3().getNormalMatrix(this.matrixWorld).invert();
		const dstPosArr = new Float32Array(attr.position.count * 3);
		const dstNrmArr = new Float32Array(attr.normal.count * 3);
		for (let i = 0; i < attr.position.count; i++) {
			const dstPos = VEC3();
			const dstNrm = VEC3();
			const tmpPos = VEC3().fromBufferAttribute(attr.position, i);
			const tmpNrm = VEC3().fromBufferAttribute(attr.normal, i);
			const indices = new THREE.Vector4().fromBufferAttribute(attr.skinIndex, i);
			const weights = new THREE.Vector4().fromBufferAttribute(attr.skinWeight, i);
			for (let j = 0; j < 4; j++) {
				const weight = weights.getComponent(j);
				if (weight === 0) {
					continue;
				}
				const boneMatrix = new THREE.Matrix4().fromArray(this.skeleton.boneMatrices, indices.getComponent(j) * 16);
				dstPos.addScaledVector(tmpPos.applyMatrix4(boneMatrix), weight);
				const transformed = tmpNrm.applyMatrix3(new THREE.Matrix3().getNormalMatrix(boneMatrix)).normalize();
				dstNrm.addScaledVector(transformed, weight);
			}
			dstPos.applyMatrix4(toLocalPos);
			dstPosArr[i * 3 + 0] = dstPos.x;
			dstPosArr[i * 3 + 1] = dstPos.y;
			dstPosArr[i * 3 + 2] = dstPos.z;
			dstNrm.applyMatrix3(toLocalNrm);
			dstNrmArr[i * 3 + 0] = dstNrm.x;
			dstNrmArr[i * 3 + 1] = dstNrm.y;
			dstNrmArr[i * 3 + 2] = dstNrm.z;
		}
		const bentGeometry = new THREE.BufferGeometry();
		bentGeometry.setAttribute('position', new THREE.BufferAttribute(dstPosArr, 3));
		bentGeometry.setAttribute('normal', new THREE.BufferAttribute(dstNrmArr, 3));
		bentGeometry.setIndex(this.geometry.index);
		return bentGeometry;
	}
	isBent() {
		const bones = this.skeleton.bones;
		const anchor = bones[0];
		const moving = bones[bones.length - 1];
		return (anchor.position.x != moving.position.x) || (anchor.position.y != moving.position.y);
	}
	bendAt(in_dstV3) {
		const bones = this.skeleton.bones;
		const updated = this.#updatedBentBones(in_dstV3);
		for (let i = 1; i < bones.length; i++) {
			const destV3 = updated.posArr[i].clone().add(updated.dirArr[i].multiplyScalar(this.#length));
			bones[i][lookAtWithoutRotation](destV3);
			bones[i].position.copy(bones[i].parent.worldToLocal(updated.posArr[i]));
		}
	}
	moreShrink() {
		const anchor = this.#boneAnchorWorldPosition();
		const moving = this.#boneMovingWorldPosition();
		const curLen = anchor.distanceTo(moving);
		const orgLen = this.#length;
		if (Math.abs(curLen - orgLen) > 10) {
			const factor = ((curLen - orgLen) / orgLen) * 0.1;
			const vec3 = moving.lerp(anchor, factor);
			this.bendAt(vec3);
			return true;
		} else {
			return false;
		}
	}
	#addMeshToBone(in_ix, in_mesh, in_interlocking) {
		if (in_interlocking) {
			// in_mesh should be a part of this
			in_mesh.userData.group = this.#getCache('INTERLOCKING');
		}
		this.skeleton.bones[in_ix].add(in_mesh);
	}
	addToAnchor(in_mesh, in_interlocking = false) {
		this.#addMeshToBone(0, in_mesh, in_interlocking);
	}
	addToMoving(in_mesh, in_interlocking = false) {
		this.#addMeshToBone(this.skeleton.bones.length - 1, in_mesh, in_interlocking);
	}
	addGeometryToAnchor(in_geometry) {
		this.addToAnchor(new THREE.Mesh(in_geometry, this.material), true);
	}
	addGeometryToMoving(in_geometry) {
		this.addToMoving(new THREE.Mesh(in_geometry, this.material), true);
	}
	helper() {
		return new THREE.SkeletonHelper(this);
	}
	copyPoseData() {
		return this.skeleton.bones.map(in_bone => {
			return {
				position : in_bone.position.toArray(),
				quaternion : in_bone.quaternion.toArray() 
			};
		});
	}
	restorePoseData(in_poseData, in_restorePosition = true) {
		in_poseData.forEach((in_boneData, in_ix) => {
			const bone = this.skeleton.bones[in_ix];
			if (in_restorePosition) {
				bone.position.fromArray(in_boneData.position);
			}
			bone.quaternion.fromArray(in_boneData.quaternion);
		});
	}
}

class cSoftBoxPart extends cAbstractPart {
	constructor(in_w, in_h, in_d, in_boneCnt) {
		const wSeg = 1;
		const hSeg = in_boneCnt - 1;
		const dSeg = 1;
		const geometry = new THREE.BoxGeometry(in_w, in_h, in_d, wSeg, hSeg, dSeg);
		super(geometry, in_boneCnt);
	}
}

class cSoftCylinderPart extends cAbstractPart {
	constructor(in_rad_t, in_rad_b, in_h, in_boneCnt) {
		const rSeg = 32;
		const hSeg = in_boneCnt - 1;
		const geometry = new THREE.CylinderGeometry(in_rad_t, in_rad_b, in_h, rSeg, hSeg);
		super(geometry, in_boneCnt);
	}
}

class cSoftCapsulePart extends cSoftCylinderPart {
	constructor(in_rad_t, in_rad_b, in_h, in_boneCnt) {
		super(in_rad_t, in_rad_b, in_h, in_boneCnt);
		const conf = capsuleConfigure(in_rad_t, in_rad_b, in_h);
		const sphereParams = [32, 16, 0, Math.PI * 2];
		const geo = new THREE.SphereGeometry(conf.radius.t, ...sphereParams, 0, conf.theta);
		const sign = in_rad_t > in_rad_b ? +1 : -1;
		geo.translate(0, conf.delta.t * sign, 0);
		geo.rotateX(Math.PI / 2);
		this.addGeometryToMoving(geo);
	}
}

class cSoftConePart extends cAbstractPart {
	constructor(in_rad, in_h, in_boneCnt) {
		const rSeg = 32;
		const hSeg = in_boneCnt - 1;
		const geometry = new THREE.ConeGeometry(in_rad, in_h, rSeg, hSeg)
		super(geometry, in_boneCnt);
	}
}

class cSoftRoundBoxPart extends cAbstractPart {
	constructor(in_w, in_h, in_d, in_boneCnt) {
		const wSeg = 1;
		const hSeg = in_boneCnt - 1;
		const rSeg = 32;
		const zp = new THREE.PlaneGeometry(in_w, in_h, wSeg, hSeg);
		zp.rotateY(Math.PI * 0);
		zp.translate(0, 0, in_d / 2 * +1);
		const zn = new THREE.PlaneGeometry(in_w, in_h, wSeg, hSeg);
		zn.rotateY(Math.PI * 1);
		zn.translate(0, 0, in_d / 2 * -1);
		const xp = new THREE.CylinderGeometry(in_d / 2, in_d / 2, in_h, rSeg, hSeg, true, 0, Math.PI);
		xp.rotateY(Math.PI * 0);
		xp.translate(in_w / 2 * +1, 0, 0);
		const xn = new THREE.CylinderGeometry(in_d / 2, in_d / 2, in_h, rSeg, hSeg, true, 0, Math.PI);
		xn.rotateY(Math.PI * 1);
		xn.translate(in_w / 2 * -1, 0, 0);
		super(safeMergeGeometry([zp, zn, xp, xn]), in_boneCnt);
		// decoration (top, bottom)
		const makeDecoGeometry = (in_r, in_len) => {
			const wSeg = 32;
			const hSeg = 16;
			const geo1 = new THREE.SphereGeometry(in_r, wSeg, hSeg, 0, Math.PI * 0.5);
			geo1.translate(in_len / 2 * -1, 0, 0);
			const geo2 = new THREE.CylinderGeometry(in_r, in_r, in_len, wSeg, 1, true, 0, Math.PI);
			geo2.rotateY(Math.PI * 0.5 * -1);
			geo2.rotateZ(Math.PI * 0.5 * +1);
			const geo3 = new THREE.SphereGeometry(in_r, wSeg, hSeg, 0, Math.PI * 0.5);
			geo3.rotateY(Math.PI * 0.5 * +1);
			geo3.translate(in_len / 2 * +1, 0, 0);
			return safeMergeGeometry([geo1, geo2, geo3]);
		};
		const mDeco = makeDecoGeometry(in_d / 2, in_w);
		this.addGeometryToMoving(mDeco);
		const aDeco = makeDecoGeometry(in_d / 2, in_w);
		aDeco.rotateY(Math.PI);
		this.addGeometryToAnchor(aDeco);
	}
}

class cSolidPart extends cAbstractPart {
	constructor(in_geometry, in_restricted = false) {
		const boneCnt = 2;
		super(in_geometry, boneCnt);
		/*
			true  : can lookAt() toward all direction
			false : can't lookAt() toward direction of local x-coordinate
		*/
		this.plane_1_0_0 = in_restricted;
	}
	bendAt(in_dstV3, in_byUserInteraction = true) {
		let projection;
		if (this.plane_1_0_0) {
			projection = this[getWorldVec3](DIRECTION.XP);
		} else {
			projection = null;
		}
		this[lookAtWithoutRotation](in_dstV3, projection);
		if (in_byUserInteraction) {
			this.resetDraggingRcv();
		}
	}
	moreShrink() {
		return false;
	}
	copyPoseData() {
		const poseData = {};
		poseData.bone = super.copyPoseData();
		poseData.quaternion = this.quaternion.clone().toArray();
		poseData.plane_1_0_0 = this.plane_1_0_0;
		return poseData;
	}
	restorePoseData(in_poseData) {
		super.restorePoseData(in_poseData.bone, false);
		this.quaternion.fromArray(in_poseData.quaternion);
		this.plane_1_0_0 = in_poseData.plane_1_0_0;
	}
}

class cHead extends cSolidPart {
	constructor(in_radius) {
		const geometry = new THREE.SphereGeometry(in_radius);
		super(geometry, false);
	}
}

class cSmartPhone extends cSolidPart {
	constructor(in_width, in_height, in_radius) {
		const geometry = roundTrapezoidGeometry(in_width, in_width, in_height, in_radius);
		super(geometry, false);
	}
}

class cLightSaber extends cSolidPart {
	constructor(in_length, in_radius) {
		const parts = [];
		parts.push(customCapsuleGeometry(in_radius, in_radius, in_length));
		const radius = in_radius * 1.5;
		const length = in_length * 0.2;
		const pos = (in_length - length) / 2;
		parts.push(customCapsuleGeometry(radius, radius, length).translate(0, pos * -1, 0));
		const merged = safeMergeGeometry(parts)
		merged.translate(0, length * -0.5, 0);
		super(merged, false);
		this.position.z += length * 0.3;
	}
}

class cJointedSolidPart extends cSolidPart {
	/*
		cJointedSolidPart
		|
		+-- userData.jointed
		|
		+-- cSolidPart
			|
			+-- cSolidPart ...
	*/
	static createUtil1(in_geoArm, in_geoJoint, in_armCnt, in_restricted) {
		const geoArr = [];
		for (let i = 0; i < in_armCnt; i++) {
			geoArr[i] = {
				segment : in_geoArm.clone(),
				joint : in_geoJoint.clone()
			};
		}
		/*
			*** NOTE ***
			as a API policy, object itself (not clone) should be user for this.
			if not, without disposing by caller, memory leak will happen.
		*/
		geoArr[0].segment = in_geoArm;
		geoArr[0].joint = in_geoJoint;
		return new cJointedSolidPart(geoArr, in_restricted);
	}
	static createUtil2(in_geoArm, in_armCnt, in_restricted) {
		return cJointedSolidPart.createUtil1(in_geoArm, null, in_armCnt, in_restricted);
	}
	static #jointedFrom(in_startObj, in_direction) {
		const ancestor = in_startObj[instanceInAncestor](cJointedSolidPart);
		if (ancestor) {
			const chain = [ancestor, ...ancestor.userData.jointed];
			if (chain.includes(in_startObj)) {
				if (in_direction) {
					chain.reverse();
				}
				// if in_startObj belongs to a cJointedSolidPart chain, method returns array.
				return chain.slice(chain.indexOf(in_startObj));
			} else {
				// in_startObj does not belong to a cJointedSolidPart (simply child)
				return [];
			}
		} else {
			// can not find cJointedSolidPart ancestor
			return [];
		}
	}
	static ancestors(in_obj) {
		// in_startObj + ancestors
		return cJointedSolidPart.#jointedFrom(in_obj, true);
	}
	static descendants(in_obj) {
		// in_startObj + descendants
		return cJointedSolidPart.#jointedFrom(in_obj, false);
	}
	static highlightAt(in_obj, in_highlight) {
		const jointedChain = cJointedSolidPart.ancestors(in_obj);
		jointedChain.forEach(in_ancestor => in_ancestor.highlight(in_highlight));
	}
	static stretchable(in_obj) {
		const jointedChain = cJointedSolidPart.ancestors(in_obj);
		if (jointedChain.length > 1) {
			return true;
		} else {
			// root or not cJointedSolidPart
			return false;
		}
	}
	static stretchAt(in_obj, in_dstV3) {
		const jointedChain = cJointedSolidPart.ancestors(in_obj);
		if (jointedChain.length === 0) {
			// not cJointedSolidPart
			return false;
		}
		/*
			[0] > threshold : using normal bendAt
			[0] < threshold : 
			  [1] > threshold : affect [1] + bendAt [0]
			  [1] < threshold : i++
			    [2] > threshold : affect [2] + bendAt [1] ([0] is the same angle with [1])
			    [2] < threshold : i++
		*/
		const threshold = 0.01;
		const smoothing = 0.9;
		const vectorToStretch = in_targetObj => {
			return VEC3().subVectors(in_dstV3, in_targetObj.getWorldPosition(VEC3()));
		};
		const angleToStretch = in_targetObj => {
			return vectorToStretch(in_targetObj).angleTo(in_targetObj.getWorldDirection(VEC3()));
		};
		if (angleToStretch(jointedChain[0]) < threshold) {
			let target = 0;
			for (let i = 1; i < jointedChain.length; i++) {
				if (angleToStretch(jointedChain[i]) < threshold) {
					continue;
				} else {
					target = i;
					break;
				}
			}
			if (target > 0) {
				// affect [n]
				const parent = jointedChain[target];
				const srcDir = parent.getWorldDirection(VEC3());
				const dstDir = vectorToStretch(parent);
				const adhocScale = 1000; // how can I decide this ?
				const delta = in_dstV3.distanceTo(parent.getWorldPosition(VEC3())) / adhocScale;
				const angle = Math.min(srcDir.angleTo(dstDir), delta);
				const axis = VEC3().crossVectors(srcDir, dstDir).normalize();
				const quat = new THREE.Quaternion().setFromAxisAngle(axis, angle * smoothing);
				srcDir.applyQuaternion(quat).multiplyScalar(WORLD_RADIUS);
				parent[lookAtWithoutRotation](parent.position.clone().add(srcDir));
				// bendAt [n - 1]
				const child = jointedChain[target - 1];
				child[lookAtWithoutRotation](in_dstV3);
			}
			// streched
			return true;
		}
		// can bendAt
		return false;
	}
	constructor(in_geoArr, in_restricted) {
		let prev = null;
		in_geoArr.forEach(({segment, joint}) => {
			if (!prev) {
				// once
				super(segment, in_restricted);
				this.userData.jointed = [];
				prev = this;
			} else {
				const next = new cSolidPart(segment, in_restricted);
				prev.addToMoving(next, true);
				this.userData.jointed.push(next);
				prev = next;
			}
			if (joint) {
				prev.addGeometryToMoving(joint);
			}
		});
		// userData.jointed will not be updated.
		Object.freeze(this.userData.jointed);
	}
	get #jointed() {
		return [this, ...this.userData.jointed];
	}
	cloneGeometry(in_local = true) {
		const parts = [];
		this.#jointed.forEach(in_obj => {
			// call cloneGeometry@cAbstractPart
			const part = super.cloneGeometry.call(in_obj, in_local);
			if (in_local) {
				part.applyMatrix4(in_obj.matrixWorld);
			}
			parts.push(part);
		});
		const merged = safeMergeGeometry(parts);
		if (in_local) {
			merged.applyMatrix4(new THREE.Matrix4().copy(this.matrixWorld).invert());
		}
		return merged;
	}
	addToMoving(in_obj, in_interlocking = false) {
		// call addToMoving@cAbstractPart
		super.addToMoving.call(this.#jointed[this.#jointed.length - 1], in_obj, in_interlocking);
	}
	resetMaterial(in_material) {
		this.#jointed.forEach(in_obj => {
			// call resetMaterial@cAbstractPart
			super.resetMaterial.call(in_obj, in_material);
		});
	}
	copyPoseData() {
		return {
			self : super.copyPoseData(),
			// without this
			jointed : this.userData.jointed.map(in_obj => in_obj.copyPoseData())
		};
	}
	restorePoseData(in_poseData) {
		super.restorePoseData(in_poseData.self);
		in_poseData.jointed.forEach((in_partData, in_ix) => {
			this.userData.jointed[in_ix].restorePoseData(in_partData);
		});
	}
}

function createCapsuleArm1(in_movingRad, in_anchorRad, in_totalLen, in_armCnt) {
	// in_totalLen includes radius
	const wSeg = 32;
	const hSeg = 16;
	const sphereParams = [wSeg, hSeg, 0, Math.PI * 2];
	const length = (in_totalLen - (in_movingRad + in_anchorRad)) / in_armCnt;
	const deltaRad = (in_anchorRad - in_movingRad) / in_armCnt;
	const geoArr = [];
	let mDeco, solid, aDeco;
	let anchorDelta = 0;
	for (let i = 0; i < in_armCnt; i++) {
		const anchorRad = in_anchorRad - deltaRad * i;
		const movingRad = anchorRad - deltaRad;
		const conf = capsuleConfigure(movingRad, anchorRad, length);
		const top2theta = [0, conf.theta];
		mDeco = new THREE.SphereGeometry(conf.radius.t, ...sphereParams, ...top2theta);
		mDeco.rotateX(Math.PI * 0.5);
		if (i == 0) {
			const theta2bottom = [conf.theta, Math.PI - conf.theta];
			aDeco = new THREE.SphereGeometry(conf.radius.b, ...sphereParams, ...theta2bottom);
			aDeco.rotateX(Math.PI * 0.5);
			anchorDelta = conf.delta.b;
		}
		solid = new THREE.CylinderGeometry(movingRad, anchorRad, length, wSeg, 1, true);
		solid.translate(0, conf.delta.b, 0);
		geoArr[i] = {
			segment : solid,
			joint : mDeco
		};
	}
	const capsuleArm = new cJointedSolidPart(geoArr, false);
	capsuleArm.addGeometryToAnchor(aDeco);
	return {
		object : capsuleArm,
		delta : anchorDelta
	}
}

function createCapsuleArm2(in_rad, in_totalLen, in_armCnt) {
	return createCapsuleArm1(in_rad, in_rad, in_totalLen, in_armCnt);
}

function roundedBoxBody(in_movingLen, in_anchorLen, in_lenArr, in_rad) {
	// each length includes radius
	in_lenArr[0] -= in_rad;
	in_lenArr[in_lenArr.length - 1] -= in_rad;
	const totalLen = in_lenArr.reduce((acc, val) => acc + val, 0);
	const delta = in_movingLen - in_anchorLen;
	let toCurMoving = 0;
	let toCurAnchor = 0;
	const geoArr = [];
	let mDeco, solid, aDeco;
	for (let i = 0; i < in_lenArr.length; i++) {
		toCurAnchor += in_lenArr[i];
		const movingLen = in_anchorLen - in_rad * 2 + delta * toCurMoving / totalLen;
		const anchorLen = in_anchorLen - in_rad * 2 + delta * toCurAnchor / totalLen;
		const parts = makeTrapezoidGeometryParts(anchorLen, 0, movingLen, 0, in_lenArr[i], in_rad);
		const mDecoArr = [];
		const solidArr = [];
		const aDecoArr = [];
		parts.forEach(in_part => {
			if (in_part.userData.isSurface) {
				solidArr.push(in_part);
			} else {
				if (in_part.userData.groupName === 'bottom') {
					if (i === 0) {
						aDecoArr.push(in_part);
					} else {
						in_part.dispose();
					}
				} else {
					mDecoArr.push(in_part);
				}
			}
		});
		solid = safeMergeGeometry(solidArr)
		mDeco = safeMergeGeometry(mDecoArr)
		mDeco.translate(0, in_lenArr[i] * 0.5 * -1, 0);
		mDeco.rotateX(Math.PI * 0.5);
		// equals to i === 0
		if (aDecoArr.length > 0) {
			aDeco = safeMergeGeometry(aDecoArr)
			aDeco.translate(0, in_lenArr[i] * 0.5 * +1, 0);
			aDeco.rotateX(Math.PI * 0.5);
		}
		geoArr[i] = {
			segment : solid,
			joint : mDeco
		};
		toCurMoving += in_lenArr[i];
	}
	const body = new cJointedSolidPart(geoArr, true);
	body.addGeometryToAnchor(aDeco);
	return body;
}

class cFigure extends THREE.Object3D {
	static #cacheKeys = {
		HEAD : Symbol(),
		BODY : Symbol(),
		NARM : Symbol(),
		PARM : Symbol(),
		NLEG : Symbol(),
		PLEG : Symbol(),
		ITEM : Symbol()
	};
	#getCache(in_key) {
		return this.userData[cFigure.#cacheKeys[in_key]];
	}
	#setCache(in_key, in_value) {
		this.userData[cFigure.#cacheKeys[in_key]] = in_value;
	}
	constructor(
		in_head,
		in_body,
		in_narm,
		in_parm,
		in_nleg,
		in_pleg,
		in_item = null
	) {
		super();
		this.add(in_body);
		this.rotateX(Math.PI * -0.5);
		// cache parts
		this.#setCache('HEAD', in_head);
		this.#setCache('BODY', in_body);
		this.#setCache('NARM', in_narm);
		this.#setCache('PARM', in_parm);
		this.#setCache('NLEG', in_nleg);
		this.#setCache('PLEG', in_pleg);
		this.#setCache('ITEM', in_item);
		// adjust center
		const adhocDelta = -80;
		this.position.y = adhocDelta;
	}
	get #cached() {
		const arr = [];
		Object.keys(cFigure.#cacheKeys).forEach(in_key => {
			arr.push(this.#getCache(in_key));
		});
		return arr;
	}
	resetItem(in_item) {
		const item = this.#getCache('ITEM');
		if (item) {
			item.removeFromParent();
		}
		this.#setCache('ITEM', in_item);
		if (in_item) {
			this.#getCache('NARM').addToMoving(in_item);
		}
	}
	resetItemUpToHead() {
		const item = this.#getCache('ITEM');
		if (!item) {
			return;
		}
		const inverse = new THREE.Matrix4().copy(item.matrixWorld).invert();
		const local = this.#getCache('HEAD').getWorldPosition(VEC3()).applyMatrix4(inverse);
		item.up.copy(local).normalize();
	}
	resetMaterial(in_material) {
		this.#cached.forEach(in_part => {
			if (!in_part) {
				return;
			}
			in_part.resetMaterial(in_material);
		});
	}
	cloneGeometry(in_local = true) {
		const parts = [];
		this.#cached.forEach(in_cache => {
			if (!in_cache) {
				return;
			}
			const part = in_cache.cloneGeometry(in_local);
			if (in_local) {
				part.applyMatrix4(in_cache.matrixWorld);
			}
			parts.push(part);
		});
		const merged = safeMergeGeometry(parts);
		if (in_local) {
			merged.applyMatrix4(new THREE.Matrix4().copy(this.matrixWorld).invert());
		}
		return merged;
	}
	copyPoseData() {
		const poseData = {};
		Object.keys(cFigure.#cacheKeys).forEach(in_key => {
			const part = this.#getCache(in_key);
			if (part && part.copyPoseData) {
				poseData[in_key] = part.copyPoseData();
				if (in_key === 'ITEM') {
					poseData['ITEM_CLASS'] = part.constructor.name;
				}
			}
		});
		return poseData;
	}
	restorePoseData(in_poseData) {
		Object.keys(cFigure.#cacheKeys).forEach(in_key => {
			const part = this.#getCache(in_key);
			if (part && part.restorePoseData && in_poseData[in_key]) {
				part.restorePoseData(in_poseData[in_key]);
			}
		});
	}
}

/*
	(2) figure setting : color, material, items, and figure
*/

const gCyclicColors = new cCyclicValues(
	// dodgerblue
	0x1E90FF,
	// gold
	0xFFD700,
	// orangered
	0xFF4500,
	// pink
	0xEEBEC9,
	// green
	0x008000,
	// royalblue
	0x4169E1,
	// darkgoldenrod
	0xB8860B,
	// lightgray
	0xD3D3D3,
	// gray
	0x808080,
	// black
	0x000000
);

(in_index => {
	if (in_index !== false) {
		gCyclicColors.setCurrentIndex(in_index);
	}
})(getParam('color'));

function createToonTexture() {
	const canvas = document.createElement('canvas');
	canvas.width = 128;
	canvas.height = 128;
	const context = canvas.getContext('2d');
	const gradient = context.createLinearGradient(0, 0, canvas.width, 0);
	const stops = [
		{to : 0.75, color : '#aaaaaa'},
		{to : 0.95, color : '#cccccc'},
		{to : 1.00, color : '#eeeeee'}
	];
	let from = 0.00;
	stops.forEach(in_stop => {
	    gradient.addColorStop(from, in_stop.color);
	    gradient.addColorStop(in_stop.to, in_stop.color);
		from = in_stop.to;
	});
	context.fillStyle = gradient;
	context.fillRect(0, 0, canvas.width, canvas.height);
	const texture = new THREE.CanvasTexture(canvas);
	texture.minFilter = THREE.NearestFilter;
	texture.magFilter = THREE.NearestFilter;
	return texture;
}

const gCyclicMaterials = (in_color => {
	const cyclic = new cCyclicValues();
	cyclic.push(new THREE.MeshStandardMaterial({
		color : in_color,
		metalness : 0.3,
		roughness : 0.3
	}));
	cyclic.push(new THREE.MeshStandardMaterial({
		color : in_color,
		roughness : 1.0
	}));
	cyclic.push(new THREE.MeshToonMaterial({
		color : in_color,
		gradientMap : createToonTexture()
	}));
	cyclic.push(new THREE.MeshBasicMaterial({
		color : in_color
	}));
	return cyclic;
})(gCyclicColors.currValue());

(in_index => {
	if (in_index !== false) {
		gCyclicMaterials.setCurrentIndex(in_index);
	}
})(getParam('material'));

function incrementColor() {
	// gCyclicColors --> gCyclicMaterials
	const incremented = gCyclicColors.incrementedValue();
	gCyclicMaterials.forEach(in_materials => {
		in_materials.color.set(incremented); 
	});
}

const gCyclicItems = (in_material => {
	const cyclic = new cCyclicValues();
	cyclic.push(null);
	const lightSaber = new cLightSaber(300, 10, in_material);
	lightSaber.resetMaterial(in_material);
	cyclic.push(lightSaber);
	const smartPhone = new cSmartPhone(40, 80, 5, in_material);
	smartPhone.resetMaterial(in_material);
	cyclic.push(smartPhone);
	const tablet = new cSmartPhone(120, 80, 5, in_material);
	tablet.resetMaterial(in_material);
	cyclic.push(tablet);
	return cyclic;
})(gCyclicMaterials.currValue());

const gCyclicFigures = (in_material => {
	const cyclic = new cCyclicValues();
	const settings = [
		{
			HEADSIZE : 110,
			THICK1 : 50,
			BODY : {
				SHOULDER : 160,
				WAIST : 120,
				HEIGHT : 200
			},
			ARM : {
				LENGTH : 200,
				THICK2 : 55,
				NEGA : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(-10, 0, -10)
				},
				POSI : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(+10, 0, -10)
				}
			},
			LEG : {
				LENGTH : 250,
				THICK2 : 55,
				NEGA : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(-1, 0, -10)
				},
				POSI : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(+1, 0, -10)
				}
			}
		},
		{
			HEADSIZE : 100,
			THICK1 : 45,
			BODY : {
				SHOULDER : 110,
				WAIST : 180,
				HEIGHT : 200
			},
			ARM : {
				LENGTH : 190,
				THICK2 : 35,
				NEGA : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(-10, 0, -10)
				},
				POSI : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(+10, 0, -10)
				}
			},
			LEG : {
				LENGTH : 220,
				THICK2 : 35,
				NEGA : {
					DLT : VEC3(+35, 0, 0),
					DIR : VEC3(0, 0, -10)
				},
				POSI : {
					DLT : VEC3(-35, 0, 0),
					DIR : VEC3(0, 0, -10)
				}
			}
		},
		{
			HEADSIZE : 100,
			THICK1 : 45,
			BODY : {
				SHOULDER : 120,
				WAIST : 120,
				HEIGHT : 180
			},
			ARM : {
				LENGTH : 180,
				THICK2 : 45,
				NEGA : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(-10, 0, -10)
				},
				POSI : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(+10, 0, -10)
				}
			},
			LEG : {
				LENGTH : 220,
				THICK2 : 45,
				NEGA : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(0, 0, -10)
				},
				POSI : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(0, 0, -10)
				}
			}
		},
		{
			HEADSIZE : 100,
			THICK1 : 15,
			BODY : {
				SHOULDER : 70,
				WAIST : 50,
				HEIGHT : 120
			},
			ARM : {
				LENGTH : 140,
				THICK2 : 20,
				NEGA : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(-10, 0, -10)
				},
				POSI : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(+10, 0, -10)
				}
			},
			LEG : {
				LENGTH : 160,
				THICK2 : 20,
				NEGA : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(-1, 0, -10)
				},
				POSI : {
					DLT : VEC3(0, 0, 0),
					DIR : VEC3(+1, 0, -10)
				}
			}
		}
	];
	settings.forEach(in_setting => {
		const upperBodyRatio = 0.6;
		const radius = in_setting.THICK1 / 2;
		// body
		const body = roundedBoxBody(
			in_setting.BODY.SHOULDER,
			in_setting.BODY.WAIST,
			[
				in_setting.BODY.HEIGHT * (1 - upperBodyRatio),
				in_setting.BODY.HEIGHT * upperBodyRatio
			],
			radius
		);
		// head
		const head = new cHead(in_setting.HEADSIZE / 2);
		body.addToMoving(head);
		head.position.z = radius / 2;
		// arm (negative)
		const narm = createCapsuleArm1(in_setting.ARM.THICK2 / 2, radius, in_setting.ARM.LENGTH, 2);
		narm.object.lookAt(in_setting.ARM.NEGA.DIR);
		body.addToMoving(narm.object);
		narm.object.position.x = (in_setting.BODY.SHOULDER / 2 - radius) * -1;
		narm.object.position.add(in_setting.ARM.NEGA.DLT);
		// arm (positive)
		const parm = createCapsuleArm1(in_setting.ARM.THICK2 / 2, radius, in_setting.ARM.LENGTH, 2);
		parm.object.lookAt(in_setting.ARM.POSI.DIR);
		body.addToMoving(parm.object);
		parm.object.position.x = (in_setting.BODY.SHOULDER / 2 - radius) * +1;
		parm.object.position.add(in_setting.ARM.POSI.DLT);
		// leg (negative)
		const nleg = createCapsuleArm1(in_setting.LEG.THICK2 / 2, radius, in_setting.LEG.LENGTH, 2);
		nleg.object.lookAt(in_setting.LEG.NEGA.DIR);
		body.addToAnchor(nleg.object);
		nleg.object.position.x = (in_setting.BODY.WAIST / 2 - radius) * -1;
		nleg.object.position.add(in_setting.LEG.NEGA.DLT);
		// leg (positive)
		const pleg = createCapsuleArm1(in_setting.LEG.THICK2 / 2, radius, in_setting.LEG.LENGTH, 2);
		pleg.object.lookAt(in_setting.LEG.POSI.DIR);
		body.addToAnchor(pleg.object);
		pleg.object.position.x = (in_setting.BODY.WAIST / 2 - radius) * +1;
		pleg.object.position.add(in_setting.LEG.POSI.DLT);
		// figure
		const figure = new cFigure(head, body, narm.object, parm.object, nleg.object, pleg.object);
		figure.resetMaterial(in_material);
		cyclic.push(figure);
	});
	return cyclic;
})(gCyclicMaterials.currValue());

(in_index => {
	if (in_index !== false) {
		gCyclicFigures.setCurrentIndex(in_index);
	}
})(getParam('figure'));

let gDoubleFigure = null;

function incrementMaterial() {
	const incremented = gCyclicMaterials.incrementedValue();
	// gCyclicMaterials --> gCyclicItems
	gCyclicItems.forEach(in_item => {
		if (in_item) {
			in_item.resetMaterial(incremented);
		}
	});
	// gCyclicMaterials --> gCyclicFigures
	gCyclicFigures.forEach(in_figure => {
		in_figure.resetMaterial(incremented);
	});
	if (gDoubleFigure) {
		gDoubleFigure.material = incremented;
	}
}

function incrementItem() {
	/*
		*** NOTE ***
		when an Object3D is added to another object,
		it will be removed from its current parent object.
		so not all figures but only current figure should be handled.
	*/
	gCyclicFigures.currValue().resetItem(gCyclicItems.incrementedValue());
}

/*
	(3) ui & dom setting
*/

const WORLD_RADIUS = 1000;

const gWorld = new cSphericalWorld(WORLD_RADIUS);

gCyclicFigures.forEach(in_figure => {
	/*
		*** NOTE ***
		adhoc!! without this process, morphing will be failed.
		maybe some initializ process, which includs scene.add(), is required.
	*/
	gWorld.add(in_figure);
	gWorld.remove(in_figure);
});

gWorld.add(gCyclicFigures.currValue());

function restoreFigureAndItem(in_figure, in_poseData) {
	let item = gCyclicItems.currValue();
	let itemClass = item ? item.constructor.name : null;
	const targetItemClass = in_poseData.hasOwnProperty('ITEM_CLASS') ? in_poseData['ITEM_CLASS'] : null;
	let cnt = 10;
	while (itemClass !== targetItemClass) {
		item = gCyclicItems.incrementedValue();
		itemClass = item ? item.constructor.name : null;
		if (cnt-- === 0) {
			throw new Error('loop : restoreFigureAndItem');
		}
	}
	in_figure.resetItem(item);
	in_figure.restorePoseData(in_poseData);
}

const GALLERY_PATH = './gallery/';

(in_pose => {
	if (in_pose === false) {
		return;
	}
	// in_pose : posture.situation.emotion.usecase
	const path = GALLERY_PATH + in_pose + '.txt';
	getResource(path).then(in_json => {
		const pose = JSON.parse(in_json);
		restoreFigureAndItem(gCyclicFigures.currValue(), pose);
		gWorld.setViewCode(pose['WORLD_VIEWCODE']);
	}).catch(in_err => {
	    console.error(in_err);
	});
})(getParam('pose'));

function uiChangeColor() {
	const currColor = new THREE.Color(gCyclicColors.currValue());
	const nextColor = new THREE.Color(gCyclicColors.nextValue());
	let delta = 0.05;
	let interpolation = 0;
	const hook = () => {
		interpolation += delta;
		if (interpolation < 1) {
			let tempColor = currColor.clone().lerp(nextColor, interpolation);
			(gCyclicMaterials.currValue()).color.setHex(tempColor.getHex());
		} else {
			gWorld.removeAnimationHook(hook);
			incrementColor();
		}
	};
	gWorld.addAnimationHook(hook);
}

function uiChangeMaterial() {
	const flashEffect = 0xEEEEEE;
	gWorld.motionFog(flashEffect, 0, 100, 200).then(() => {
		incrementMaterial();
		return gWorld.motionFog(flashEffect, 100, 50, 200);
	});
}

function geometryTransition(in_geoCurr, in_geoNext, in_material, in_callback) {
	in_geoCurr.morphAttributes.position = [in_geoNext.attributes.position];
	// use morphingFigure only during morphing
	const morphingMesh = new THREE.Mesh(in_geoCurr, in_material);
	let morph = 0;
	const hook = () => {
		if (morph > 1) {
			gWorld.removeAnimationHook(hook);
			gWorld.remove(morphingMesh);
			if (in_callback) {
				(in_callback)();
			}
			in_geoCurr.dispose();
			in_geoNext.dispose();
		} else {
			morph += 0.05;
			morphingMesh.morphTargetInfluences[0] = morph;
		}
	};
	gWorld.add(morphingMesh);
	gWorld.addAnimationHook(hook);
}

function uiChangeFigure() {
	const currFigure = gCyclicFigures.currValue();
	const nextFigure = gCyclicFigures.incrementedValue();
	const currItem = gCyclicItems.currValue();
	if (currItem) {
		currItem.removeFromParent();
	}
	const currGeometry = currFigure.cloneGeometry(false);
	const nextGeometry = nextFigure.cloneGeometry(false);
	const material = gCyclicMaterials.currValue();
	const callback = () => {
		gWorld.add(nextFigure);
		if (currItem) {
			nextFigure.resetItem(currItem);
		}
	};
	gWorld.remove(currFigure);
	geometryTransition(currGeometry, nextGeometry, material, callback);
}

function uiChangeItem() {
	gWorld.motionKnock().then(() => {
		incrementItem();
	});
}

function uiDefaultView() {
	gWorld.motionViewFrom(VEC3(0, 0, 1));
}

const CLIPMARGIN = 10;

const uiPose = (() => {
	const knock = nonReentrantAsync(async () => {
		SE_BEEP.play();
		await gWorld.motionKnock();
	});
	let closureData = null;
	function save() {
		knock();
		const pose = gCyclicFigures.currValue().copyPoseData();
		pose['WORLD_VIEWCODE'] = gWorld.getViewCode();
		closureData = JSON.stringify(pose);
		// console.log(closureData);
		if (getParam('save')) {
			const path = GALLERY_PATH + 'save.php';
			const obj = {
				poseImg : gWorld.base64png(CLIPMARGIN),
				poseJson : closureData
			};
			postResource(path, obj).then(in_response => {
			    console.log('saved on the server-side');
			}).catch(in_err => {
			    console.error(in_err);
			});
		}
	}
	function restore() {
		if (!closureData) {
			return;
		}
		knock();
		const pose = JSON.parse(closureData);
		restoreFigureAndItem(gCyclicFigures.currValue(), pose);
		gWorld.setViewCode(pose['WORLD_VIEWCODE']);
		/*
			*** NOTE ***
			the morphing process for the spherical geometry part is not working properly

			// const figure = gCyclicFigures.currValue();
			// const currGeometry = figure.cloneGeometry(false);
			// figure.restorePoseData(closureData, serialize);
			// const nextGeometry = figure.cloneGeometry(false);
			// const material = gCyclicMaterials.currValue();
			// const callback = () => {
			//     gWorld.add(figure);
			// };
			// gWorld.remove(figure);
			// geometryTransition(currGeometry, nextGeometry, material, callback);
		*/
	}
	return {save, restore};
})();

const gCyclicDouble = new cCyclicValues(
	{
		text : 'double (near)',
		func : uiDoubleNear
	},
	{
		text : 'double (far)',
		func : uiDoubleFar
	},
	{
		text : 'without double',
		func : uiWithoutDouble
	}
);

function uiIncrementDouble(in_elem) {
	const currDouble = gCyclicDouble.currValue();
	const nextDouble = gCyclicDouble.incrementedValue();
	in_elem.innerText = nextDouble.text;
	in_elem.removeEventListener('click', currDouble.func);
	in_elem.addEventListener('click', nextDouble.func);
}

async function uiDeletDouble() {
	/*
		*** NOTE ***
		uiDeletDouble be called with await.
		without it, gDoubleFigure may be disposed during using.
	*/
	if (!gDoubleFigure) {
		return;
	}
	const tempMaterial = gDoubleFigure.material.clone();
	tempMaterial.transparent = true;
	gDoubleFigure.material = tempMaterial;
	const InitOpacity = 1.0;
	const lastOpacity = 0.0;
	await gWorld.easeOut(InitOpacity, lastOpacity, 300, (in_currOpacity) => {
		tempMaterial.opacity = in_currOpacity;
	});
	gWorld.remove(gDoubleFigure);
	tempMaterial.dispose();
	gDoubleFigure.geometry.dispose();
	gDoubleFigure = null;
}

async function uiShowDouble(in_distance) {
	await uiDeletDouble();
	gDoubleFigure = new THREE.Mesh(
		gCyclicFigures.currValue().cloneGeometry(false),
		gCyclicMaterials.currValue());
	gDoubleFigure.raycast = () => {};
	gWorld.add(gDoubleFigure);
	gWorld.startRotation(VEC3().random().multiplyScalar(0.005));
	const vec3 = gWorld.getCameraPos().negate().normalize();
	await gWorld.easeOut(0, in_distance, 500, (in_currDistance) => {
		gDoubleFigure.position.copy(vec3.clone().multiplyScalar(in_currDistance));
	});
	gWorld.stopRotation();
}

function uiDoubleNear(in_ev) {
	uiIncrementDouble(in_ev.target);
	uiShowDouble(200);
}

function uiDoubleFar(in_ev) {
	uiIncrementDouble(in_ev.target);
	uiShowDouble(400);
}

async function uiWithoutDouble(in_ev) {
	uiIncrementDouble(in_ev.target);
	await uiDeletDouble();
}

/*
	*** NOTE ***
	in Safari, using await to get audio will cause the process to fail.
	I'm not sure of the reason, but top-level await might be the cause.
	this time use then() to avoid the issue.
*/

let SE_BEEP = beep(2000);
let SE_DUMMY = beep(10);
let SE_SHUTTER = SE_BEEP;
let SE_RELEASE = SE_BEEP;

SOUND.SHUTTER.then(in_decompress => {
	SE_SHUTTER = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

SOUND.RELEASE.then(in_decompress => {
	SE_RELEASE = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

function takeShotSound() {
	SE_SHUTTER.play();
}

function takeShotFlash() {
	const flash = document.createElement('div');
	Object.assign(flash.style, {
		position : 'fixed',
		left : '0px',
		top : '0px',
		width : '100%',
		height : '100%',
		background : 'white',
		zIndex : 2 ** 31 - 1,
	});
	document.body.appendChild(flash);
	autoTransition(flash, 'opacity 0.2s ease-out', 1, 0);
	flash.addEventListener('transitionend', () => {
		document.body.removeChild(flash);
	});
}

function uiGetScreenShot() {
	takeShotSound();
	takeShotFlash();
	(async () => {
		/*
			*** NOTE ***
			the browser treats the data URL as a resource when using fetch.
			the fetch function retrieves the data and allows us to convert it into a Blob.
		*/
		const response = await fetch(gWorld.base64png(CLIPMARGIN));
		const blob = await response.blob();
		try {
			await navigator.clipboard.write([
				new ClipboardItem({'image/png': blob})
			]);
		} catch (err) {
			alert(err);
		}
	})();
}

function uiHelp() {
	const url = {
		ver : './version.txt',
		img : './stick-figure-help.gif',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div><img src="' + url.img + '" /></div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getResource(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.error(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		color : 'white',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Image Usage Rights</dt>',
		'<dd>All images generated using this software are free for users to use as they see fit.</dd>',
		'<dd>This includes the rights to modify, distribute, and use the images for both personal and commercial purposes without any restrictions.</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	startDialog(dialog);
}

(in_settings => {
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	in_settings.forEach(in_setting => {
		let button = document.createElement('button');
		button.innerText = in_setting.text;
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})([
	{
		text : 'next color',
		func : uiChangeColor
	},
	{
		text : 'next material',
		func : uiChangeMaterial
	},
	{
		text : 'next figure',
		func : uiChangeFigure
	},
	{
		text : 'next item',
		func : uiChangeItem
	},
	{
		text : 'default position',
		func : uiDefaultView
	},
	{
		text : 'save pose',
		func : uiPose.save
	},
	{
		text : 'restore pose',
		func : uiPose.restore
	},
	{
		text : gCyclicDouble.currValue().text,
		func : gCyclicDouble.currValue().func
	},
	{
		text : 'screenshot',
		func : uiGetScreenShot
	},
	{
		text : 'help',
		func : uiHelp
	},
	{
		text : 'rights',
		func : uiRights
	},
	{
		text : 'corridor',
		func : () => location.href = 'https://pj-corridor.net/'
	}
]);

const TRANSPARENT_IMAGE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADBJREFUOE9jTEtL+8+ABxgbG+OTZmAcNWBYhMHMmTPxpoOzZ8/iTwejBjAwDv0wAADSgj/p4jinSwAAAABJRU5ErkJggg==';

function drawBackground(in_canvas) {
	Object.assign(in_canvas.style, {
		backgroundImage : 'url(' + TRANSPARENT_IMAGE + ')',
		backgroundRepeat : 'repeat',
		backgroundSize : 'auto',
		position : 'absolute',
		left : 0,
		top : 0,
		zIndex : -1
	});
}

const gBackgroundCanvas = document.createElement('CANVAS');

function setupBody(in_document) {
	if (!in_document.body) {
		in_document.documentElement.appendChild(in_document.createElement('BODY'));
	}
	Object.assign(in_document.body.style, {
		margin : '0',
		overflow : 'hidden'
	});
}

function createChildWindow(in_document) {
	return new Promise(in_callback => {
		setupBody(in_document);
		const iframe = in_document.createElement('iframe');
		in_document.body.appendChild(iframe);
		Object.assign(iframe.style, {
			width: '100%',
			height: '100%',
			border: 'none'
		});
		/*
			*** NOTE ***
			although Chrome can use iframe.contentDocument right after createElement,
			Firefox can not use it ant needs to use asynchronous process.
			by the way, if you use not timer but load event,
			your code will not work for Chrome.
		*/
		setTimeout(() => {
			setupBody(iframe.contentDocument);
			(in_callback)(iframe.contentWindow);
		}, 0);
	});
}

document.addEventListener('DOMContentLoaded', (async () => {
	/*
		*** NOTE ***
		without iframe (outer window),
		geometry in event will be wrong because of google ads
	*/
	const outer = await createChildWindow(document);
	let resizeWorld = in_ev => {
		gWorld.resize(outer.innerWidth, outer.innerHeight);
		gBackgroundCanvas.width = outer.innerWidth;
		gBackgroundCanvas.height = outer.innerHeight;
		drawBackground(gBackgroundCanvas);
	};
	outer.addEventListener('resize', debouncing(resizeWorld, 300));
	outer.dispatchEvent(new Event('resize'));
	outer.document.body.appendChild(gWorld.canvas);
	outer.document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

/*
	(4) event handlers
*/

(() => {
	class state {
		static #transitions = {
			waiting : Symbol(),
			operating : Symbol(),
			animating : Symbol()
		};
		static #current;
		static {
			state.set('waiting');
		}
		static is(in_transition) {
			return state.#current === state.#transitions[in_transition];
		}
		static set(in_transition) {
			state.#current = state.#transitions[in_transition];
		}
		static #_obj = null;
		static set obj(in_obj) {
			if (in_obj) {
				state.set('operating');
			} else {
				state.set('waiting');
			}
			state.#_obj = in_obj;
		}
		static get obj() {
			return state.#_obj;
		}
		static far = false;
		static #_wideMode = false;
		static get isWideMode() {
			return state.#_wideMode;
		}
		static #_timer1 = null;
		static #_timer1_ms = 500;
		static observeLongPush(in_callback) {
			state.#_wideMode = false;
			state.unobserveLongPush();
			state.#_timer1 = setTimeout(() => {
				if (state.is('operating')) {
					state.#_wideMode = true;
					(in_callback)();
				}
				state.unobserveLongPush();
				state.unobserveRepeatPush();
			}, state.#_timer1_ms);
		}
		static unobserveLongPush() {
			if (state.#_timer1) {
				clearTimeout(state.#_timer1);
				state.#_timer1 = null;
			}
		}
		static #_timer2 = null;
		static #_timer2_ms = 300;
		static observeRepeatPush(in_callback) {
			if (state.#_timer2) {
				if (state.is('operating')) {
					state.#_wideMode = true;
					(in_callback)();
				}
				state.unobserveLongPush();
				state.unobserveRepeatPush();
			} else {
				state.#_timer2 = setTimeout(() => {
					state.#_timer2 = null;
				}, state.#_timer2_ms);
			}
		}
		static unobserveRepeatPush() {
			if (state.#_timer2) {
				clearTimeout(state.#_timer2);
				state.#_timer2 = null;
			}
		}
		static initialize() {
			state.obj = null;
			state.far = false;
			state.#_wideMode = false;
		}
		static help = false;
	}
	const speak = makeSpeaker({width : 250, fontSize : 'large', display : 2000});
	const start = in_ev => {
		if (!state.is('waiting')) {
			return;
		}
		const ndc = ndcFromEvent(in_ev);
		const intersects = gWorld.intersectPositive(ndc);
		if (intersects.length === 0) {
			return;
		}
		const rayHit = intersects[0];
		// for #makeRoughGeometry(), and addMeshToBone()
		const target = rayHit.object[instanceInAncestor](cAbstractPart);
		if (!target) {
			// uncontrollable object
			return;
		}
		const cameraPos = gWorld.getCameraPos();
		const objectPos = target.getWorldPosition(VEC3());
		const fineAdjustment = 0.9;
		state.far = (rayHit.distance * fineAdjustment > cameraPos.distanceTo(objectPos));
		state.obj = target;
		// not lookAt(cameraPos), but lookAt(raycaster.ray.direction.negate())
		state.obj.activateDraggingRcv(objectPos.add(cameraPos));
		if (cJointedSolidPart.stretchable(state.obj)) {
			const callback = () => {
				cJointedSolidPart.highlightAt(state.obj, true);
				SE_BEEP.play();
			};
			state.observeLongPush(callback);
			state.observeRepeatPush(callback);
			if (!state.help) {
				speak('long-push or double click for wide-mode');
				state.help = true;
			}
		}
		if (!state.isWideMode) {
			state.obj.highlight(true);
			SE_BEEP.play();
		}
	};
	const move = in_ev => {
		if (!state.is('operating')) {
			return;
		}
		state.unobserveLongPush();
		const ndc = ndcFromEvent(in_ev);
		let intersects;
		if (state.far) {
			intersects = gWorld.intersectNegative(ndc, cAbstractPart.operatingLayer);
		} else {
			intersects = gWorld.intersectPositive(ndc, cAbstractPart.operatingLayer);
		}
		if (intersects.length > 0) {
			// receiver (CircleGeometry or SphereGeometry)
			if ((intersects.length === 1) && (state.isWideMode)) {
				// receiver (only CircleGeometry)
				if (cJointedSolidPart.stretchAt(state.obj, intersects[0].point)) {
					// (1) bendAt() may be applied to ancestor
					return;
				}
			}
			// (2) bendAt() is applied to state.obj
			state.obj.bendAt(intersects[0].point);
			if (state.obj instanceof cSmartPhone) {
				gCyclicFigures.currValue().resetItemUpToHead();
			}
		} else {
			// (3) state.obj is released
			const hook = (in_obj => {
				return () => {
					/*
						when stop will be called during animation,
						state.obj will be set to null.
						so bind state.obj to callback.
					*/
					if (in_obj.moreShrink()) {
						return;
					}
					gWorld.removeAnimationHook(hook);
					stop(new Event('mouseout'));
				}
			})(state.obj);
			SE_RELEASE.play();
			state.set('animating')
			gWorld.addAnimationHook(hook);
		}
	};
	const stop = in_ev => {
		if (state.is('waiting')) {
			return;
		}
		state.unobserveLongPush();
		if (state.isWideMode) {
			cJointedSolidPart.highlightAt(state.obj, false);
		} else {
			state.obj.highlight(false);
		}
		state.obj.activateReleasedRcv();
		state.initialize();
	};
	let handlers = {
		'mousedown' : start,
		'mousemove' : move,
		'mouseleave' : stop,
		'mouseout' : stop,
		'mouseup' : stop
	};
	let once = false;
	for (let [eventName, handler] of Object.entries(handlers)) {
		gWorld.canvas.addEventListener(eventName, in_ev => {
			if (!once) {
				/*
					*** NOTE ***
					Safari may restrict sound without user interaction.
					because of this, the sound does not work without this code.
				*/
				SE_DUMMY.play();
				once = true;
			}
			(handler)(in_ev);
		});
	}
})();

</script>
</body>
</html>
