<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports" : {
		"three" : "https://cdn.jsdelivr.net/npm/three@0.181.0/build/three.module.min.js",
		"utils" : "https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/utils/BufferGeometryUtils.js",
		"basic" : "./basic-functions.js",
		"rubik" : "./rubiks-cube.js",
		"sound" : "./sound-effect.js"
	}
}
</script>
</head>
<body>
<script id='worker-blob' type='text/plain'>

class facelet {
	static #dim = 3;
	static pieces = facelet.#dim ** 2;
	static sortedArr = [...'URFDLB'];
	static surfaces = facelet.sortedArr.length;
	static faceletCnt = facelet.surfaces * facelet.pieces;
	static makeComplete(in_isIx = true) {
		const comp = [];
		facelet.sortedArr.forEach((in_sticker, in_ix) => {
			const data = in_isIx ? in_ix : in_sticker;
			comp.push(...Array(facelet.pieces).fill(data));
		});
		return comp;
	}
	static #makeInitIndexes() {
		return Array.from({length : facelet.faceletCnt}, (_, i) => i);
	}
	/*
		                   ZN ZN ZN
		                XN 00 01 02 XP
		                XN 03 UU 05 XP
		                XN 06 07 08 XP
		                   ZP ZP ZP

		   YP YP YP        YP YP YP        YP YP YP        YP YP YP
		ZN 36 37 38 ZP  XN 18 19 20 XP  ZP 09 10 11 ZN  XP 45 46 47 XN
		ZN 39 LL 41 ZP  XN 21 FF 23 XP  ZP 12 RR 14 ZN  XP 48 BB 50 XN
		ZN 42 43 44 ZP  XN 24 25 26 XP  ZP 15 16 17 ZN  XP 51 52 53 XN
		   YN YN YN        YN YN YN        YN YN YN        YN YN YN

		                   ZP ZP ZP
		                XN 27 28 29 XP
		                XN 30 DD 32 XP
		                XN 33 34 35 XP
		                   ZN ZN ZN
	*/
	static #edgeRingMap = new Map([
		['U', [47, 46, 45, 11, 10,  9, 20, 19, 18, 38, 37, 36]],
		['R', [ 8,  5,  2, 45, 48, 51, 35, 32, 29, 26, 23, 20]],
		['F', [ 6,  7,  8,  9, 12, 15, 29, 28, 27, 44, 41, 38]],
		['D', [24, 25, 26, 15, 16, 17, 51, 52, 53, 42, 43, 44]],
		['L', [ 0,  3,  6, 18, 21, 24, 27, 30, 33, 53, 50, 47]],
		['B', [ 2,  1,  0, 36, 39, 42, 33, 34, 35, 17, 14, 11]]
	]);
	static #centerRingMap = new Map([
		['M', [ 1,  4,  7, 19, 22, 25, 28, 31, 34, 52, 49, 46]],
		['E', [48, 49, 50, 39, 40, 41, 21, 22, 23, 12, 13, 14]],
		['S', [ 3,  4,  5, 10, 13, 16, 32, 31, 30, 43, 40, 37]]
	]);
	static #axis = [
		['L', 'M', 'R'],
		['D', 'E', 'U'],
		['B', 'S', 'F']
	];
	static #surfaceR90 = [6, 3, 0, 7, 4, 1, 8, 5, 2];
	static #rotateEdge(in_ixArr, in_sticker, in_cnt = 1) {
		const cnt = (in_cnt + 4) % 4;
		if (cnt === 0) {
			return in_ixArr;
		}
		const ixArr = [...in_ixArr];
		// 1. surface of in_sticker
		const start = facelet.sortedArr.indexOf(in_sticker) * facelet.pieces;
		facelet.#surfaceR90.forEach((in_srcIx, in_dstIx) => ixArr[start + in_dstIx] = in_ixArr[start + in_srcIx]);
		// 2. ring around in_sticker
		const ring = facelet.#edgeRingMap.get(in_sticker);
		for (let i = 0; i < ring.length; i++) {
			const srcIx = ring[i];
			const dstIx = ring[(i + 3) % ring.length];
			ixArr[dstIx] = in_ixArr[srcIx];
		}
		if (cnt > 1) {
			return facelet.#rotateEdge(ixArr, in_sticker, (cnt - 1));
		} else {
			return ixArr;
		}
	}
	static #rotateCenter(in_ixArr, in_slice, in_cnt = 1) {
		const cnt = (in_cnt + 4) % 4;
		if (cnt === 0) {
			return in_ixArr;
		}
		const ixArr = [...in_ixArr];
		const ring = facelet.#centerRingMap.get(in_slice);
		for (let i = 0; i < ring.length; i++) {
			const srcIx = ring[i];
			const dstIx = ring[(i + 3) % ring.length];
			ixArr[dstIx] = in_ixArr[srcIx];
		}
		if (cnt > 1) {
			return facelet.#rotateCenter(ixArr, in_slice, (cnt - 1));
		} else {
			return ixArr;
		}
	}
	static moveArr = [];
	static {
		const initArr = facelet.#makeInitIndexes();
		let sameId = 0;
		facelet.sortedArr.forEach(in_sticker => {
			const axisId = facelet.#axis.findIndex(in_arr => in_arr.includes(in_sticker));
			const axisOrder = facelet.#axis[axisId].indexOf(in_sticker);
			const registerMove = in_angle => {
				facelet.moveArr.push({
					move : facelet.#rotateEdge(initArr, in_sticker, in_angle / 90),
					hint : {same : sameId, axis : axisId, order : axisOrder, angle : in_angle}
				});
			};
			registerMove(90);
			registerMove(180);
			registerMove(270);
			sameId++;
		});
		const sliceArr = ['M', 'E', 'S'];
		sliceArr.forEach(in_slice => {
			const axisId = facelet.#axis.findIndex(in_arr => in_arr.includes(in_slice));
			const axisOrder = facelet.#axis[axisId].indexOf(in_slice);
			const registerMove = in_angle => {
				facelet.moveArr.push({
					move : facelet.#rotateCenter(initArr, in_slice, in_angle / 90),
					hint : {same : sameId, axis : axisId, order : axisOrder, angle : in_angle}
				});
			};
			registerMove(90);
			registerMove(180);
			registerMove(270);
			sameId++;
		});
	}
	static canonical = [];
	static {
		const rotateGroup = {
			FtoR : [
				{sticker : 'U', cnt : 3},
				{sticker : 'E', cnt : 1},
				{sticker : 'D', cnt : 1}
			],
			RtoU : [
				{sticker : 'F', cnt : 3},
				{sticker : 'S', cnt : 3},
				{sticker : 'B', cnt : 1}
			],
			UtoF : [
				{sticker : 'L', cnt : 1},
				{sticker : 'M', cnt : 1},
				{sticker : 'R', cnt : 3}
			]
		}
		const initArr = facelet.#makeInitIndexes();
		const canonMoveArr = [
			// U === U
			[],
			['FtoR'],
			['FtoR', 'FtoR'],
			['FtoR', 'FtoR', 'FtoR'],
			// U === R
			['RtoU'],
			['RtoU', 'FtoR'],
			['RtoU', 'FtoR', 'FtoR'],
			['RtoU', 'FtoR', 'FtoR', 'FtoR'],
			// U === B
			['UtoF'],
			['UtoF', 'FtoR'],
			['UtoF', 'FtoR', 'FtoR'],
			['UtoF', 'FtoR', 'FtoR', 'FtoR'],
			// U === D
			['RtoU', 'RtoU'],
			['RtoU', 'RtoU', 'FtoR'],
			['RtoU', 'RtoU', 'FtoR', 'FtoR'],
			['RtoU', 'RtoU', 'FtoR', 'FtoR', 'FtoR'],
			// U === L
			['RtoU', 'RtoU', 'RtoU'],
			['RtoU', 'RtoU', 'RtoU', 'FtoR'],
			['RtoU', 'RtoU', 'RtoU', 'FtoR', 'FtoR'],
			['RtoU', 'RtoU', 'RtoU', 'FtoR', 'FtoR', 'FtoR'],
			// U === F
			['UtoF', 'UtoF', 'UtoF'],
			['UtoF', 'UtoF', 'UtoF', 'FtoR'],
			['UtoF', 'UtoF', 'UtoF', 'FtoR', 'FtoR'],
			['UtoF', 'UtoF', 'UtoF', 'FtoR', 'FtoR', 'FtoR']
		];
		canonMoveArr.forEach(in_rotateArr => {
			let tempArr = initArr;
			in_rotateArr.forEach(in_which => {
				rotateGroup[in_which].forEach(({sticker, cnt}) => {
					if (facelet.#edgeRingMap.has(sticker)) {
						tempArr = facelet.#rotateEdge(tempArr, sticker, cnt);
					} else {
						// facelet.#centerRingMap.has(sticker)
						tempArr = facelet.#rotateCenter(tempArr, sticker, cnt);
					}
				});
			});
			facelet.canonical.push(tempArr);
		});
		// debug for facelet.canonical
		if (false) {
			const comp = facelet.makeComplete(false);
			facelet.debugCanonical(comp);
		}
	}
	static debugCanonical(in_arr) {
		facelet.canonical.forEach((in_move, in_no) => {
			const moved = [];
			for (let i = 0; i < in_move.length; i++) {
				moved[i] = in_arr[in_move[i]];
			}
			console.log('canonical #' + in_no);
			facelet.debug(moved);
		});
	}
	static #surfaceTupleMap = (() => {
		const map = new Map();
		// for facelet.#c
		for (let tupleCnt = 1; tupleCnt <= 3; tupleCnt++) {
			const total = facelet.pieces * tupleCnt;
			const nTupleArr = [];
			function nextDigit(in_arr, in_depth) {
				const tail = in_arr[in_arr.length - 1];
				const sum = in_arr.reduce((a, b) => a + b, 0);
				for (let i = tail; i >= 0; i--) {
					if (sum + i > total) {
						continue;
					}
					const arr = [...in_arr, i];
					if (in_depth === 1) {
						if (sum + i === total) {
							nTupleArr.push(arr);
						}
					} else {
						nextDigit(arr, in_depth - 1);
					}
				}
			}
			for (let i = facelet.pieces; i > 0; i--) {
				nextDigit([i], 5);
			}
			for (let i = 0; i < nTupleArr.length; i++) {
				let sum = 0;
				for (let j = 0; j < nTupleArr[i].length; j++) {
					sum += nTupleArr[i][j] * (10 ** (nTupleArr[i].length - j - 1));
				}
				nTupleArr[i] = sum;
			}
			map.set(tupleCnt, nTupleArr);
		}
		// console.log(map);
		return map;
	})();
	static pack = (() => {
		const digit1 = facelet.surfaces ** 1;
		const digit2 = facelet.surfaces ** 2;
		const representativeArr = new Uint8Array(facelet.faceletCnt);
		const digit = 3;
		return in_uArr => {
			representativeArr.fill(0xFF);
			facelet.canonical.forEach(in_move => {
				for (let i = 0; i < facelet.faceletCnt; i++) {
					if (in_uArr[in_move[i]] === representativeArr[i]) {
						// next elem
						continue;
					}
					if (in_uArr[in_move[i]] < representativeArr[i]) {
						// update representative by current in_move
						for (let j = i; j < facelet.faceletCnt; j++) {
							representativeArr[j] = in_uArr[in_move[j]];
						}
					}
					// next in_move
					break;
				}
			});
			let uniqStr = '';
			for (let i = 0; i < representativeArr.length / digit; i++) {
				const g = i * digit;
				const ch =
					representativeArr[g + 0] * digit2 +
					representativeArr[g + 1] * digit1 +
					representativeArr[g + 2];
				uniqStr += String.fromCharCode(ch);
			}
			return uniqStr;
		};
	})();
	static debug(in_arr) {
		const format = [
			['*', 'U', '*', '*'],
			['L', 'F', 'R', 'B'],
			['*', 'D', '*', '*']
		];
		const rows = format.length;
		const cols = format[0].length;
		const findStickerIx = in_sticker => {
			for (let row = 0; row < rows; row++) {
				for (let col = 0; col < cols; col++) {
					if (in_sticker === format[row][col]) {
						return {row, col}
					}
				}
			}
			throw new Error('invalid sticker');
		};
		const table = Array.from({length : rows * facelet.#dim}, () => Array(cols * facelet.#dim).fill(null));
		facelet.sortedArr.forEach((in_sticker, in_ix) => {
			const ix = findStickerIx(in_sticker);
			for (let row = 0; row < facelet.#dim; row++) {
				for (let col = 0; col < facelet.#dim; col++) {
					const r = ix.row * facelet.#dim + row;
					const c = ix.col * facelet.#dim + col;
					const f = in_ix * (facelet.pieces) + row * facelet.#dim + col;
					table[r][c] = in_arr[f];
				}
			}
		});
		console.table(table);
	}
}

function applyMove(in_srcArr, in_dstArr, in_move) {
	for (let i = 0; i < in_move.length; i++) {
		in_dstArr[i] = in_srcArr[in_move[i]];
	}
}

class cPresetDistMap extends Map {
	static #maxDistanceDefault = 3;
	#setup(in_maxDistance) {
		const initArr = Uint8Array.from(facelet.makeComplete());
		this.set(facelet.pack(initArr), 0);
		const queue = [initArr];
		while (queue.length > 0) {
			const currArr = queue.shift();
			const depth = this.get(facelet.pack(currArr));
			if (depth >= in_maxDistance) {
				continue;
			}
			for (let i = 0; i < facelet.moveArr.length; i++) {
				const nextArr = new Uint8Array(facelet.faceletCnt);
				applyMove(currArr, nextArr, facelet.moveArr[i].move);
				const packed = facelet.pack(nextArr);
				if (this.has(packed)) {
					continue;
				}
				this.set(packed, depth + 1);
				queue.push(nextArr);
			}
		}
		// console.log('setup done : ', this.size, facelet.moveArr.length ** in_maxDistance);
	}
	constructor() {
		super();
		this.maxDistance = cPresetDistMap.#maxDistanceDefault;
		this.#setup(this.maxDistance);
	}
	update(in_maxDistance) {
		this.clear();
		this.maxDistance = in_maxDistance;
		this.#setup(this.maxDistance);
	}
}

const gPresetDistMap = new cPresetDistMap();

const BUDGET_ADDON = 4;

function countUntilSolve(in_initArr) {
	const answer = {found : false, distance : -1};
	const dfs = (in_currArr, in_rootBudget, in_currBudget, in_prevHint, in_visited) => {
		if (answer.found) {
			return;
		}
		const packed = facelet.pack(in_currArr);
		const currDist = gPresetDistMap.get(packed);
		if (currDist === undefined) {
			if (in_currBudget > gPresetDistMap.maxDistance) {
				if ((in_visited.get(packed) ?? -1) < in_currBudget) {
					in_visited.set(packed, in_currBudget);
				} else {
					// give up : already visited with more budget
					return;
				}
			} else {
				// give up : can't find in in_currBudget
				return;
			}
		} else {
			answer.found = true;
			answer.distance = (in_rootBudget - in_currBudget) + currDist;
			return;
		}
		const nextArr = new Uint8Array(facelet.faceletCnt);
		for (let i = 0; i < facelet.moveArr.length; i++) {
			if (answer.found) {
				return;
			}
			const nextHint = facelet.moveArr[i].hint;
			if (in_prevHint) {
				// pruning usind hint
				if (nextHint.same === in_prevHint.same) {
					// skip : the same rotation of the same group
					continue;
				} else {
					if (nextHint.axis === in_prevHint.axis) {
						if (nextHint.angle === in_prevHint.angle) {
							// skip : the same as the opposite rotation of the other group
							continue;
						}
						if (nextHint.order !== in_prevHint.order + 1) {
							// skip : should follow normalize sequence
							continue;
						}
					}
				}
			}
			applyMove(in_currArr, nextArr, facelet.moveArr[i].move);
			dfs(nextArr, in_rootBudget, in_currBudget - 1, nextHint, in_visited);
		}
	};
	const start = performance.now();
	const budgetLimit = gPresetDistMap.maxDistance + BUDGET_ADDON;
	for (let rootBudget = 0; rootBudget <= budgetLimit; rootBudget++) {
		const visited = new Map();
		dfs(in_initArr, rootBudget, rootBudget, null, visited);
		if (answer.found) {
			break;
		}
	}
	console.log(performance.now() - start + 'ms');
	if (answer.distance < 0) {
		return (budgetLimit + 1) + '+';
	} else {
		return answer.distance;
	}
}

self.addEventListener('message', (() => {
	const closure = {latest : null, wating : false};
	return in_ev => {
		const {mtype, value} = in_ev.data;
		if (mtype === 'solve') {
			closure.latest = value;
			if (closure.wating) {
				return;
			}
			closure.wating = true;
			setTimeout(() => {
				closure.wating = false;
				// it may be long time in this process
				self.postMessage({mtype : 'solved', value : countUntilSolve(closure.latest)});
			}, 0);
		} else {
			if (mtype === 'update') {
				gPresetDistMap.update(value);
				self.postMessage({mtype : 'updated', value : true});
			} else {
				console.log('invalid mtype : ' + mtype);
			}
		}
	};
})());

</script>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';
import {
	getResource,
	postResource,
	getParam,
	DEBUG,
	COLOR,
	randomString,
	snapToNotch,
	snapToPI,
	snapTo05PI,
	createPeriodicSin,
	createPeriodicCos,
	pseudoMessageDigest1,
	pseudoMessageDigest2,
	beep,
	isEmulated,
	throttling,
	thresholding,
	debouncing,
	nonReentrantAsync,
	autoTransition,
	startDialog,
	factoryBuilder,
	arrRand,
	arrTrim,
	cEase,
	cApproximateMap,
	cApproximateSet,
	cCyclicMap,
	cCyclicValues,
	forEachCombination,
	cChart,
	clipArea,
	clipClearArea,
	fillRoundRect,
	XYZ,
	VEC3,
	DIRECTION,
	ndcFromEvent,
	ndcToAbs,
	getWorldVec3,
	getWorldUp,
	instanceInAncestor,
	lookAtWithoutRotation,
	safeMergeGeometry,
	makeTrapezoidGeometryParts,
	trapezoidGeometryUtil,
	roundBoxGeometry,
	roundRegularBoxGeometry,
	roundTrapezoidGeometry,
	capsuleConfigure,
	customCapsuleGeometry,
	cSphericalWorld
} from 'basic';
import {
	cRubiksCube
} from 'rubik';
import * as SOUND from 'sound';

/*
	(1) Texture, MeshLambertMaterial, and BoxGeometry using cCache, which returns the same object in cache without creating.
*/

const textureFactory = factoryBuilder((in_w, in_h) => {
	const gradation = 4
	// gradation (from black to white)
	let maxDepth = 255;
	let styles = [];
	for (let i = 0; i < gradation; i++) {
		let depth = Math.ceil(maxDepth / (gradation - 1) * i);
		styles[i] = 'rgb(' + depth + ',' + depth + ',' + depth + ')';
	}
	// draw and convert using toDataUR
	let canvas = document.createElement('CANVAS');
	canvas.width = in_w;
	canvas.height = in_h;
	const ctx = canvas.getContext('2d');
	let radius = gradation + 2;
	/*
		Rect           RoundRect      RoundRect

		##########     ##########     ##########
		##########     ##******##     ##******##
		##########     #********#     #**++++**#
		##########     #********#     #*++++++*#
		########## --> #********# --> #*++++++*# --> ...
		##########     #********#     #*++++++*#
		##########     #********#     #**++++**#
		##########     ##******##     ##******##
		##########     ##########     ##########
	*/
	for (let i = 0; i < gradation; i++) {
		ctx.fillStyle = styles[i];
		if (i > 0) {
			ctx[fillRoundRect](i, i, in_w - i * 2, in_h - i * 2, radius - i);
		} else {
			ctx.fillRect(i, i, in_w - i * 2, in_h - i * 2);
		}
	}
	return (new THREE.TextureLoader()).load(canvas.toDataURL());
});

const materialFactory = factoryBuilder((in_w, in_h, in_color) => {
	return new THREE.MeshLambertMaterial({
		color : in_color,
		map : textureFactory.create(in_w, in_h)
	});
});

function boxMaterials(in_x, in_y, in_z, in_colors) {
	/*
		     2    
		     |   5
		     |  /
		    ###/
		    ###
		1 --#*#-- 0
		    /##
		   /###
		  /  |
		 4   |
		     3
	*/
	return [
		materialFactory.create(in_z, in_y, in_colors[0]),
		materialFactory.create(in_y, in_z, in_colors[1]),
		materialFactory.create(in_x, in_z, in_colors[2]),
		materialFactory.create(in_x, in_z, in_colors[3]),
		materialFactory.create(in_x, in_y, in_colors[4]),
		materialFactory.create(in_x, in_y, in_colors[5])
	];
}

const boxGeometryFactory = factoryBuilder((in_x, in_y, in_z) => {
	const radian = 6;
	const geometry = roundBoxGeometry(in_x - radian * 2, in_y - radian * 2, in_z - radian * 2, radian);
	geometry.parameters = {
		x : in_x,
		y : in_y,
		z : in_z
	};
	return geometry;
});

const DARKGRAY = 0x222222;
const LIGHTGRAY = 0x555555;
const HIGHLIGHT = 0x888888;

const ORANGE = 0xFFAA00;
const RED = 0xFF0000;
const WHITE = 0xFFFFFF;
const YELLOW = 0xFFFF00;
const BLUE = 0x3333FF;
const GREEN = 0x33CC33;

const EDGECOLOR = DARKGRAY;
const INSIDECOLOR = DARKGRAY;

const SURFACEx6 = [
	{NORM : DIRECTION.XP, INITCOLOR : RED},
	{NORM : DIRECTION.XN, INITCOLOR : ORANGE},
	{NORM : DIRECTION.YP, INITCOLOR : WHITE},
	{NORM : DIRECTION.YN, INITCOLOR : YELLOW},
	{NORM : DIRECTION.ZP, INITCOLOR : GREEN},
	{NORM : DIRECTION.ZN, INITCOLOR : BLUE}
];

const edgeMaterial = new THREE.MeshLambertMaterial({color : EDGECOLOR});

function pieceColorList(in_dimV3, in_ixV3) {
	/*
		piece ( hexahedron ) has surface x6
		|
		+- edge surface x0-3
		|	|
		|	+- orange, red, white, ...
		|
		+- inner surface x3-6
			|
			+- dark gray
	*/
	const colorList = [];
	// when in_ixV3 is on an edge, the color of SURFACEx6 is used
	SURFACEx6.forEach(({NORM, INITCOLOR}) => {
		XYZ.forEach(in_xyz => {
			switch (NORM[in_xyz]) {
			// the surface is facing the positive direction
			case +1 :
				// the position is at the positive edge
				if (in_ixV3[in_xyz] === in_dimV3[in_xyz] - 1) {
					colorList.push(INITCOLOR);
				} else {
					colorList.push(INSIDECOLOR);
				}
				break;
			// the surface is facing the negative direction
			case -1 :
				// the position is at the negative edge
				if (in_ixV3[in_xyz] === 0) {
					colorList.push(INITCOLOR);
				} else {
					colorList.push(INSIDECOLOR);
				}
				break;
			case 0 :
				break;
			}
		});
	});
	return colorList;
}

/*
	(2) shape, parts composition, and behavior of a Rubik's Cube
*/

class cCubeDimV3 extends THREE.Vector3 {
	get maxDim() {
		return Math.max(...this.toArray());
	}
	#sizeList(in_unitSize = 1) {
		const list = {};
		/*
			in case of 3x2x2, ...
			list.x = [in_unitSize, in_unitSize, in_unitSize]
			list.y = [in_unitSize, in_unitSize * 2]
			list.z = [in_unitSize, in_unitSize * 2]
		*/
		XYZ.forEach(in_xyz => {
			if (this[in_xyz] < this.maxDim) {
				// separate not 4=3+1 but 4=2+2
				if (this.maxDim % this[in_xyz] === 0) {
					const quotient = this.maxDim / this[in_xyz];
					list[in_xyz] = Array(this[in_xyz]).fill(in_unitSize * quotient);
				} else {
					list[in_xyz] = Array(this[in_xyz] - 1).fill(in_unitSize);
					list[in_xyz].push((this.maxDim - this[in_xyz] + 1) * in_unitSize);
				}
			} else {
				list[in_xyz] = Array(this[in_xyz]).fill(in_unitSize);
			}
		});
		return list;
	}
	#indexLoop(in_callback) {
		// first surface is at "new THREE.Vector3(0, 0, -1)"
		for (let z = 0; z < this.z; z++) {
			for (let y = 0; y < this.y; y++) {
				for (let x = 0; x < this.x; x++) {
					(in_callback)(VEC3(x, y, z));
				}
			}
		}
	}
	positionLoop(in_callback, in_unitSize, in_moveToV3 = VEC3()) {
		const sizeList = this.#sizeList(in_unitSize);
		/*
			each piece should be translated using translateV3

			before translated :

			   |
			   +---+
			   |   |
			   |   |
			   |   |
			---+---+-
			   |
			   |
			   |

			after translated :

			   |
			   |
			   |
			 +-+-+
			 | | |
			-+-+-+---
			 | | |
			 +-+-+
			   |
		*/
		const cubeCneter = this.maxDim * in_unitSize / 2;
		const translateV3 = in_moveToV3.clone().sub(VEC3(cubeCneter, cubeCneter, cubeCneter));
		this.#indexLoop(in_ixV3 => {
			const pieceSizeV3 = VEC3();
			const piecePosV3 = VEC3();
			XYZ.forEach(in_xyz => {
				const curr = in_ixV3[in_xyz];
				let start = 0;
				for (let i = 0; i < curr; i++) {
					start += sizeList[in_xyz][i];
				}
				pieceSizeV3[in_xyz] = sizeList[in_xyz][curr];
				piecePosV3[in_xyz] = start + pieceSizeV3[in_xyz] / 2;
			});
			piecePosV3.add(translateV3);
			(in_callback)(in_ixV3, piecePosV3, pieceSizeV3);
		});
	}
	isInsideCube(in_ixV3) {
		return XYZ.every(in_xyz => {
			return (0 < in_ixV3[in_xyz]) && (in_ixV3[in_xyz] < this[in_xyz] - 1);
		});
	}
}

class converter {
	// assume sorted as facelet.sortedArr order
	static #featuresArr = [
		{NORM : DIRECTION.YP, STICKER : 'U', O1 : DIRECTION.ZP, O2 : DIRECTION.XP, COLOR : WHITE},
		{NORM : DIRECTION.XP, STICKER : 'R', O1 : DIRECTION.YN, O2 : DIRECTION.ZN, COLOR : RED},
		{NORM : DIRECTION.ZP, STICKER : 'F', O1 : DIRECTION.YN, O2 : DIRECTION.XP, COLOR : GREEN},
		{NORM : DIRECTION.YN, STICKER : 'D', O1 : DIRECTION.ZN, O2 : DIRECTION.XP, COLOR : YELLOW},
		{NORM : DIRECTION.XN, STICKER : 'L', O1 : DIRECTION.YN, O2 : DIRECTION.ZP, COLOR : ORANGE},
		{NORM : DIRECTION.ZN, STICKER : 'B', O1 : DIRECTION.YN, O2 : DIRECTION.XN, COLOR : BLUE}
	];
	static stickerMap = (() => {
		const map = new Map();
		converter.#featuresArr.forEach(in_features => map.set(in_features.COLOR, in_features.STICKER));
		return map;
	})();
	static stickerOrder(in_sticker) {
		return Array.from(converter.stickerMap).findIndex(in_e => in_e[1] === in_sticker);
	}
	static #getOrderFeature(in_norm) {
		for (let i = 0; i < converter.#featuresArr.length; i++) {
			const obj = converter.#featuresArr[i];
			if (obj.NORM.equals(in_norm)) {
				return {O0 : converter.stickerOrder(obj.STICKER), ...obj};
			}
		}
		throw new Error('invalid param : ' + in_norm);
	}
	static sortedIndexes(in_srcArr) {
		/*
			in_srcArr = [
				{sticker : sticker-00, norm : norm-00, pos : world-pos-00, ...},
				{sticker : sticker-01, norm : norm-01, pos : world-pos-01, ...},
				...
				{sticker : sticker-53, norm : norm-53, pos : world-pos-53, ...}
			];
		*/
		const arr = in_srcArr.map(({norm, pos}, in_ix) => {
			const {O0, O1, O2} = converter.#getOrderFeature(norm);
			const quantize = in_vec => {
				let val = pos.dot(in_vec);
				return Math.abs(val) < 1e-3 ? 0 : Math.sign(val);
			};
			return {ix : in_ix, o0 : O0, o1 : quantize(O1), o2 : quantize(O2)};
		});
		arr.sort((a, b) => (a.o0 === b.o0) ? ((a.o1 === b.o1) ? a.o2 - b.o2 : a.o1 - b.o1) : a.o0 - b.o0);
		return arr.map(in_e => in_e.ix);
	}
}

class cCntRubiksCube extends cRubiksCube {
	static #url = (in_code => {
		return URL.createObjectURL(new Blob([in_code]));
	})(document.getElementById('worker-blob').textContent);
	static #worker;
	static {
		const instant = new Worker(cCntRubiksCube.#url);
		const delayed = new Worker(cCntRubiksCube.#url);
		delayed.postMessage({mtype : 'update', value : 4});
		const handler = in_ev => {
			const {mtype, value} = in_ev.data;
			if (mtype === 'updated') {
				instant.terminate();
				// replace worker to use powerful preset-data
				cCntRubiksCube.#worker = delayed;
				console.log('worker is updated');
				delayed.removeEventListener('message', handler);
			}
		};
		delayed.addEventListener('message', handler);
		cCntRubiksCube.#worker = instant;
	}
	static #execWorker(in_currArr, in_callback) {
		cCntRubiksCube.#worker.onmessage = in_ev => {
			const {mtype, value} = in_ev.data;
			if (mtype === 'solved') {
				(in_callback)(value);
			}
		};
		cCntRubiksCube.#worker.postMessage({mtype : 'solve', value : in_currArr}); 
	}
	rotateOnWorldAxis(in_axis, in_rad) {
		const reparentChildren = (a, b) => [...a.children].forEach(in_e => b.attach(in_e));
		const temp = new THREE.Object3D();
		reparentChildren(this, temp);
		temp.rotateOnWorldAxis(in_axis, in_rad);
		reparentChildren(temp, this);
	}
	countUntilSolve(in_callback) {
		const srcArr = [];
		const stickerArr = [];
		for (const piece of this.children) {
			Object.values(DIRECTION).forEach(in_direction => {
				const color = cCntRubiksCube.getColor(piece, in_direction);
				if (color === INSIDECOLOR) {
					return;
				}
				srcArr.push({
					sticker : converter.stickerMap.get(color),
					norm : in_direction,
					pos : piece.getWorldPosition(VEC3()),
				});
			});
		}
		const sorted = converter.sortedIndexes(srcArr);
		for (let i = 0; i < sorted.length; i++) {
			stickerArr[i] = srcArr[sorted[i]].sticker;
		}
		// facelet.debug(stickerArr);
		const currArr = Uint8Array.from(stickerArr.map(converter.stickerOrder));
		cCntRubiksCube.#execWorker(currArr, in_callback);
	}
}

/*
	(3) ui & dom setting

	gWorld (cSphericalWorld)
	|
	+-- gCube (cRubiksCube)
		|
		+-- meshes <--- gMeshLevelMap
*/


const FUKIDASHI = 'data:image/png;base64,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RV19rU0HgpLeogVSmiXDqJaIuPEOLqB69mmXbCW95QF6tElJtn/ezyjFm24ELU6WZboR0FsfkEtHj8DxXTti9frNblD54o+X6lYvAZz0VAREQAREQASaOgFqhrS0NLDQk2VZwZoiknzYVu/evXBs9yMithrvYALKhsfp4LHQIdW27Z8efQRGjTgfLdPTYVmhB9qiRRouGDkco88/1w0qX/H1Rsyd9zYKChRUHskvg+oSAREQAREQAREIn0BqSgr69jodh7ZrxYPq7cY7kIDyuu7KPW/ZFtod3yUDtCzR5EYlx9ZDFcuiK68lrr36SjeoPD2lGZas+RxTX5wJJsfissVQx+k9ERABERABEYguAdXelAkYOxC6d++G1ulpxFBvN17NAirAddeheYp9Zt/TjPVpGGhhYssHKpZludlB3aDy00/CjrwCvDJ3AaZMmyERdSBw+kwEREAEREAERCAqBGj86du7Nw47pCPvjVfvNmoSUH7XXYtk2z792O4472fnuH5KywrtuqvaE8uiJcobVD7whB7YtHsvZktEVcWk1yLQpAhosCIgAiLQkARSjFfslBP898arVzoDO+RAaH0q88wzUqndyYd1xu/HXokzBw2s9ZJCqr2zzhiEcWPHQCIqJGm9KQIiIAIiIAIiECMCvnvjHdKuDVusVxxUKAFl+wLHueru5ON6YNCA/q71ia3VtjC6fvCZZ0hE1RZcVPZXpSIgAiIgAiLQdAnQsNO/bx907tCOEOoVB1VdQAVYn47r2hEjhw91s4CypboWiai6ktNxIiACIiACIiACiCACiqjUlJR6x0FVFVDVrE8D+/ertesu1DhrFFHTZ4L3wwl1jN4TAREQAREQAREQgUgSsCwLxx97NLq0bM5q6xwHFSygomB9Yu98paqI2paThxVr/odPPv0MZWVlvt30KAIiIAIiEF8E1BsRaDQELMvGoV27oGXzVI6pznFQgQIqatYn9tBXfCLqhuuuwuifDcQ1V1yM03/6EyQnJ/t20aMIiIAIiIAIiIAIRIWAbVvo1u1wtKpnPqhKAVVhfTK9bXdU5/b45Xk/q3fsk6kr5EYRdc6QwXj8rw+Aj3wdcke9KQIi4CWgf0VABERABCJCgDFQfXv3QucMN5C8znVWCqiy/W40ugXYqc2S3du11LnWMA7kACic+BjG7tpFBERABERABERABCJC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eCSlIgIiIAIiIAIikDAEiqOQuiBw8FUFFBiZ7kaoGzHFdOdMe87054EH6bkIiAAgBiIgAiIgAvFJgNanzOUr8Pk3G5m6IKKxT74R274n/scANx7TnTPtOdOf+z/XExEQAREQAREQARGIUwJceVdYWIS5897GN9uymLogorFPvmFXF1DG8sT05sYKtZvpzpn2nD5EqjnfQfHxqF6IgAiIgAiIgAiIQDABVzzNfwurPl8XNesTWwwloIAAKxTTnjP9OX2JPEBFBERABERABESgHgR0aNQI0NiTuWwZ5rw+D9/uzIma9YkDCC2gaIUqL99jdnCY9vzzbzdi2QoFkxse2kRABERABERABOKUQElJCVauXov1W3dEZeVd4LBrElDwBZMz7fn27H1YZTrEjgUerOciIAIikIAE1GUREIFGSIDWp6XLluOjpSvBGG4zxKjEPpl63c12/w31T4Abjx1ZmLkSy1euUkqDUKz0ngiIgAiIgAiIQIMRCAwc/3zzNjCGm7HcjOk2nXJMifhWs4CiG8+yd7MD7MiunFwoM3nE+TfNCjVqERABERABEYgggWqB48DGMk/5MMZ0R7CZoKoOJKCCgsm9mcmXuzflo9ILqkUvREAEREAEREAERKABCNB193FmJl4JDBxPsobhu082mu5E1Ppk6vNvBxZQAVaoEsdxeDM+3pSPnfXXoCciIAIiIAIiIAIi0AAEaNApKCjAK/96Ayu+/T7qgeOBQzyYgAqyQvFmfO9+sBBFRUVgpwMr0nMREAEREAERiC4B1S4CwQQonqbNeAkrP1uHwjLHsWLguvP14OACSlYoHys9ioAIiIAIiIAIxAkBGnM+zlyGt99biM1789mrnLIYuO7YEEs4AqqaFeo/xgpVWFgoKxQJqohAEyKgoYqACIhAPBBgKNHij5fiuSkzsXbTjzFZdVd13OEJqCpWqP9+tQE0mdF0VrVCvRYBERABERABERCBaBFgCFFBQaF7r7vlX2+MuevON65wBVSQFWqzMZW9/d4iZC5brrxQPpIxeVQjIiACIiACItB0CVA85efnY9qLM7Fkzefee90x7skpHxrtVXdVqYcvoAKsUMwL9c3WHXjvw4VuWoOqleq1CIiACIiACIiACPgJROhJYWER3nhzPl5/+z1sysljioKNZQ0gnjic2ggorxXKUz6MUe67i0udVZ98CaZN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';

const CUBE_SIZE = 400;

const WORLD_RADIUS = CUBE_SIZE * 10;
const WORLD_INIT_ZOOM = WORLD_RADIUS / 3;

const gWorld = new cSphericalWorld(WORLD_RADIUS);

const gCube = new cCntRubiksCube();

gWorld.add(gCube);

gWorld.moveView(2.5, 0.5);
gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);

(async in_cubeSize => {
	const cubeDim = new cCubeDimV3(3, 3, 3);
	const unitSize = in_cubeSize / cubeDim.maxDim;
	const pieces = [];
	// see cCubeDimV3 implementation
	cubeDim.positionLoop((in_ixV3, in_posV3, in_sizeV3) => {
		if (cubeDim.isInsideCube(in_ixV3)) {
			// console.log('inside', in_ixV3);
			return;
		}
		const geometry = boxGeometryFactory.create(...in_sizeV3.toArray());
		// geometry has 7 groups (sub meshes)
		const colors = pieceColorList(cubeDim, in_ixV3);
		const materials = boxMaterials(...in_sizeV3.toArray(), colors);
		materials.push(edgeMaterial);
		/*
			*** NOTE ***
			when you use materials (= array) for "new THREE.Mesh",
			the geometry should be devided into groups (= sub meshes).
		*/
		const piece = new THREE.Mesh(geometry, materials);
		piece.position.copy(in_posV3);
		pieces.push(piece);
	}, unitSize);
	await gWorld.motionFog(0x000000, 0, 100);
	gCube.setupAllPieces(pieces);
})(CUBE_SIZE);

class cWarpLine {
	static #speed = 10;
	static #gradation = 10;
	constructor(in_canvas) {
		const w = in_canvas.width;
		const h = in_canvas.height;
		this.ctx = in_canvas.getContext('2d');
		this.box = new THREE.Box2(
			new THREE.Vector2(0, 0),
			new THREE.Vector2(w, h)
		);
		this.from = new THREE.Vector2(w / 2, h / 2);
		this.#reset();
	}
	#reset() {
		const angle = Math.random() * Math.PI * 2;
		this.direction = new THREE.Vector2(Math.cos(angle), Math.sin(angle));
		this.speed = Math.random() * cWarpLine.#speed + 5;
		this.length = 0;
	}
	#curVec(in_scalar) {
		return this.from.clone().add(this.direction.clone().multiplyScalar(in_scalar));
	}
	#drawGrayLine(in_from, in_to, in_grayScale) {
		this.ctx.strokeStyle = COLOR.sGray(in_grayScale);
		this.ctx.beginPath();
		this.ctx.moveTo(in_from.x, in_from.y);
		this.ctx.lineTo(in_to.x, in_to.y);
		this.ctx.stroke();
	}
	update() {
		this.length += this.speed;
		const to = this.#curVec(this.length);
		if (this.box.containsPoint(to)) {
			const notch = this.length / cWarpLine.#gradation;
			for (let i = 0; i < cWarpLine.#gradation; i++) {
				this.#drawGrayLine(
					this.#curVec(notch * i),
					this.#curVec(notch * (i + 1)),
					255 / cWarpLine.#gradation * (i + 1)
				);
			}
		} else {
			/*
				*** NOTE ***
				even if overwritung using black,
				this.#drawGrayLine(this.from, to, 0x00);
				smudge of white line will remain.
			*/
			this.#reset();
		}
	}
}

function warpViewProgress(in_canvas, in_lineCount) {
	const warpLines = [];
	for (let i = 0; i < in_lineCount; i++) {
		warpLines.push(new cWarpLine(in_canvas));
	}
	return () => {
		warpLines.forEach(in_line => {
			in_line.update();
		});
	}
}

function complete() {
	const progress = warpViewProgress(gBackgroundCanvas, 50);
	gWorld.addAnimationHook(progress);
	const duration = 2000;
	gWorld.motionZoom2(WORLD_RADIUS * 1.5, duration * 0.9);
	setTimeout(() => {
		gWorld.removeAnimationHook(progress);
		gCube.removeCompleteCallback();
		const dialog = document.createElement('div');
		Object.assign(dialog.style, {
			width : 'auto',
			height : 'auto',
			color : 'white',
			background : 'black',
			borderRadius : '1em',
			padding : '1.5em'
		});
		([
			'<div>Congratulation !!</div>',
			'<div>( Your score is : ' + gCube.getScore() + ' )</div>',
			'<div>Thanks to your wisdom, peace in the universe has been preserved.</div>',
			'<div>Click to go next stage.</div>',
		]).forEach(in_fragment => {
			dialog.innerHTML += in_fragment;
		});
		startDialog(dialog, () => {
			drawCosmicView(gBackgroundCanvas, 400, 50);
			gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);
		});
		nextLevel(false);
	}, duration);
}

/*
	*** NOTE ***
	in Safari, using await to get audio will cause the process to fail.
	I'm not sure of the reason, but top-level await might be the cause.
	this time use then() to avoid the issue.
*/

let SE_BEEP = beep(2000);
let SE_DUMMY = beep(10);
let SE_MOVED = SE_BEEP;
let SE_ERROR = SE_BEEP;

SOUND.MOVED.then(in_decompress => {
	SE_MOVED = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

SOUND.ERROR.then(in_decompress => {
	SE_ERROR = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

function shuffle(in_count) {
	const randomRotation = (in_remaining_count) => {
		const callback = () => {
			SE_MOVED.play();
			gWorld.removeAnimationHook(progress);
			if (in_remaining_count > 1) {
				(randomRotation)(in_remaining_count - 1);
			} else {
				setTimeout(() => {
					gWorld.stopRotation();
					gCube.uiEnable();
				}, 500);
			}
		};
		const progress = gCube.makeRandomRotationProgress(callback, true);
		gWorld.addAnimationHook(progress);
	};
	gCube.registerCompleteCallback(complete);
	gCube.uiDisable();
	gWorld.startRotation(VEC3().random().multiplyScalar(0.05));
	(randomRotation)(in_count);
}

function makeShuffle(in_cnt) {
	return () => {
		shuffle(in_cnt);
	};
}

function uiHelp() {
	const url = {
		ver : './version.txt',
		img : './cube3d-help.gif',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div><img src="' + url.img + '" /></div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getResource(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.error(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		color : 'white',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Rights</dt>',
		'<dd>This software is based on MIT License.</dd>',
		'<dd>The code can be freely modified and reused.</dd>',
		'<dd>For full license details, please refer to :</dd>',
		'<dd>https://opensource.org/licenses/MIT</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	startDialog(dialog);
}

const ID_PREV_LEVEL = randomString();
const ID_NEXT_LEVEL = randomString();

(in_settings => {
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	in_settings.forEach(in_setting => {
		let button = document.createElement('button');
		if (in_setting.id) {
			button.id = in_setting.id;
		}
		if (in_setting.text) {
			button.innerText = in_setting.text;
		}
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})([
	{
		text : 'shuffle x3',
		func : makeShuffle(3)
	},
	{
		text : 'shuffle x5',
		func : makeShuffle(5)
	},
	{
		text : 'shuffle x10',
		func : makeShuffle(10)
	},
	{
		text : 'help',
		func : uiHelp
	},
	{
		text : 'rights',
		func : uiRights
	},
	{
		text : 'corridor',
		func : () => location.href = 'https://pj-corridor.net/'
	}
]);

function drawCosmicView(in_canvas, in_stars, in_nebulae_patterns, in_color = 0x000064) {
	const ctx = in_canvas.getContext('2d');
	const w = in_canvas.width;
	const h = in_canvas.height;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	for (let i = 0; i < in_nebulae_patterns; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const r = Math.random() * 100 + 50;
		const gradient = ctx.createRadialGradient(x, y, 0, x, y, r);
		gradient.addColorStop(0, COLOR.sRGBA(in_color, 127));
		gradient.addColorStop(1, COLOR.sRGBA(in_color, 0));
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2, false);
		ctx.fillStyle = gradient;
		ctx.fill();
	}
	for (let i = 0; i < in_stars; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const r = Math.random() * 1;
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2, false);
		ctx.fillStyle = 'white';
		ctx.fill();
	}
}

function drawBackground(in_canvas) {
	Object.assign(in_canvas.style, {
		position : 'absolute',
		left : 0,
		top : 0,
		zIndex : -1
	});
	drawCosmicView(in_canvas, 400, 50);
}

const gBackgroundCanvas = document.createElement('CANVAS');

function setupBody(in_document) {
	if (!in_document.body) {
		in_document.documentElement.appendChild(in_document.createElement('BODY'));
	}
	Object.assign(in_document.body.style, {
		margin : '0',
		overflow : 'hidden'
	});
}

function createChildWindow(in_document) {
	return new Promise(in_callback => {
		setupBody(in_document);
		const iframe = in_document.createElement('iframe');
		in_document.body.appendChild(iframe);
		Object.assign(iframe.style, {
			width: '100%',
			height: '100%',
			border: 'none'
		});
		/*
			*** NOTE ***
			although Chrome can use iframe.contentDocument right after createElement,
			Firefox can not use it ant needs to use asynchronous process.
			by the way, if you use not timer but load event,
			your code will not work for Chrome.
		*/
		setTimeout(() => {
			setupBody(iframe.contentDocument);
			(in_callback)(iframe.contentWindow);
		}, 0);
	});
}

document.addEventListener('DOMContentLoaded', (async () => {
	/*
		*** NOTE ***
		without iframe (outer window),
		geometry in event will be wrong because of google ads
	*/
	const outer = await createChildWindow(document);
	let resizeWorld = in_ev => {
		gWorld.resize(outer.innerWidth, outer.innerHeight);
		gBackgroundCanvas.width = outer.innerWidth;
		gBackgroundCanvas.height = outer.innerHeight;
		drawBackground(gBackgroundCanvas);
	};
	outer.addEventListener('resize', debouncing(resizeWorld, 300));
	outer.dispatchEvent(new Event('resize'));
	outer.document.body.appendChild(gWorld.canvas);
	outer.document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

const speak = (() => {
	const maxInt = 2 ** 31 - 1;
	const outer = document.createElement('DIV');
	document.body.appendChild(outer);
	const w = 200;
	const b = 20;
	const r = 20;
	const image = new Image();
	image.src = FUKIDASHI;
	image.onload = () => {
		const h = image.naturalHeight * w / image.naturalWidth;
		Object.assign(outer.style, {
			pointerEvents : 'none',
			visibility : 'hidden',
			opacity : '0',
			position : 'absolute',
			width : w + 'px',
			height : h + 'px',
			right : r + 'px',
			bottom : b + 'px',
			display : 'grid',
			placeItems : 'center',
			textAlign : 'center',
			backgroundPosition : 'center center',
			backgroundSize : 'contain',
			backgroundRepeat : 'no-repeat',
			backgroundImage : 'url(' + image.src + ')',
			zIndex : maxInt
		});
	}
	const inner = document.createElement('SPAN');
	Object.assign(inner.style, {
		width : '80%',
		fontFamily : 'cursive',
		fontSize : 'x-large',
		color : 'black'
	});
	outer.appendChild(inner);
	return in_text => {
		outer.style.visibility = 'visible';
		inner.textContent = in_text;
		autoTransition(outer, 'opacity 1s ease-out', '0', '1', () => {
			autoTransition(outer, 'opacity 1s ease-out', '1', '0');
		});
	};
})();

/*
	(4) event handlers
*/

const knock = nonReentrantAsync(async () => {
	SE_ERROR.play();
	await gWorld.motionKnock();
});

const notifyDelta = (() => {
	const RC = cRubiksCube.uiSetDeltaPositionRC;
	return in_ndc => {
		const intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			return;
		}
		const result = gCube.uiNotifyDeltaPosition(intersects[0].object, intersects[0].point, ndcToAbs(in_ndc));
		if (result === RC.UNMOVABLE) {
			knock();
		}
	}
})();

function colorUtil(in_target, in_index, in_callback) {
	const colors = [];
	for (let i = 0; i < in_target.material.length; i++) {
		const hex = in_target.material[i].color.getHex();
		if ((in_index < 0) || (i === in_index)) {
			colors.push(in_callback(hex));
		} else {
			colors.push(hex);
		}
	}
	const setting = in_target.geometry.parameters;
	const materials = boxMaterials(setting.x, setting.y, setting.z, colors);
	materials.push(edgeMaterial);
	/*
		*** NOTE ***
		materials created by boxMaterials are cached using cCache.
		therefore, you don't need to worry about memory leaks without calling dispose().
	*/
	in_target.material = materials;
}

function highlight(in_target, in_index, in_alpha) {
	colorUtil(in_target, in_index, in_currHex => {
		return (new THREE.Color(in_currHex)).lerp(new THREE.Color(0xFFFFFF), in_alpha).getHex();
	});
}

function highlightAll(in_target, in_alpha) {
	highlight(in_target, -1, in_alpha);
}

function changeColor(in_target, in_index, in_nextHex) {
	colorUtil(in_target, in_index, in_currHex => {
		return in_nextHex;
	});
}

function changeColorAll(in_target, in_nextHex) {
	changeColor(in_target, -1, in_nextHex);
}

const setFocus = (() => {
	const c = {
		prev : null,
		materials : []
	};
	return in_ndc => {
		let intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			if (c.prev) {
				c.prev.target.material = c.materials;
				/*
					*** NOTE ***
					as materials made by boxMaterials will be cached using cCache,
					you don't need to call dispose() when mouseout.
				*/
				c.materials = [];
				c.prev = null;
			}
			return;
		}
		const currTarget = intersects[0].object;
		// assume that each face is composed of two faces
		const currSurface = Math.floor(intersects[0].faceIndex / 2);
		if (currSurface >= Object.keys(DIRECTION).length) {
			// faces included in the edge
			return;
		}
		if (c.prev) {
			if ((c.prev.target === currTarget) && (c.prev.surface === currSurface)) {
				return;
			} else {
				c.prev.target.material = c.materials;
			}
		}
		c.prev = {
			target : currTarget,
			surface : currSurface
		};
		c.materials = currTarget.material;
		const alpha = 0.3;
		highlight(currTarget, currSurface, alpha);
	}
})();

function decideSurface(in_intersects) {
	// as face.normal is local coordination of the object, need to convert
	const matrix = (new THREE.Matrix3()).getNormalMatrix(in_intersects[0].object.matrixWorld);
	const surface = in_intersects[0].face.normal.clone().applyMatrix3(matrix).normalize();
	const snap = (in_err => {
		return (in_value, ...in_targets) => {
			let snapped = in_value;
			in_targets.forEach(in_target => {
				if (Math.abs(in_value - in_target) < in_err) {
					snapped = in_target;
				}
			});
			return snapped;
		};
	})(0.0001);
	XYZ.forEach(in_xyz => {
		surface[in_xyz] = snap(surface[in_xyz], -1, 0, +1);
	});
	return surface;
}

function choose(in_ev) {
	const ndc = ndcFromEvent(in_ev);
	let intersects = gWorld.intersectPositive(ndc);
	if (intersects.length === 0) {
		return;
	}
	knock();
}

const gHandlers = (() => {
	const c = {
		x : -1,
		y : -1,
		once : false
	};
	const start = in_ev => {
		if (!c.once) {
			/*
				*** NOTE ***
				Safari may restrict sound without user interaction.
				because of this, the sound does not work without this code.
			*/
			SE_DUMMY.play();
			c.once = true;
		}
		const ndc = ndcFromEvent(in_ev);
		const intersects = gWorld.intersectPositive(ndc);
		if (intersects.length === 0) {
			return;
		}
		c.x = in_ev.clientX;
		c.y = in_ev.clientY;
		gCube.uiSetInitPosition(decideSurface(intersects), intersects[0].point, ndcToAbs(ndc));
	};
	const move = thresholding(in_ev => {
		c.x = -1;
		c.y = -1;
		const ndc = ndcFromEvent(in_ev);
		if (gCube.uiIsMoving()) {
			if (gCube.uiUpdatePosition(ndcToAbs(ndc))) {
				SE_MOVED.play();
			}
		} else {
			if (gCube.uiIsDragging()) {
				notifyDelta(ndc);
			} else {
				if (!in_ev[isEmulated]) {
					// setFocus(ndc);
				}
			}
		}
	});
	const stop = in_ev => {
		const releaseProgress = gCube.uiRelease(in_rotateURFDLB => {
			gWorld.removeAnimationHook(releaseProgress);
			if (in_rotateURFDLB) {
				// rotation for the expected result in "cCntRubiksCube.#faceletFrom3D"
				gCube.rotateOnWorldAxis(in_rotateURFDLB.axis, in_rotateURFDLB.rad * -1);
				gWorld.rotateOnWorldAxis(in_rotateURFDLB.axis, in_rotateURFDLB.rad)
			}
			gCube.countUntilSolve(in_cnt => speak('last ' + in_cnt + ' move'));
		});
		if (releaseProgress) {
			gWorld.addAnimationHook(releaseProgress);
		} else {
			if ((c.x !== in_ev.clientX) || (c.y !== in_ev.clientY)) {
				return;
			}
			choose(in_ev);
		}
	};
	return {
		'mousedown' : start,
		'mousemove' : move,
		'mouseleave' : stop,
		'mouseout' : stop,
		'mouseup' : stop
	};
})();

for (let [eventName, handler] of Object.entries(gHandlers)) {
	gWorld.canvas.addEventListener(eventName, handler);
}

</script>
</body>
</html>
