<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports": {
		"three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.min.js",
		"utils": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/utils/BufferGeometryUtils.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';

/*
	(1) utilities
*/

async function getVersion(in_version_file) {
	try {
		const response = await fetch(in_version_file);
		if (response.ok) {
			return await response.text();
		} else {
			throw new Error('4xx or 5xx Error');
		}
	} catch (in_err) {
		throw new Error('SOP Error etc');
	}
}

function parseParam(in_url = location.href) {
	const req = new URL(in_url);
	const parsed = {
		q : {},
		h : []
	};
	req.searchParams.forEach((value, key) => {
		parsed.q[key] = value;
	});
	if (req.hash) {
		const hashValues = req.hash.substring(1).split('#');
	}
	return parsed;
}

function getParam(in_name) {
	const parsed = parseParam();
	if (in_name in parsed.q) {
		const value = parsed.q[in_name];
		const checkNum = parseInt(value, 10);
		if (checkNum.toString() === value) {
			return checkNum;
		} else {
			return value;
		}
	}
	if (in_name in parsed.h) {
		return true;
	}
	return false;
}

function randomString(in_length = 5)
{
	return Math.floor(Math.random() * (10 ** in_length)).toString(16).padStart(in_length, '0');
}

function convertUnit(in_u1_value, in_u1_from, in_u1_to, in_u2_from, in_u2_to) {
	return in_u2_from + ((in_u1_value - in_u1_from) / (in_u1_to - in_u1_from)) * (in_u2_to - in_u2_from);
}

/*

const testSets = [
	[+0.1,  0, +1,   0, +10, +1],
	[+0.1, +1,  0,   0, +10, +9],
	[+0.1,  0, +1, +10,   0, +9],
	[+0.1, +1,  0, +10,   0, +1],
	[-0.1,  0, -1,   0, +10, +1],
	[-0.1, -1,  0,   0, +10, +9],
	[-0.1,  0, -1, +10,   0, +9],
	[-0.1, -1,  0, +10,   0, +1],
	[+0.1,  0, +1,   0, -10, -1],
	[+0.1, +1,  0,   0, -10, -9],
	[+0.1,  0, +1, -10,   0, -9],
	[+0.1, +1,  0, -10,   0, -1],
	[-0.1,  0, -1,   0, -10, -1],
	[-0.1, -1,  0,   0, -10, -9],
	[-0.1,  0, -1, -10,   0, -9],
	[-0.1, -1,  0, -10,   0, -1]
];

testSets.forEach(test => {
	if (convertUnit(test[0], test[1], test[2], test[3], test[4]) !== test[5]) {
		console.log('failed');
	}
});

*/

function convertUnitRect(in_src_x, in_src_y, in_src_rect, in_dst_rect)
{
	return (new THREE.Vector2(
		convertUnit(in_src_x, in_src_rect.l, in_src_rect.r, in_dst_rect.l, in_dst_rect.r),
		convertUnit(in_src_y, in_src_rect.t, in_src_rect.b, in_dst_rect.t, in_dst_rect.b)
	));
}

function convertRaycasterUnit(in_src_x, in_src_y, in_src_w, in_src_h)
{
	const src_rect = {
		l : 0,
		t : 0,
		r : in_src_w,
		b : in_src_h
	};
	const dst_rect = {
		l : -1,
		t : -1,
		r : 1,
		b : 1
	};
	const vec2 = convertUnitRect(in_src_x, in_src_y, src_rect, dst_rect);
	// finally, dst_rect.t and dst_rect.b should be inverted
	vec2.y *= -1;
	return vec2;
}

function eventPos2RaycasterPos(in_ev)
{
	const elem = in_ev.currentTarget
	return convertRaycasterUnit(
		in_ev.clientX - elem.offsetLeft,
		in_ev.clientY - elem.offsetTop,
		elem.offsetWidth,
		elem.offsetHeight);
}

function snapToNotch(in_value, in_notch)
{
	let notch = in_notch / 2;
	let abs = Math.abs(in_value);
	let cnt = Math.floor(abs / notch);
	if (cnt % 2 === 1) {
		cnt += 1;
	}
	if (abs === 0) {
		return 0;
	} else {
		return notch * cnt * (in_value / abs);
	}
}

function snapToPI(in_value)
{
	/*
		{in : Math.PI / 2 - delta, expected : 0},
		{in : Math.PI / 2 + delta, expected : Math.PI}
	*/
	return snapToNotch(in_value, Math.PI);
}

function snapTo05PI(in_value)
{
	/*
		{in : Math.PI / 4 - delta, expected : 0},
		{in : Math.PI / 4 + delta, expected : Math.PI / 2}
	*/
	return snapToNotch(in_value, Math.PI / 2);
}

function nearlyEqual(in_a, in_b, in_error = 0.01) {
	const diff = Math.abs(in_a - in_b);
	const comp = Math.max(Math.abs(in_a), Math.abs(in_b));
	// scale-adjusted error
	return diff < comp * in_error;
}

const arrRand = Symbol();

Array.prototype[arrRand] = function() {
	return this[Math.floor(Math.random() * this.length)];
};

const forEachCombination = Symbol();

Array.prototype[forEachCombination] = function(in_n, in_callback) {
	const combine = (in_args, in_start, in_decrement) => {
		if (in_decrement === 0) {
			return (in_callback)(...in_args);
		} else {
			for (let i = in_start; i <= this.length - in_decrement; i++) {
				in_args.push(this[i]);
				if (combine(in_args, i + 1, in_decrement - 1)) {
					return true;
				} else {
					in_args.pop();
				}
			}
		}
		return false;
	}
	return (combine)([], 0, in_n);
};

function pseudoMessageDigest1(in_array) {
	let hash = 0;
	in_array.sort().forEach(in_entry => {
		for (let i = 0; i < in_entry.length; i++) {
			hash = (hash << 5) - hash + in_entry.charCodeAt(i);
			hash |= 0;
		}
	});
	return hash >>> 0;
}

function pseudoMessageDigest2(in_string) {
	return pseudoMessageDigest1([in_string]);
}

const createAudio = (() => {
	async function deflate(in_arrBuff) {
		const stream1 = new Blob([in_arrBuff]).stream();
		const stream2 = stream1.pipeThrough(new CompressionStream('deflate'));
		return await new Response(stream2).arrayBuffer();
	}
	async function inflate(in_arrBuff) {
		const stream1 = new Blob([in_arrBuff]).stream();
		const stream2 = stream1.pipeThrough(new DecompressionStream('deflate'));
		return await new Response(stream2).arrayBuffer();
	}
	async function deflate_and_base64encode(in_src) {
		const originalArrBuff = new TextEncoder().encode(in_src);
		const deflatedArrBuff = await deflate(originalArrBuff);
		return btoa(String.fromCharCode(...new Uint8Array(deflatedArrBuff)));
	}
	async function base64decode_and_inflate(in_base64) {
		const bin = atob(in_base64);
		const arr = new Uint8Array(bin.length);
		for (let i = 0; i < bin.length; i++) {
			arr[i] = bin.charCodeAt(i);
		}
		const inflatedArrBuff = await inflate(arr.buffer);
		return new TextDecoder().decode(inflatedArrBuff);
	}
	return async (in_base64) => {
		return new Audio('data:audio/mpeg;base64,' + await base64decode_and_inflate(in_base64));
	}
})();

class cEase {
	constructor(in_from, in_to, in_duration) {
		this.from = in_from;
		this.to = in_to;
		this.duration = in_duration;
		this.start = Date.now();
	}
	#currentEasing(in_quad) {
		const elapsed = Date.now() - this.start;
		if (elapsed > this.duration) {
			return this.to;
		} else {
			return this.from + (this.to - this.from) * (in_quad)(elapsed / this.duration);
		}
	}
	currentEasingLinear() {
		return this.#currentEasing(t => t);
	}
	currentEasingIn() {
		return this.#currentEasing(t => t * t);
	}
	currentEasingOut() {
		return this.#currentEasing(t => t * (2 - t));
	}
}

/*
	*** NOTE ***
	when the app uses position of the mesh to find overlapping etc,
	need to ignore very small error.
*/

class cApproximateMap extends Map {
	// to use this class, key should be numeric
	constructor(in_error) {
		super();
		this.error = in_error;
	}
	#sortedKeys = null;
	#approximateKey(in_key) {
		for (const registeredKey of this.keys()) {
			if (Math.abs(registeredKey - in_key) < this.error) {
				return registeredKey;
			}
		}
		return in_key;
	}
	sortedKey(in_index) {
		if (!this.#sortedKeys) {
			this.#sortedKeys = Array.from(this.keys()).sort((a, b) => a - b);
		}
		return this.#sortedKeys[in_index];
	}
	get(in_key) {
		return super.get(this.#approximateKey(in_key));
	}
	set(in_key, in_value) {
		this.#sortedKeys = null;
		return super.set(this.#approximateKey(in_key), in_value);
	}
	delete(in_key) {
		this.#sortedKeys = null;
		return super.delete(this.#approximateKey(in_key));
	}
}

class cApproximateSet extends Set {
	constructor(in_error) {
		super();
		this.error = in_error;
	}
	#approximateValue(in_value) {
		for (let item of this) {
			if (Math.abs(item - in_value) < this.error) {
				return item;
			}
		}
		return in_value;
	}
	add(in_value) {
		return super.add(this.#approximateValue(in_value));
	}
	has(in_value) {
		return super.has(this.#approximateValue(in_value));
	}
	delete(in_value) {
		return super.delete(this.#approximateValue(in_value));
	}
}

class cCyclicMap extends Map {
	get #keysArray() {
		return Array.from(this.keys());
	}
	#deltaItemByOrder(in_order, in_delta) {
		const length = this.#keysArray.length;
		const deltaIndex = (in_order + in_delta + length) % length;
		const deltaKey = this.#keysArray[deltaIndex];
		return {
			k : deltaKey,
			v : this.get(deltaKey)
		};
	}
	nextItemByOrder(in_order) {
		return this.#deltaItemByOrder(in_order, +1);
	}
	currItemByOrder(in_order) {
		return this.#deltaItemByOrder(in_order, 0);
	}
	prevItemByOrder(in_order) {
		return this.#deltaItemByOrder(in_order, -1);
	}
	#deltaItemByKey(in_key, in_delta) {
		const index = this.#keysArray.indexOf(in_key);
		if (index === -1) {
			return null;
		} else {
			return this.#deltaItemByOrder(index, in_delta);
		}
	}
	nextItemByKey(in_key) {
		return this.#deltaItemByKey(in_key, +1);
	}
	prevItemByKey(in_key) {
		return this.#deltaItemByKey(in_key, -1);
	}
}

class cCyclicValues extends Array {
	#currIndex;
	constructor(...args) {
		super(...args);
		this.#currIndex = 0;
	}
	get #nextIndex() {
		return (this.#currIndex + 1) % this.length;
	}
	#increment() {
		this.#currIndex = this.#nextIndex;
	}
	currValue() {
		return this[this.#currIndex];
	}
	nextValue() {
		return this[this.#nextIndex];
	}
	incrementedValue() {
		this.#increment();
		return this.currValue();
	}
}

function emulateTouchEvent(in_elem) {
	const eventMapper = [
		{
			src : 'touchstart',
			dst : 'mousedown'
		},
		{
			src : 'touchmove',
			dst : 'mousemove'
		},
		{
			src : 'touchleave',
			dst : 'mouseleave'
		},
		{
			src : 'touchend',
			dst : 'mouseup'
		}
	];
	let lastDistance = null;
	function createAltWheelEv(in_ev) {
		const t1 = in_ev.touches[0];
		const t2 = in_ev.touches[1];
		const currentDistance = Math.sqrt(Math.pow(t2.clientX - t1.clientX, 2) + Math.pow(t2.clientY - t1.clientY, 2));
		if (lastDistance === null) {
			lastDistance = currentDistance;
			return null;
		}
		const speed = 2;
		const delta = (lastDistance - currentDistance) * speed;
		lastDistance = currentDistance;
		return new WheelEvent('wheel', {
			deltaY : delta,
			clientX : (t1.clientX + t2.clientX) / 2,
			clientY : (t1.clientY + t2.clientY) / 2,
			ctrlKey : in_ev.ctrlKey,
			altKey : in_ev.altKey,
			shiftKey : in_ev.shiftKey,
			metaKey : in_ev.metaKey
		});
	}
	function createAltMouseEv(in_type, in_ev) {
		return new MouseEvent(in_type, {
			bubbles : true,
			cancelable : true,
			view : window,
			screenX : in_ev.changedTouches[0].screenX,
			screenY : in_ev.changedTouches[0].screenY,
			clientX : in_ev.changedTouches[0].clientX,
			clientY : in_ev.changedTouches[0].clientY,
			ctrlKey : in_ev.ctrlKey,
			altKey : in_ev.altKey,
			shiftKey : in_ev.shiftKey,
			metaKey : in_ev.metaKey,
			button : 0,
			relatedTarget : null
		});
	}
	eventMapper.forEach(in_pair => {
		in_elem.addEventListener(in_pair.src, in_ev => {
			in_ev.preventDefault();
			in_ev.stopPropagation();
			let alternative = null;
			if (in_ev.touches.length > 1) {
				if ((in_ev.touches.length === 2) && (in_pair.src === 'touchmove')) {
					alternative = createAltWheelEv(in_ev);
				} else {
					lastDistance = null;
				}
			} else {
				alternative = createAltMouseEv(in_pair.dst, in_ev);
			}
			if (alternative) {
				in_ev.target.dispatchEvent(alternative);
			}
		});
	});
}

const clipArea = Symbol();
const clipClearArea = Symbol();

HTMLCanvasElement.prototype[clipArea] = function(in_margin, in_callback) {
	const w = this.width;
	const h = this.height;
	let ctx = this.getContext('2d');
	if (!ctx) {
		/*
			*** NOTE ***
			sometimes can't get 2D context ( ex. Three.js ).
			so, to get it, copy bitmap to alternative canvas.
		*/
		const alternative = document.createElement('canvas');
		alternative.width = w;
		alternative.height = h;
		ctx = alternative.getContext('2d');
		ctx.drawImage(this, 0, 0);
	}
	const rgba = (ctx.getImageData(0, 0, w, h)).data;
	let l = Number.POSITIVE_INFINITY;
	let t = Number.POSITIVE_INFINITY;
	let r = Number.NEGATIVE_INFINITY;
	let b = Number.NEGATIVE_INFINITY;
	for (let y = 0; y < h; y++) {
		for (let x = 0; x < w; x++) {
			const pt = (y * w + x) * 4;
			if (!(in_callback)(rgba[pt + 0], rgba[pt + 1], rgba[pt + 2], rgba[pt + 3])) {
				continue;
			}
			if (x < l) {
				l = x;
			}
			if (y < t) {
				t = y;
			}
			if (x > r) {
				r = x;
			}
			if (y > b) {
				b = y;
			}
		}
	}
	l = Math.max(l - in_margin, 0);
	t = Math.max(t - in_margin, 0);
	r = Math.min(r + in_margin, w - 1);
	b = Math.min(b + in_margin, h - 1);
	return {
		l : l,
		t : t,
		r : r,
		b : b,
		w : r - l + 1,
		h : b - t + 1
	};
};

HTMLCanvasElement.prototype[clipClearArea] = function(in_margin) {
	return this[clipArea](in_margin, (in_r, in_g, in_b, in_a) => {
		return (in_a > 0);
	});
}

const XYZ = ['x', 'y', 'z'];

const ROTATE = (in_obj, in_vec3) => {
	XYZ.forEach(in_xyz => {
		// for THREE.Object3D, THREE.Geometry
		const rotateAxis = 'rotate' + in_xyz.toUpperCase();
		in_obj[rotateAxis](in_vec3[in_xyz]);
	});
};

const VEC3 = (x = 0, y = 0, z = 0) => new THREE.Vector3(x, y, z);

const DIRECTION = {
	XP : VEC3(+1, 0, 0),
	XN : VEC3(-1, 0, 0),
	YP : VEC3(0, +1, 0),
	YN : VEC3(0, -1, 0),
	ZP : VEC3(0, 0, +1),
	ZN : VEC3(0, 0, -1)
}

class cBoxCollection {
	#boxes = [];
	constructor(in_objArr = []) {
		this.max = VEC3(Infinity * -1, Infinity * -1, Infinity * -1);
		this.min = VEC3(Infinity * +1, Infinity * +1, Infinity * +1);
		in_objArr.forEach(in_obj => {
			const box = (new THREE.Box3()).setFromObject(in_obj)
			this.addBox(box);
			XYZ.forEach(in_xyz => {
				this.max[in_xyz] = this.max[in_xyz] > box.max[in_xyz] ? this.max[in_xyz] : box.max[in_xyz];
				this.min[in_xyz] = this.min[in_xyz] < box.min[in_xyz] ? this.min[in_xyz] : box.min[in_xyz];
			});
		});
	}
	addBox(in_box) {
		this.#boxes.push(in_box);
	}
	containsPoint(in_vec3) {
		for (const box of this.#boxes) {
			if (box.containsPoint(in_vec3)) {
				return true;
			}
		}
		return false;
	}
	getRandomPoints(in_cnt) {
		const points = [];
		while (points.length < in_cnt) {
			for (const box of this.#boxes) {
				const min = box.min;
				const max = box.max;
				points.push(VEC3(
					Math.random() * (max.x - min.x) + min.x,
					Math.random() * (max.y - min.y) + min.y,
					Math.random() * (max.z - min.z) + min.z
				));
			}
		}
		points.length = in_cnt;
		return points;
	}
}

const lookAtWithoutRotation = Symbol();

THREE.Object3D.prototype[lookAtWithoutRotation] = function(in_dstV3, in_prjV3 = null) {
	const updateParents = true;
	const updateChildren = false;
	this.updateWorldMatrix(updateParents, updateChildren);
	const worldPosition = (VEC3()).setFromMatrixPosition(this.matrixWorld);
	const up = VEC3(0, 1, 0).applyQuaternion(this.getWorldQuaternion(new THREE.Quaternion()));
	const eye = in_dstV3.clone();
	if (in_prjV3) {
		up.projectOnPlane(in_prjV3).normalize();
		eye.sub(worldPosition).projectOnPlane(in_prjV3).add(worldPosition);
	}
	const localMatrix = (new THREE.Matrix4()).lookAt(eye, worldPosition, up);
	this.quaternion.setFromRotationMatrix(localMatrix);
	if (this.parent) {
		localMatrix.extractRotation(this.parent.matrixWorld);
		const parentQuat = (new THREE.Quaternion()).setFromRotationMatrix(localMatrix);
		this.quaternion.premultiply(parentQuat.invert());
	}
}

function safeMergeGeometry(in_arr, in_dispose = true) {
	const merged = UTILS.mergeGeometries(in_arr);
	if (in_dispose) {
		in_arr.forEach(in_geo => in_geo.dispose());
	}
	return merged;
}

function makeTrapezoidGeometryParts(in_txLen, in_tzLen, in_bxLen, in_bzLen, in_yLen, in_rad = 0) {
	const parts = [];
	/*
		|
		+- geometry
		|	|
		|	+- userData.isSurface : true / false
		|	|
		|	+- userData.groupName : 'top' / 'bottom' / 'middle'
		|
		+- geometry
		|
		+- ...
	*/
	const DEG90 = Math.PI * 1 / 2;
	const setGroupName = (in_vertices) => {
		if (in_vertices.every(vertex => vertex.y > 0)) {
			return 'top';
		}
		if (in_vertices.every(vertex => vertex.y < 0)) {
			return 'bottom';
		}
		return 'middle';
	};
	/*
			 (+)
			  |
			  0-----1
			 /|    /|
			3-----2 |
			| |   | |
		   -|-4---|-5---(+)
			|/|   |/
			7-----6
		   /  |
		 (+)
	*/
	const baseVertices = {
		v0 : VEC3(in_txLen / 2 * -1, in_yLen / 2 * +1, in_tzLen / 2 * -1),
		v1 : VEC3(in_txLen / 2 * +1, in_yLen / 2 * +1, in_tzLen / 2 * -1),
		v2 : VEC3(in_txLen / 2 * +1, in_yLen / 2 * +1, in_tzLen / 2 * +1),
		v3 : VEC3(in_txLen / 2 * -1, in_yLen / 2 * +1, in_tzLen / 2 * +1),
		v4 : VEC3(in_bxLen / 2 * -1, in_yLen / 2 * -1, in_bzLen / 2 * -1),
		v5 : VEC3(in_bxLen / 2 * +1, in_yLen / 2 * -1, in_bzLen / 2 * -1),
		v6 : VEC3(in_bxLen / 2 * +1, in_yLen / 2 * -1, in_bzLen / 2 * +1),
		v7 : VEC3(in_bxLen / 2 * -1, in_yLen / 2 * -1, in_bzLen / 2 * +1)
	};
	/*
		1. Surface (BufferGeometry)
			even you can also make surface using PlaneGeometry,
			it is a little complicated to decide position before rotation.
	*/
	const surfaceMap = new Map([
		[DIRECTION.XP, [baseVertices.v1, baseVertices.v2, baseVertices.v6, baseVertices.v5]],
		[DIRECTION.XN, [baseVertices.v0, baseVertices.v4, baseVertices.v7, baseVertices.v3]],
		[DIRECTION.YP, [baseVertices.v3, baseVertices.v2, baseVertices.v1, baseVertices.v0]],
		[DIRECTION.YN, [baseVertices.v6, baseVertices.v7, baseVertices.v4, baseVertices.v5]],
		[DIRECTION.ZP, [baseVertices.v7, baseVertices.v6, baseVertices.v2, baseVertices.v3]],
		[DIRECTION.ZN, [baseVertices.v5, baseVertices.v4, baseVertices.v0, baseVertices.v1]]
	]);
	const translatedSurfaceMap = new Map();
	const equal = (in_vec, ...in_vecArr) => in_vecArr.some(vec => in_vec.equals(vec));
	surfaceMap.forEach((in_val, in_key) => {
		let translate;
		if (equal(in_key, DIRECTION.YP, DIRECTION.YN)) {
			// top or bottom
			translate = in_key.clone().multiplyScalar(in_rad);
		} else {
			const normal = VEC3();
			in_val[forEachCombination](3, (a, b, c) => {
				let v1 = (VEC3()).subVectors(a, b);
				let v2 = (VEC3()).subVectors(b, c);
				if ((v1.lengthSq() > 0) && (v2.lengthSq() > 0)) {
					normal.crossVectors(v1, v2);
					if (normal.lengthSq() > 0) {
						normal.normalize();
						return true;
					}
				}
				return false;
			});
			translate = normal.multiplyScalar(in_rad);
		}
		const vertices = [];
		in_val.forEach(in_vertex => {
			vertices.push(in_vertex.clone().add(translate));
		});
		translatedSurfaceMap.set(in_key, vertices);
	});
	for (const vertices of translatedSurfaceMap.values()) {
		const uniqueFilter = (in_vertices) => {
			const unique = [];
			in_vertices.forEach(in_vertex => {
				if (unique.some(in_v => in_v.equals(in_vertex))) {
					return;
				}
				unique.push(in_vertex);
			});
		    return unique;
		};
		const unique = uniqueFilter(vertices);
		if (unique.length < 3) {
			continue;
		}
		const geometry = new THREE.BufferGeometry();
		const flat = [];
		unique.forEach(in_vec3 => {
			flat.push(in_vec3.x, in_vec3.y, in_vec3.z);
		});
		geometry.setAttribute('position', new THREE.Float32BufferAttribute(flat, 3));
		let ix, uv;
		if (unique.length === 3) {
			ix = [0, 1, 2];
			uv = [0, 0, 1, 0, 0.5, 1];
		} else {
			ix = [0, 1, 2, 0, 2, 3];
			uv = [0, 0, 1, 0, 1, 1, 0, 1];
		}
		geometry.setIndex(ix);
		geometry.setAttribute('uv', new THREE.Float32BufferAttribute(new Float32Array(uv), 2));
		geometry.computeVertexNormals();
		geometry.userData.isSurface = true;
		geometry.userData.groupName = setGroupName(vertices);
		parts.push(geometry);
	}
	/*
		2. Edge (CylinderGeometry)
			2.1. Edge for top & bottom surface (applying rotation by prepared setting)
			2.2. Edge for sloped side surface (applying rotation automatically)
	*/
	const makeEdgeCylinder = (in_height, in_start, in_theta) => {
		const defaultRadialSegments = 32;
		const defaultHeightSegments = 1;
		const openEnded = true;
		return new THREE.CylinderGeometry(
			in_rad,
			in_rad,
			in_height,
			defaultRadialSegments,
			defaultHeightSegments,
			openEnded,
			in_start,
			in_theta
		);
	};
	const centroid = (in_vecArr) => {
		const ret = VEC3();
		in_vecArr.forEach(in_vector => {
			ret.add(in_vector);
		});
		return ret.divideScalar(in_vecArr.length);
	};
	const theta = (a, b) => Math.atan(Math.abs(a - b) / 2 / in_yLen) * (a > b ? +1 : -1);
	const thetaX = theta(in_txLen, in_bxLen);
	const thetaZ = theta(in_tzLen, in_bzLen);
	const edgeConfigSet1 = [
		/*
			E : Edge (Vector3 x2)
			R : Rotation from Vector3(0, 1, 0)
			P : Parameter for THREE.CylinderGeometry
		*/
		{E : [baseVertices.v2, baseVertices.v3], R : VEC3(0, 0, DEG90 * -1), P : [DEG90 * 3, DEG90 + thetaZ]},
		{E : [baseVertices.v3, baseVertices.v0], R : VEC3(DEG90 * +1, 0, 0), P : [DEG90 * 2, DEG90 + thetaX]},
		{E : [baseVertices.v0, baseVertices.v1], R : VEC3(0, 0, DEG90 * +1), P : [DEG90 * 1, DEG90 + thetaZ]},
		{E : [baseVertices.v1, baseVertices.v2], R : VEC3(DEG90 * -1, 0, 0), P : [DEG90 * 0, DEG90 + thetaX]},
		{E : [baseVertices.v6, baseVertices.v7], R : VEC3(0, 0, DEG90 * +1), P : [DEG90 * 3, DEG90 - thetaZ]},
		{E : [baseVertices.v7, baseVertices.v4], R : VEC3(DEG90 * -1, 0, 0), P : [DEG90 * 2, DEG90 - thetaX]},
		{E : [baseVertices.v4, baseVertices.v5], R : VEC3(0, 0, DEG90 * -1), P : [DEG90 * 1, DEG90 - thetaZ]},
		{E : [baseVertices.v5, baseVertices.v6], R : VEC3(DEG90 * +1, 0, 0), P : [DEG90 * 0, DEG90 - thetaX]}
	];
	const edgeConfigSet2 = [
		{E : [baseVertices.v3, baseVertices.v7], P : [DEG90 * 3, DEG90]},
		{E : [baseVertices.v0, baseVertices.v4], P : [DEG90 * 2, DEG90]},
		{E : [baseVertices.v1, baseVertices.v5], P : [DEG90 * 1, DEG90]},
		{E : [baseVertices.v2, baseVertices.v6], P : [DEG90 * 0, DEG90]}
	];
	edgeConfigSet1.forEach(in_conf => {
		const length = in_conf.E[0].distanceTo(in_conf.E[1]);
		if (length === 0) {
			return;
		}
		const geometry = makeEdgeCylinder(length, in_conf.P[0], in_conf.P[1]);
		ROTATE(geometry, in_conf.R);
		geometry.translate(centroid(in_conf.E));
		geometry.userData.isSurface = false;
		geometry.userData.groupName = setGroupName(in_conf.E);
		parts.push(geometry);
	});
	const vertical = VEC3(0, 1, 0);
	edgeConfigSet2.forEach(in_conf => {
		const length = in_conf.E[0].distanceTo(in_conf.E[1]);
		const geometry = makeEdgeCylinder(length, in_conf.P[0], in_conf.P[1]);
		/*
			at first, I mistook it for the opposite direction.
			( in_conf.E[0] --> in_conf.E[1] )
			because of it, parameter of theta couldn't be stable.
		*/
		const slope = in_conf.E[0].clone().sub(in_conf.E[1]).normalize();
		const quaternion = new THREE.Quaternion();
		quaternion.setFromUnitVectors(vertical, slope);
		geometry.applyQuaternion(quaternion);
		geometry.translate(centroid(in_conf.E));
		geometry.userData.isSurface = false;
		geometry.userData.groupName = setGroupName(in_conf.E);
		parts.push(geometry);
	});
	/*
		3. Corner (SphereGeometry)
	*/
	const makeCornerSphere = (in_phi_start, in_theta_start, in_theta) => {
		const error = 0.01;
		const widthSegments = 32;
		const heightSegments = 16;
		return new THREE.SphereGeometry(
			in_rad,
			widthSegments,
			heightSegments,
			in_phi_start - error,
			DEG90 + error * 2,
			in_theta_start - error,
			in_theta + error * 2
		);
	};
	const uTheta = (in_txLen > in_bxLen) || (in_tzLen > in_bzLen) ? DEG90 * 2 : DEG90 * 1;
	const bTheta = (in_txLen < in_bxLen) || (in_tzLen < in_bzLen) ? DEG90 * 2 : DEG90 * 1;
	const cornerConfigSet = [
		/*
			C : Corner (Vector3 x1)
			P : Parameter for THREE.SphereGeometry
		*/
		{C : baseVertices.v0, P : [DEG90 * 3, 0, uTheta]},
		{C : baseVertices.v1, P : [DEG90 * 2, 0, uTheta]},
		{C : baseVertices.v2, P : [DEG90 * 1, 0, uTheta]},
		{C : baseVertices.v3, P : [DEG90 * 0, 0, uTheta]},
		{C : baseVertices.v4, P : [DEG90 * 3, DEG90 * 2 - bTheta, bTheta]},
		{C : baseVertices.v5, P : [DEG90 * 2, DEG90 * 2 - bTheta, bTheta]},
		{C : baseVertices.v6, P : [DEG90 * 1, DEG90 * 2 - bTheta, bTheta]},
		{C : baseVertices.v7, P : [DEG90 * 0, DEG90 * 2 - bTheta, bTheta]}
	];
	cornerConfigSet.forEach(in_conf => {
		const geometry = makeCornerSphere(...in_conf.P);
		geometry.translate(in_conf.C);
		geometry.userData.isSurface = false;
		geometry.userData.groupName = setGroupName([in_conf.C]);
		parts.push(geometry);
	});
	return parts;
}

function trapezoidGeometryUtil(in_txLen, in_tzLen, in_bxLen, in_bzLen, in_yLen, in_rad = 0) {
	const parts = makeTrapezoidGeometryParts(in_txLen, in_tzLen, in_bxLen, in_bzLen, in_yLen, in_rad);
	// assume order of groups ( BufferGeometry x6, other geometries ... )
	const groups = [];
	let edgeGroup = 0;
	parts.forEach(in_part => {
		if (in_part.userData.isSurface) {
			groups.push(in_part.index.count);
		} else {
			edgeGroup += in_part.index.count;
		}
	});
	groups.push(edgeGroup);
	const merged = safeMergeGeometry(parts);
	let start = 0;
	for (let i = 0; i < groups.length; i++) {
		merged.addGroup(start, groups[i], i);
		start += groups[i];
	}
	return merged;
}

function roundBoxGeometry(in_xLen, in_yLen, in_zLen, in_rad) {
	return trapezoidGeometryUtil(in_xLen, in_zLen, in_xLen, in_zLen, in_yLen, in_rad);
}

function roundRegularBoxGeometry(in_len, in_rad) {
	return trapezoidGeometryUtil(in_len, in_len, in_len, in_len, in_len, in_rad);
}

function roundTrapezoidGeometry(in_tLen, in_bLen, in_height, in_rad) {
	return trapezoidGeometryUtil(in_tLen, 0, in_bLen, 0, in_height, in_rad);
}

function capsuleConfigure(in_rad_t, in_rad_b, in_h) {
	/*
	                  +-(rad_t)-+
		             /|         |
		            / |         |
		           /  |         | in_h
		          /   |         |
		         /    |         |
		theta : +-----+-(rad_b)-+
	*/
	const ratio = (in_rad_b - in_rad_t) / in_h;
	const atan = Math.atan(1 / ratio);
	return {
		/*
			when in_rad_t < in_rad_b, atan will be "+"
			when in_rad_t = in_rad_b, atan will be "Math.PI / 2"
			when in_rad_t > in_rad_b, atan will be "-"
		*/
		theta : atan > 0 ? atan : Math.PI + atan,
		/*
			when in_rad_t < in_rad_b, delta will be "+"
			when in_rad_t = in_rad_b, delta will be "0"
			when in_rad_t > in_rad_b, delta will be "-"
		*/
		delta : {
			t : in_rad_t * ratio,
			b : in_rad_b * ratio
		},
		/*
			radius (real radius) will be always "+"
		*/
		radius : {
			t : (in_rad_t ** 2 + (in_rad_t * ratio) ** 2) ** 0.5,
			b : (in_rad_b ** 2 + (in_rad_b * ratio) ** 2) ** 0.5
		},
	};
}

/*

console.log(capsuleConfigure(10, 11, 50));
//theta: 1.5507989928...
console.log(capsuleConfigure(10, 10, 50));
//theta: 1.5707963267...
console.log(capsuleConfigure(11, 10, 50));
//theta: 1.5907936607...

*/

function customCapsuleGeometry(in_rad_t, in_rad_b, in_h, in_rSeg = 32, in_hSeg = 1) {
	const conf = capsuleConfigure(in_rad_t, in_rad_b, in_h);
	const sphereParams = [32, 16, 0, Math.PI * 2];
	const parts = [];
	// top
	parts.push(new THREE.SphereGeometry(conf.radius.t, ...sphereParams, 0, conf.theta));
	parts[parts.length - 1].translate(0, conf.delta.t * -1 + in_h / 2, 0);
	// bottom
	parts.push(new THREE.SphereGeometry(conf.radius.b, ...sphereParams, conf.theta, Math.PI - conf.theta));
	parts[parts.length - 1].translate(0, conf.delta.b * -1 - in_h / 2, 0);
	// middle
	parts.push(new THREE.CylinderGeometry(in_rad_t, in_rad_b, in_h, in_rSeg, in_hSeg, true));
	return safeMergeGeometry(parts);
}

/*
	(2) cSphericalWorld

	|
	+-- Scene
	|
	+-- WebGLRenderer
	|
	+-- Object3D ( to control camera )
		|
		+- PerspectiveCamera
*/

const EV_DISTANCE_MULTIPLIER = 3;

const DEVICE_PIXEL_RATIO = window.devicePixelRatio;

class cSphericalWorld {
	static #defaultCameraSetting = 2;
	static #view = [
		{
			cameraFrom : DIRECTION.ZN,
			cameraUp : DIRECTION.YP,
			dxDir : -1,
			dyDir : -1
		},
		{
			cameraFrom : DIRECTION.ZN,
			cameraUp : DIRECTION.YN,
			dxDir : 1,
			dyDir : 1
		},
		{
			cameraFrom : DIRECTION.ZP,
			cameraUp : DIRECTION.YP,
			dxDir : -1,
			dyDir : 1
		},
		{
			cameraFrom : DIRECTION.ZP,
			cameraUp : DIRECTION.YN,
			dxDir : 1,
			dyDir : -1
		}
	][cSphericalWorld.#defaultCameraSetting];
	static #rotationCallbackName = Symbol();
	static #cameraName = randomString();
	#scene = null;
	#renderer = null;
	#cameraCtrl = null;
	#anchorPosV2 = null;
	zoomMin = Number.NEGATIVE_INFINITY;
	zoomMax = Number.POSITIVE_INFINITY;
	#userObjects = new Set();
	#animationHooks = new Set();
	static #deltaThreshold = 0.05;
	constructor(in_radius) {
		// scene
		this.#scene = new THREE.Scene();
		//this.#scene.background = new THREE.Color(0xFFFFFF);
		// renderer
		this.#renderer = new THREE.WebGLRenderer({alpha : true, antialias : true});
		this.#renderer.setPixelRatio(DEVICE_PIXEL_RATIO);
		// camera
		const camera = new THREE.PerspectiveCamera();
		camera.name = cSphericalWorld.#cameraName;
		camera.fov = 45;
		camera.near = 1;
		camera.far = in_radius * 2;
		camera.position.set(
			0,
			0,
			in_radius * cSphericalWorld.#view.cameraFrom.z);
		camera.up.copy(cSphericalWorld.#view.cameraUp);
		camera.lookAt(VEC3(0, 0, 0));
		if (false) {
			camera.layers.enableAll();
		}
		this.#cameraCtrl = new THREE.Object3D();
		this.#cameraCtrl.add(camera);
		// light
		const lightColor = 0xFFFFFF;
		const light = new THREE.DirectionalLight(lightColor);
		light.position.set(
			0,
			in_radius * cSphericalWorld.#view.cameraUp.y,
			in_radius * cSphericalWorld.#view.cameraFrom.z);
		this.#cameraCtrl.add(light);
		this.add(new THREE.AmbientLight(lightColor), true);
		// other
		this.resize(this.canvas.width, this.canvas.height);
		this.canvas.addEventListener('mousedown', this.#evMoveStart.bind(this));
		this.canvas.addEventListener('mousemove', this.#evMoveUpdate.bind(this));
		this.canvas.addEventListener('mouseleave', this.#evMoveStop.bind(this));
		this.canvas.addEventListener('mouseout', this.#evMoveStop.bind(this));
		this.canvas.addEventListener('mouseup', this.#evMoveStop.bind(this));
		this.canvas.addEventListener('wheel', this.#evZoom.bind(this));
		emulateTouchEvent(this.canvas);
	}
	get canvas() {
		return this.#renderer.domElement;
	}
	get #camera() {
		return this.#cameraCtrl.getObjectByName(cSphericalWorld.#cameraName);
	}
	getLookAt() {
		return this.#camera.position.clone().negate();
	}
	#moveCameraCtrl(in_world_dx, in_world_dy) {
		this.#cameraCtrl.rotateY(in_world_dx * cSphericalWorld.#view.dxDir);
		this.#cameraCtrl.rotateX(in_world_dy * cSphericalWorld.#view.dyDir);
	}
	moveView(in_world_dx, in_world_dy) {
		this.#moveCameraCtrl(in_world_dx * -1, in_world_dy * -1);
	}
	#setZoom(in_distance) {
		this.#camera.position.normalize().multiplyScalar(in_distance);
	}
	#evMoveStart(in_ev) {
		const vec2 = eventPos2RaycasterPos(in_ev);
		if (this.intersectPositive(vec2).length > 0) {
			return;
		}
		this.#anchorPosV2 = vec2;
	}
	#evMoveUpdate(in_ev) {
		if (!this.#anchorPosV2) {
			return;
		}
		const vec2 = eventPos2RaycasterPos(in_ev);
		let delta = vec2.clone().sub(this.#anchorPosV2);
		if (delta.length() < cSphericalWorld.#deltaThreshold) {
			return;
		}
		delta.multiplyScalar(EV_DISTANCE_MULTIPLIER);
		this.#moveCameraCtrl(delta.x, delta.y);
		this.#anchorPosV2 = vec2;
	}
	#evMoveStop(in_ev) {
		if (!this.#anchorPosV2) {
			return;
		}
		this.#anchorPosV2 = null;
	}
	#evZoom(in_ev) {
		const distance = this.#camera.position.length() + in_ev.deltaY;
		if ((this.zoomMax < distance) && (distance < this.zoomMin)) {
			this.#setZoom(distance);
		}
	}
	#intersectObjects(in_vec2, in_direction, in_layer) {
		const raycaster = new THREE.Raycaster();
		raycaster.layers.set(in_layer);
		// camera ---[ raycast ]---> object
		raycaster.setFromCamera(in_vec2, this.#camera);
		const intersects = raycaster.intersectObjects(this.#scene.children);
		if (in_direction || (intersects.length === 0)) {
			return intersects;
		}
		// camera ---> object ( intersects[0].point ) ---[ raycaster.ray.direction ]---> opposit
		const opposit = (intersects[0].point.clone()).add(raycaster.ray.direction.multiplyScalar(this.#camera.far));
		// camera ---> object <---[ raycast again ]--- opposit
		raycaster.set(opposit, (raycaster.ray.direction.clone()).negate());
		return raycaster.intersectObjects(this.#scene.children);
	}
	intersectPositive(in_vec2, in_layer = 0) {
		return this.#intersectObjects(in_vec2, true, in_layer);
	}
	intersectNegative(in_vec2, in_layer = 0) {
		return this.#intersectObjects(in_vec2, false, in_layer);
	}
	copyCameraPosition() {
		return this.#camera.getWorldPosition(VEC3());
	}
	#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, in_method) {
		return new Promise(resolve => {
			if (nearlyEqual(in_initValue, in_stopValue)) {
				(in_progressCallback)(in_stopValue);
				// to the next then in the chain
				(resolve)();
				return;
			}
			const ease = new cEase(in_initValue, in_stopValue, in_duration);
			const hook = () => {
				let currValue;
				switch (in_method) {
				case 10 :
					currValue = ease.currentEasingIn();
					break;
				case 20 :
					currValue = ease.currentEasingOut();
					break;
				case 30 :
				default :
					currValue = ease.currentEasingLinear();
					break;
				}
				if (currValue === in_stopValue) {
					this.removeAnimationHook(hook);
					(in_progressCallback)(in_stopValue);
					// to the next then in the chain
					(resolve)();
				} else {
					(in_progressCallback)(currValue);
				}
			};
			this.addAnimationHook(hook);
		});
	}
	easeIn(in_initValue, in_stopValue, in_duration, in_progressCallback) {
		return this.#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, 10);
	}
	easeOut(in_initValue, in_stopValue, in_duration, in_progressCallback) {
		return this.#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, 20);
	}
	easeLinear(in_initValue, in_stopValue, in_duration, in_progressCallback) {
		return this.#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, 30);
	}
	addAnimationHook(in_hook) {
		this.#animationHooks.add(in_hook);
	}
	removeAnimationHook(in_hook) {
		this.#animationHooks.delete(in_hook);
	}
	motionZoom1(in_initDistance, in_stopDistance, in_duration) {
		return this.easeOut(in_initDistance, in_stopDistance, in_duration, in_currDistance => {
			this.#setZoom(in_currDistance);
		});
	}
	motionZoom2(in_stopDistance, in_duration) {
		return this.motionZoom1(this.#camera.position.length(), in_stopDistance, in_duration);
	}
	motionKnock(in_duration = 100) {
		const currentDistance = this.#camera.position.length();
		return this.motionZoom1(currentDistance * 1.1, currentDistance, in_duration);
	}
	motionDefaultView(in_duration = 2000) {
		const targetQuat = new THREE.Quaternion();
		const targetRad = this.#cameraCtrl.quaternion.angleTo(targetQuat);
		return this.easeIn(0, targetRad, in_duration, in_currRad => {
			this.#cameraCtrl.quaternion.rotateTowards(targetQuat, in_currRad);
		});
	}
	motionFog(in_color, in_initFogged, in_stopFogged, in_duration = 500) {
		return new Promise(resolve => {
			if (this.#scene.fog) {
				// to the next then in the chain
				(resolve)();
				return;
			}
			const distance = this.#camera.position.length();
			const margin = 100;
			const radius = this.#getUserObjectRadius() + margin;
			const initNear = convertUnit(in_initFogged, 0, 100, distance + radius, distance - radius * 3);
			const stopNear = convertUnit(in_stopFogged, 0, 100, distance + radius, distance - radius * 3);
			this.#scene.fog = new THREE.Fog(in_color, initNear, initNear + radius * 2);
			this.easeLinear(initNear, stopNear, in_duration, in_currNear => {
				this.#scene.fog.near = in_currNear;
				this.#scene.fog.far = in_currNear + radius * 2;
			}).then(() => {
				this.#scene.fog = null;
				// to the next then in the chain
				(resolve)();
			});
		});
	}
	startRotation(in_vec3) {
		this[cSphericalWorld.#rotationCallbackName] = () => {
			ROTATE(this.#cameraCtrl, in_vec3);
		};
		this.addAnimationHook(this[cSphericalWorld.#rotationCallbackName]);
	}
	stopRotation() {
		this.removeAnimationHook(this[cSphericalWorld.#rotationCallbackName]);
		delete this[cSphericalWorld.#rotationCallbackName];
	}
	resize(in_w, in_h) {
		this.#renderer.setSize(in_w, in_h);
		this.#camera.aspect = in_w / in_h;
		this.#camera.updateProjectionMatrix();
	}
	#getUserObjectRadius() {
		let max = Number.NEGATIVE_INFINITY;
		this.#userObjects.forEach(in_obj => {
			const box = new THREE.Box3();
			in_obj.traverse(in_descendant => {
				if (in_descendant.visible && in_descendant.geometry) {
					in_descendant.geometry.computeBoundingBox();
					const descendantBox = in_descendant.geometry.boundingBox.clone();
					descendantBox.applyMatrix4(in_descendant.matrixWorld);
					box.union(descendantBox);
				}
			});
			const sphere = new THREE.Sphere();
			box.getBoundingSphere(sphere);
			max = Math.max(max, sphere.radius);
		});
		return max;
	}
	#updateZoomParams() {
		let delayed = 1000;
		const update = () => {
			const radius = this.#getUserObjectRadius();
			if (radius < 0) {
				// don't have visible object
				delayed *= 2;
				window.setTimeout(update, delayed);
			} else {
				this.zoomMin = this.#camera.far - radius;
				this.zoomMax = radius
			}
		};
		(update)();
	}
	add(in_added, in_isSystemObject = false) {
		this.#scene.add(in_added);
		if (in_isSystemObject) {
			return;
		}
		this.#userObjects.add(in_added);
		this.#updateZoomParams();
	}
	remove(in_removed, in_isSystemObject = false) {
		/*
			*** NOTE ***
			as remove is idempotent,
			children will be removed safety.
		*/
		this.#scene.remove(in_removed);
		if (in_isSystemObject) {
			return;
		}
		this.#userObjects.delete(in_removed);
		this.#updateZoomParams();
	}
	render() {
		this.#renderer.render(this.#scene, this.#camera);
	}
	start() {
		this.add(this.#cameraCtrl, true);
		this.#renderer.setAnimationLoop(() => {
			this.render();
			this.#animationHooks.forEach(in_hook => {
				(in_hook)();
			});
		});
	}
}

/*
	(3) Texture, MeshLambertMaterial, and BoxGeometry using cCache, which returns the same object in cache without creating.
*/

function factoryBuilder(in_constructor) {
	class cCache {
		static #cache = {};
		constructor(...in_args) {
			this.entity = (in_constructor)(...in_args);
		}
		static #genKey(...in_args) {
			const args = [];
			// assume in_args is primitive
			in_args.forEach(in_arg => {
				if (Number.isFinite(in_arg)) {
					args.push(Math.ceil(in_arg));
				} else {
					args.push(in_arg);
				}
			});
			return '_' + args.join('-');
		}
		static getRef(...in_args) {
			const key = cCache.#genKey(...in_args);
			if (key in cCache.#cache) {
				// console.log('cache hit ( cCache key : ' + key + ' )');
			} else {
				cCache.#cache[key] = new cCache(...in_args);
			}
			return cCache.#cache[key].entity;
		}
		static allClear(in_callback = null) {
			if (in_callback) {
				Object.keys(cCache.#cache).forEach(in_key => {
					(in_callback)(cCache.#cache[in_key].entity);
				});
			}
			cCache.#cache = {};
		}
	}
	/*
		*** NOTE ***
		when there are a lot of the same objects,
		and they can be shared using reference,
		cCache.getRef() returns reference.
	*/
	return {
		create : cCache.getRef,
		allClear : cCache.allClear
	};
}

CanvasRenderingContext2D.prototype.fillRoundRect = function(x, y, w, h, r) {
	this.beginPath();
	this.moveTo(x + r, y);
	this.lineTo(x + w - r, y);
	this.arc(x + w - r, y + r, r, Math.PI * (3 / 2), 0, false);
	this.lineTo(x + w, y + h - r);
	this.arc(x + w - r, y + h - r, r, 0, Math.PI * (1 / 2), false);
	this.lineTo(x + r, y + h);
	this.arc(x + r, y + h - r, r, Math.PI * (1 / 2), Math.PI, false);
	this.lineTo(x, y + r);
	this.arc(x + r, y + r, r, Math.PI, Math.PI * (3 / 2), false);
	this.closePath();
	this.fill();
}

const textureFactory = factoryBuilder((in_w, in_h) => {
	const gradation = 4
	// gradation (from black to white)
	let maxDepth = 255;
	let styles = [];
	for (let i = 0; i < gradation; i++) {
		let depth = Math.ceil(maxDepth / (gradation - 1) * i);
		styles[i] = 'rgb(' + depth + ',' + depth + ',' + depth + ')';
	}
	// draw and convert using toDataUR
	let canvas = document.createElement('CANVAS');
	canvas.width = in_w;
	canvas.height = in_h;
	const ctx = canvas.getContext('2d');
	let radius = gradation + 2;
	/*
		Rect           RoundRect      RoundRect

		##########     ##########     ##########
		##########     ##******##     ##******##
		##########     #********#     #**++++**#
		##########     #********#     #*++++++*#
		########## --> #********# --> #*++++++*# --> ...
		##########     #********#     #*++++++*#
		##########     #********#     #**++++**#
		##########     ##******##     ##******##
		##########     ##########     ##########
	*/
	for (let i = 0; i < gradation; i++) {
		ctx.fillStyle = styles[i];
		if (i > 0) {
			ctx.fillRoundRect(i, i, in_w - i * 2, in_h - i * 2, radius - i);
		} else {
			ctx.fillRect(i, i, in_w - i * 2, in_h - i * 2);
		}
	}
	return (new THREE.TextureLoader()).load(canvas.toDataURL());
});

const materialFactory = factoryBuilder((in_w, in_h, in_color) => {
	return new THREE.MeshLambertMaterial({
		color : in_color,
		map : textureFactory.create(in_w, in_h)
	});
});

function boxMaterials(in_x, in_y, in_z, in_colors) {
	/*
		     2    
		     |   5
		     |  /
		    ###/
		    ###
		1 --#*#-- 0
		    /##
		   /###
		  /  |
		 4   |
		     3
	*/
	return [
		materialFactory.create(in_z, in_y, in_colors[0]),
		materialFactory.create(in_y, in_z, in_colors[1]),
		materialFactory.create(in_x, in_z, in_colors[2]),
		materialFactory.create(in_x, in_z, in_colors[3]),
		materialFactory.create(in_x, in_y, in_colors[4]),
		materialFactory.create(in_x, in_y, in_colors[5])
	];
}

const boxGeometryFactory = factoryBuilder((in_x, in_y, in_z) => {
	const radian = 6;
	return roundBoxGeometry(in_x - radian * 2, in_y - radian * 2, in_z - radian * 2, radian);
});

const GRAY = 0x222222;

const ORANGE = 0xFFAA00;
const RED = 0xFF0000;
const WHITE = 0xFFFFFF;
const YELLOW = 0xFFFF00;
const BLUE = 0x3333FF;
const GREEN = 0x33CC33;

const SURFACEPROP = [];

if (getParam('color') === 'easy') {
	SURFACEPROP.push({V3 : DIRECTION.XP, COLOR : WHITE});
	SURFACEPROP.push({V3 : DIRECTION.XN, COLOR : WHITE});
	SURFACEPROP.push({V3 : DIRECTION.YP, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.YN, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.ZP, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.ZN, COLOR : BLUE});
} else {
	// standard color scheme
	SURFACEPROP.push({V3 : DIRECTION.XP, COLOR : ORANGE});
	SURFACEPROP.push({V3 : DIRECTION.XN, COLOR : RED});
	SURFACEPROP.push({V3 : DIRECTION.YP, COLOR : WHITE});
	SURFACEPROP.push({V3 : DIRECTION.YN, COLOR : YELLOW});
	SURFACEPROP.push({V3 : DIRECTION.ZP, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.ZN, COLOR : GREEN});
}

/*
	(4) dimension of Cube and Meshes of them
*/

const CUBE_SIZE = 400;

const gMeshLevelMap = ((in_cubeSize) => {
	const map = new cCyclicMap();
	const edgeMaterial = new THREE.MeshLambertMaterial({color : GRAY});
	const settings = [
		{
			dimension : 2,
			intersect : VEC3(1, 1, 1)
		},
		{
			dimension : 3,
			intersect : VEC3(2, 2, 2)
		},
		{
			dimension : 3,
			intersect : VEC3(2, 2, 1)
		},
		{
			dimension : 3,
			intersect : VEC3(2, 1, 1)
		},
		{
			dimension : 3,
			intersect : VEC3(1, 1, 1)
		},
	];
	settings.forEach(in_setting => {
		const unitSize = in_cubeSize / in_setting.dimension;
		const delta = in_setting.intersect.clone().multiplyScalar(unitSize * 0.5);
		const pieces = [];
		for (let z = 0; z <= in_setting.dimension - 1; z++) {
			for (let y = 0; y <= in_setting.dimension - 1; y++) {
				for (let x = 0; x <= in_setting.dimension - 1; x++) {
					const colors = SURFACEPROP.map(in_obj => in_obj.COLOR);
					const geometry = boxGeometryFactory.create(unitSize, unitSize, unitSize);
					// geometry has 7 groups (sub meshes)
					const materials = boxMaterials(unitSize, unitSize, unitSize, colors);
					materials.push(edgeMaterial);
					const positiveSide = VEC3(
						unitSize * (x + 0.5),
						unitSize * (y + 0.5),
						unitSize * (z + 0.5)
					).add(delta.clone().negate());
					const negativeSide = VEC3(
						unitSize * (x + 0.5) - in_cubeSize,
						unitSize * (y + 0.5) - in_cubeSize,
						unitSize * (z + 0.5) - in_cubeSize
					).add(delta);
					const isIntersected = [x, y, z].every((in_v, in_ix) => in_v < in_setting.intersect.toArray()[in_ix]);
					if (isIntersected) {
						// create x1
						const piece = new THREE.Mesh(geometry, materials);
						piece.position.copy(negativeSide);
						pieces.push(piece);
					} else {
						// create x2 (+ translated)
						const gemini1 = new THREE.Mesh(geometry, materials);
						gemini1.position.copy(negativeSide);
						pieces.push(gemini1);
						const gemini2 = new THREE.Mesh(geometry, materials);
						gemini2.position.copy(positiveSide);
						pieces.push(gemini2);
					}
				}
			}
		}
		const volume_default = 15;
		const volume_intersect = in_setting.intersect.toArray().reduce((acc, cur) => acc * cur, 1);
		const volume_current = (in_setting.dimension ** 3) * 2 - volume_intersect;
		const level = (volume_current / volume_default).toFixed(1);
		map.set('lv ' + level, pieces);
	});
	return map;
})(CUBE_SIZE);

let gMeshCurrentLevel = getParam('level');

if (gMeshCurrentLevel === false) {
	gMeshCurrentLevel = 0;
}

function getColorBySide(in_mesh, in_targetV3) {
	const matrix = (new THREE.Matrix4()).makeRotationFromQuaternion(in_mesh.quaternion);
	const invertV3 = in_targetV3.clone().applyMatrix4(matrix.invert());
	const err = 0.001;
	for (let i = 0; i < SURFACEPROP.length; i++) {
		const surfaceV3 = SURFACEPROP[i].V3;
		if (XYZ.every(in_xyz => Math.abs(invertV3[in_xyz] - surfaceV3[in_xyz]) < err)) {
			return in_mesh.material[i].color.getHex();
		}
	}
	return -1;
}

/*
	(5) Rubik's Cube related functions
*/

let AUDIO_ROTATION, AUDIO_ERROR, AUDIO_DUMMY;

createAudio('eJzt0jnTqkgYhuEfRNCigBC+zQ4i+5qJC6sim4C/furz1KkJpiac8kwVd9Lp1d0PQkc1AZAWkLorw6tgZ/SlyLCNAVo1EQsX5qEFOtRoV9i/ufh2eBCNaLwo6+WfHwbqBKpUzhZCAn1BGCF2RIi1EG2h3xE5GOHZQqwy3TAfYZZXLNrZIRIQBtGabgLTgHAhqVGLGx07B8mXQUBcdsN72Li+XMYuJjR7vy27oPYtRty4Kj0cx1J3N+jHz/eW53JkyoYVQErBA7wMA9xnu7/bOIq3z0I3Fe5oVu9QSqN8YbZ7bsuEh1pqPCf142kwW4cr0vA4ee3woggv4vSILeWOc5crbRFteWaINFrQYV7I53sa60VyApoZHeEpsJMNGD4XZp8IeYyvejfqUSbXfXVDTcOW1ydJeC2o9wiRVZmmD4V4Pto50KWPH1h1UCR0I0QD7KLd1bY2YQBBGCWxlouXEHZz3z9JW5xOcmQ3G/7hQWu+jpeW4k84tPW6kQtjOegpGvsI9ZLz2OQG5ufnI4mmpfx8Q5lwnLjcuBfhoc2N82kU0H2B9saO6FH/QEFkIaZY1BYAtCK0jUwpznlVZHZzPtT2dsfptZmISSpOR/Dksa4xZf96f1HdyeQln0DAWaFCNQGINuxewmk6GfmkZIt7Cob7u7jzziCWXby5G3MgHKjpfk6DOKtOWnkt9ovyGcz7mS5mq5Y7gu9655JNcrlVX5ZnG32HowbGoQxkTnU3QwRgt5WcvJB/p/RYDz0fi/k4T7JCJeM+9t1k6U+1QQqBM+smNKeSbc28reNdZ6TMbut9/IKhOd5FNjNchFniElcbAM6XU2sG4nFfu+xC2zN2VK6+P3Jx0EjBvLD5D/Xu6ZMv8ucS9UUv4UCpjHtQCzDFcscdz+/jkjwFlxvDJTeOoRIs150VXkty3F+44taQAnOxGHOw2G6DEhIhVc9ABU1TMUKo6H42RQR80+rVjegDyYmYPA5TLm71YjBsn/y1H7ERZzC6coISftpkn8NYqNkQcPCn5YnS0fGM0fBg+vg1StgBH1o/fvtv/7ed/9Y//OoPWq7gd6v/P231f7fV/91W/3db/d9t9X+31f/dVv93W/3fbfV/t9X/5/R/9/8Fg3FQCQ==').then(in_audio => AUDIO_ROTATION = in_audio);

createAudio('eJzt0smyslgWhuELYrAAAWG4kU2PSA/OUARppD2AcPUZ/6mqUUWOzYzwnazpEys+gLN2RUg5Izm8cScNOWmHxoR1xOL0xJabdrU7mCWVXBaM/UXiGYlbc1EgTigxF75liobJgceqfOHnnNHsjQUgcoy7O4BeRO4W48TO8cMcLtSTn4kf5rI8q0DRNPXS6BIrxITfGO9aQXHnFNlm6E8Sr5kjaWZVi0hiJF4kFDZQNIl/VoWu6ddr67chBZkv2S388Z8YYzflO7LSCYnITaZXWOwFOj+D2reClfpZMOYFIFKLhvEsrPTwxtrNd0dWjzWL6GLRUi8OdQRbWbsbgZB4DwgFI5HNIv+EzNTBgq2+nRh3RnuKjLWUdFJ6lp0j9c1OZ7VPnkdOyoxeGf2qKq/XvKR+XpXYkwJwAoCQoh0hoTc8SwKAQ9w/dn1MJeb16xc1bdLlp0p4E0LsUxsSaVcK1OiKN4fXyCZtag6ew/Zg5r5cBq69c4S5DMki7Pe3WpAKgByfzlvLC+vATGoOQMpt0xtZEaQTsvTX7RZNsiAcYo0liyU76SjP7xTWxfX19vXAD86UO5RH82KXr76NtlAnKBOGKNMKAwBgOeYAjdOh4lKrRHXicNf6iR3Sv37EqLQua3MRGTZidGPSH2hyiChaheGdRZmQeo4ZX2ZBPVsep6qXHqCzXEaMFDmHQJXF9BhlbEhR8rUF0E3JXsmaD9FPXZp11XQFzraNwYkTlyWtVHfuofpxRJ5vWcjHsn3LzlePrIEzUIWkHII0Z0PHIrKip2YAGmK/7Ejk1wRZcVS5pxNrq25JCpX7x++KmnrXA0YpFNVExEYN7APhvqQ6udkjih5b7Xh2GGK40tmS96qoSOtTqm1gk4gNiV7qkxy30Q6Q1bNbOUg7qDeDvaWI2uVORxatpiLjm9LkSgcxsO+vYfsZGulikrgKEzP782EyTTgB+obLo5K2rgBAAHBJd6QHPTTDQLdsR5OsaJVlbyovUhDIamoX/92Pujr8Zq6ocQrBULo3gWrfmLgMc6oRjDL25mif+qTuEuNk5sSYBnDvg5E7NgLQvulSUm/mIPikFwyXQSTdybOjEmF30P18rmZf98mFvUERks1hurbho7ZEUVKdA7hACt5LkPG0X7ZQp8Of1716oVeTA7HJ+yBifnXPxgLpa4CBu3u6am5ju8c4G9zqP34sJ3rNKqvT++twNZuEPuHtwVPAxwBlhCwkN3ExAnfIYT8AnOI3Bmkh2mjzUONZZzypUfZa2g1HJX4DmGPbQk0x2K8pFcZ8vXILewCiGW75aAMZHmjC9eZ+phex94NhTsswY07H2Qys20yNer4AvF3B4OJ4Bl4A4EhLv91uUUdPx2gvnOFh+oPk/fqlBAPCi7miEjl9Ijb9A2HndAjGsV0yH46iJIjcQhUaP4zh5EL3WARiAeJna/zw8LyXPbpkFqJwiYXydQ+ci5y/SyXn0ODlMPrAdCn8AJ1vvgrM0GzuHgp5monVKRiexUZONCr1Orqtxs4pj8KYAMKjysjpxcu4+mH+mdPeB2/RD8LQx/LZ9a3Z8tH665d5zCFJyFenRKgvxLyjT5ZzCv+h/Z9fcxBCSo3+F1n8nk87/66v/7N9/Z/t6/9sX/9n+/o/29f/2b7+z/b1f7av/7N9/f+c/u3+vwAz5Yo+').then(in_audio => AUDIO_ERROR = in_audio);

createAudio('eJztzsuOoloUgOEHYrDUXSAM1wbkfm0RYdaCbLwBoojw9J2qdCeVnJzp4XTCP/mnH4BrpIiGHy0dz5INNE41bU95QBFX7Y4VAPxZH7wCvBzG16AC14wACy8DHozVueAawo+Vl3GBgmM1qEbGi6Ws+hcjOP9QKy8TmUZPpEfqI2KGn6URmK/ABz4klaP6jzfKuugUdsmZfTF8FGs+JMBp/lgNLNknhzXLFHY4rol0HjDzNqrgmF68Loy+AHCNkCaGay2JnakMA64snqHEFCYDZ5sqABfxdY5ADmMrPD6E1unaLrl1RapfFk3YPNYKP7Rp8vCg2a3pCyR7t5BZEK+updcZaJWEf5fvPVjqUk1C4OqVcXKUhR6wLI8+cu3+3F1qQd/eADqPRT8db7lY7zofV+HLEwquP23oOAx1zyl4jJWI6XW3YczWnAusPv0pRf0cZb3WRQaiJFyqa/EOEYF73g7pioAYNVFOIY3FkJ5+PB246S6VbzAAcCKRdBA093rgiJDslyVJ27t25vb7eI9W/NPAwLNKc4TPuCcJHm+RxrvRsFzCyu0CorC8LQAWr1tjRy9xy7Wjz7+EGEpqJyffesRHj3d7rm7uNvCmbR41E3vKXDnpZOO3fyNRB/T3pcGg6806PcpJL6e08RTnoQS5jcu3lTe8fi0s4FMgRbnc2/orBakC8bm4PmO3i2MSk1PAEmrKgay+7rSWaK1Vdz9Y0miT3fNxdQQDarieiVCIZ5AqgRx30uZg2oz2PsNHnjq1Rz/kU+sLZV4BbMr8eUeMlAhtPW5pkGUJKcTdAThbeEfxl1/u5Z4eShv7M2KM3iFNNDXBrbpxw63TOVvsd/+jvru+/PoDEbUL/mnBvja189/6h98IZv9/2Oyfttk/bbN/2mb/tM3+aZv90zb7p232T9vsn7bZP22zf9r+dv/3/nb/L/4gyhY=').then(in_audio => AUDIO_DUMMY = in_audio);

class cRubiksCube extends THREE.Object3D {
	static #smallError = 0.01;
	static get err() {
		return cRubiksCube.#smallError;
	}
	static #orderBy(...in_args) {
		for (let i = 0; i < in_args.length - 1 ; i++) {
			if (in_args[i + 1] - in_args[i] < cRubiksCube.err) {
				return false;
			}
		}
		return true;
	}
	static #axes = {
		x : new THREE.Vector3(1, 0, 0),
		y : new THREE.Vector3(0, 1, 0),
		z : new THREE.Vector3(0, 0, 1)
	};
	static #axisProp(in_axis, in_match = true) {
		const props = Object.keys(cRubiksCube.#axes).filter(in_key => {
			const equal = cRubiksCube.#axes[in_key].equals(in_axis);
			return in_match ? equal : !equal;
		});
		if (props.length > 1) {
			return props;
		} else {
			return props[0];
		}
	}
	static #staticTest = {mode : false, obj : null};
	static unitTest(in_method, in_testObj = {}, ...in_args) {
		cRubiksCube.#staticTest.mode = true;
		cRubiksCube.#staticTest.obj = in_testObj
		const ret = eval('cRubiksCube.' + in_method + '(...in_args)');
		console.log(ret);
		throw new Error('end of unitTest'); 
	}
	#instanceTest = {mode : false, obj : null};
	unitTest(in_method, in_testObj = {}, ...in_args) {
		this.#instanceTest.mode = true;
		this.#instanceTest.obj = in_testObj
		const ret = eval('this.' + in_method + '(...in_args)');
		console.log(ret);
		throw new Error('unitTest'); 
	}
	get #settingVal() {
		if (this.userData.currentSettingKey) {
			return this.userData.settingPerPieces[this.userData.currentSettingKey];
		} else {
			throw new Error('no currentSettingKey');
		}
	}
	set #settingKey(in_value) {
		if (!this.userData.settingPerPieces) {
			this.userData.settingPerPieces = {};
		}
		if (!this.userData.settingPerPieces[in_value]) {
			this.userData.settingPerPieces[in_value] = {};
		}
		this.userData.currentSettingKey = in_value;
	}
	removePieces() {
		const pieces = this.children.slice();
		pieces.forEach(in_piece => {
			this.remove(in_piece);
		});
		this.userData.currentSettingKey = null;
	}
	addPieces(in_pieces) {
		this.removePieces();
		const uuids = [];
		in_pieces.forEach(in_piece => {
			if (!in_piece.userData.initialPosition) {
				// all pieces should have initial position to check complete
				in_piece.userData.initialPosition = in_piece.position.clone();
			}
			uuids.push(in_piece.uuid);
			this.add(in_piece);
		});
		this.#settingKey = pseudoMessageDigest1(uuids);
		if (!this.#settingVal.initialized) {
			this.#settingVal.completeCallback = null;
			this.#settingVal.rotationCount = 0;
			this.#settingVal.shuffled = false;
			this.#settingVal.initialized = true;
		}
	}
	getScore() {
		const max = 100;
		return Math.max(Math.ceil((max - this.#settingVal.rotationCount) / 10) * 10, 0);
	}
	isComplete() {
		return SURFACEPROP.every(in_prop => {
			const surfaceV3 = in_prop.V3;
			let sameColor = -1;
			return this.children.every(in_piece => {
				const color = getColorBySide(in_piece, surfaceV3);
				if (color === GRAY) {
					return true;
				}
				if (sameColor < 0) {
					sameColor = color;
					return true;
				}
				if (sameColor === color) {
					return true;
				} else {
					return false;
				}
			});
		});
	}
	#setupGroup(in_pieces) {
		const buffer = new THREE.Box3();
		const unionBox = new THREE.Box3();
		in_pieces.forEach(in_piece => {
			unionBox.union(buffer.setFromObject(in_piece));
		});
		/*
			*** NOTE ***
			property of rotation will be changed in uiUpdatePosition().
			at that time, it will be decided based on position of group.
			though position was fixed to (0, 0, 0) before,
			center of the box is used now.
		*/
		const group = new THREE.Object3D();
		this.add(group);
		group.position.copy(unionBox.getCenter(VEC3()));
		in_pieces.forEach(in_piece => {
			group.attach(in_piece);
		});
		return group;
	}
	#releaseGroup(in_group) {
		const copiedPieces = [...in_group.children];
		copiedPieces.forEach(in_piece => {
			/*
				*** NOTE ***
				"add" follows parent position.
				"attach" keeps world position.
				in addition, both of them internally call "remove" from other object.
			*/
			this.attach(in_piece);
		});
		this.remove(in_group);
	}
	#splitGroupByAxis_1_groupBySameScalar(io_scalarMap, in_axis) {
		this.children.forEach(in_piece => {
			const component = in_piece.position.dot(in_axis);
			const reference = io_scalarMap.get(component);
			if (reference) {
				// there already exists almost the same component
				reference.pieces.push(in_piece);
				reference.tmpBox.union(new THREE.Box3().setFromObject(in_piece));
			} else {
				io_scalarMap.set(component, {
					pieces : [in_piece],
					tmpBox : (new THREE.Box3()).setFromObject(in_piece)
				});
			}
		});
	}
	static #splitGroupByAxis_2_calculateEdges(io_scalarMap, in_axis) {
		for (const [scalar, info] of io_scalarMap.entries()) {
			const length = (new THREE.Vector3().subVectors(info.tmpBox.max, info.tmpBox.min)).dot(in_axis);
			info.edgeL = scalar - length / 2;
			info.edgeR = scalar + length / 2;
			delete info.tmpBox;
		}
	}
	static #splitGroupByAxis_3_makeCandidatesBorder(in_scalarMap) {
		const candidateBorderSet = new cApproximateSet(cRubiksCube.err);
		for (const info of in_scalarMap.values()) {
			candidateBorderSet.add(info.edgeL);
			candidateBorderSet.add(info.edgeR);
		}
		const candidateBorder = Array.from(candidateBorderSet);
		candidateBorder.sort((a, b) => a - b);
		candidateBorder.shift();
		candidateBorder.pop();
		return candidateBorder;
	}
	static #splitGroupByAxis_4_makeActualBorder(in_scalarMap, in_candidateBorder) {
		const actualBorder = [];
		for (let i = 0; i < in_candidateBorder.length; i++) {
			let isBorder = true;
			for (const info of in_scalarMap.values()) {
				if (cRubiksCube.#orderBy(info.edgeL, in_candidateBorder[i], info.edgeR)) {
					isBorder = false;
					break;
				}
			}
			if (isBorder) {
				actualBorder.push(in_candidateBorder[i]);
			}
		}
		return actualBorder;
	}
	static #splitGroupByAxis_5_makeActualBorder(in_scalarMap, in_actualBorder) {
		const groups = [];
		let next = 0;
		in_actualBorder.push(Infinity);
		in_actualBorder.forEach(border => {
			const pieces = [];
			for (let i = next; i < in_scalarMap.size; i++) {
				const ascendingScalar = in_scalarMap.sortedKey(i);
				if (ascendingScalar < border) {
					const info = in_scalarMap.get(ascendingScalar);
					pieces.push(...info.pieces);
				} else {
					next = i;
					break;
				}
			}
			groups.push(pieces);
		});
		return groups;
	}
	#splitGroupByAxis(in_axis) {
		/*
			step #1 : scalarMap is the group of position based on in_axis. for example ...

				+---+---+---+---+---+---+
				| x | x | x | x | x | x |
				+---+---+---+---+---+---+
				| x |   x   | x | x | x |
				+---+---+---+---+---+---+
				| x |       x       | x |
				+---+---+---+---+---+---+

				--x---x-x-x-x-x---x---x--> : in_axis

				 3.00, {tmpBox, piece + piece + piece}
				 7.00, {tmpBox, piece}
				 9.00, {tmpBox, piece}
				11.00, {tmpBox, piece}
				13.00, {tmpBox, piece}
				15.00, {tmpBox, piece + piece}
				19.00, {tmpBox, piece + piece}
				23.00, {tmpBox, piece + piece + piece}

			step #2 : calculate edges for the bounding box. for example ...

				 3.00, {edgeL =  1.00, edgeR =  5.00, piece + piece + piece}
				 7.00, {edgeL =  5.00, edgeR =  9.00, piece}
				 9.00, {edgeL =  5.00, edgeR = 13.00, piece}
				11.00, {edgeL =  9.00, edgeR = 13.00, piece}
				13.00, {edgeL =  5.00, edgeR = 21.00, piece}
				15.00, {edgeL = 13.00, edgeR = 17.00, piece + piece}
				19.00, {edgeL = 17.00, edgeR = 21.00, piece + piece}
				23.00, {edgeL = 21.00, edgeR = 25.00, piece + piece + piece}
		*/
		let scalarMap = new cApproximateMap(cRubiksCube.err);
		if (this.#instanceTest.mode) {
			scalarMap = this.#instanceTest.obj;
		} else {
			this.#splitGroupByAxis_1_groupBySameScalar(scalarMap, in_axis);
			cRubiksCube.#splitGroupByAxis_2_calculateEdges(scalarMap, in_axis);
		}
		/*
			step #3 : make candidates of border which decides group
		*/
		const candidateBorder = cRubiksCube.#splitGroupByAxis_3_makeCandidatesBorder(scalarMap);
		if (this.#instanceTest.mode) {
			/*
				*** NOTE ***
				to display a reference using "console.log", you should use a copy of the reference.
				without it, the entity may appear updated when displayed because the console holds a reference,
				and any subsequent changes to the object will be reflected in the console.
			*/
			console.log('#3', [...candidateBorder]);
		}
		/*
			step #4 : check if candidates is actual border

			    v   v
			+---+---+---+
			| x | x | x |
			+---+---+---+ : border = 2
			| x | x | x |
			+---+---+---+

			        v
			+---+---+---+
			| x | x | x |
			+---+---+---+ : border = 1
			|   x   | x |
			+---+---+---+

			+---+---+---+
			| x |   x   |
			+---+---+---+ : border = 0
			|   x   | x |
			+---+---+---+
		*/
		const actualBorder = cRubiksCube.#splitGroupByAxis_4_makeActualBorder(scalarMap, candidateBorder);
		if (this.#instanceTest.mode) {
			console.log('#4', [...actualBorder]);
		}
		/*
			step #5 : finally, make group which will move together
		*/
		const groups = cRubiksCube.#splitGroupByAxis_5_makeActualBorder(scalarMap, actualBorder)
		if (this.#instanceTest.mode) {
			console.log('#5', [...groups]);
		}
		return groups;
	}
	#makeRotationGroup(in_piece, in_axis) {
		const groups = this.#splitGroupByAxis(in_axis);
		for (let i = 0; i < groups.length; i++) {
			if (groups[i].includes(in_piece)) {
				return groups[i];
			}
		}
		return null;
	}
	makeRandomRotationProgress(in_callback) {
		let axis;
		let pieces;
		let maxLoopCount = 100;
		while (true) {
			if (--maxLoopCount === 0) {
				throw new Error('maxLoopCount'); 
			}
			const _piece = (this.children)[arrRand]();
			axis = (Object.values(cRubiksCube.#axes))[arrRand]();
			pieces = this.#makeRotationGroup(_piece, axis);
			if (pieces.length < this.children.length) {
				break;
			}
		}
		let ratioCurrent = 0;
		const ratioStep = 1 / 20;
		const group = this.#setupGroup(pieces);
		let unitAngle = Math.PI;
		if (cRubiksCube.#groupIsMovable90(group, axis)) {
			unitAngle = Math.PI / 2;
		}
		// this progress function assumes to be called by requestAnimationFrame()
		const progress = () => {
			ratioCurrent += ratioStep;
			group.rotation[cRubiksCube.#axisProp(axis)] = unitAngle * ratioCurrent;
			if (ratioCurrent >= 1) {
				group.rotation[cRubiksCube.#axisProp(axis)] = unitAngle;
				this.#releaseGroup(group);
				this.#settingVal.shuffled = true;
				// this progress function should be stopped in callback
				ratioCurrent = 1;
			}
			(in_callback)(ratioCurrent);
		};
		return progress;
	}
	registerCompleteCallback(in_callback) {
		this.#settingVal.completeCallback = in_callback;
	}
	removeCompleteCallback() {
		this.#settingVal.completeCallback = null;
	}
	static #getRotationAxis(in_surfaceV3, in_directionV3) {
		/*
			{surface : new THREE.Vector3(+1, 0, 0), direction : new THREE.Vector3(0, +1, 0), expected : new THREE.Vector3(0, 0, +1)},
			{surface : new THREE.Vector3(+1, 0, 0), direction : new THREE.Vector3(0, -1, 0), expected : new THREE.Vector3(0, 0, -1)},
			{surface : new THREE.Vector3(-1, 0, 0), direction : new THREE.Vector3(0, +1, 0), expected : new THREE.Vector3(0, 0, -1)},
			{surface : new THREE.Vector3(-1, 0, 0), direction : new THREE.Vector3(0, -1, 0), expected : new THREE.Vector3(0, 0, +1)},
			...
		*/
		const rotationAxis = new THREE.Vector3();
		rotationAxis.crossVectors(in_surfaceV3, in_directionV3);
		return rotationAxis;
	}
	static #detectMovingDirection(in_dstV3, in_srcV3, in_surfaceV3) {
		const vec3 = (new THREE.Vector3()).subVectors(in_dstV3, in_srcV3);
		const axes = [
			new THREE.Vector3(+1, 0, 0),
			new THREE.Vector3(-1, 0, 0),
			new THREE.Vector3(0, +1, 0),
			new THREE.Vector3(0, -1, 0),
			new THREE.Vector3(0, 0, +1),
			new THREE.Vector3(0, 0, -1)
		];
		const ret = {
			minAngle : Infinity,
			directionAxis : null,
			rotationAxis : null
		};
		axes.forEach(in_axis => {
			if (in_axis.dot(in_surfaceV3) !== 0) {
				// in_axis which is not the same as in_surfaceV3 will be taken for rotation
				return;
			}
			const angle = vec3.angleTo(in_axis);
			if (angle < ret.minAngle) {
				ret.minAngle = angle;
				ret.directionAxis = in_axis;
				// rotationAxis may have negative value as component
				ret.rotationAxis = cRubiksCube.#getRotationAxis(in_surfaceV3, in_axis);
			}
		});
		return ret;
	}
	static #groupIsMovable90(in_group, in_axis) {
		// assume in_group has children which compose rotateion group
		const boxes = new cBoxCollection(in_group.children);
		const ax = cRubiksCube.#axisProp(in_axis, false);
		const error = 0.01;
		const size1 = boxes.max[ax[0]] - boxes.min[ax[0]];
		const size2 = boxes.max[ax[1]] - boxes.min[ax[1]];
		if (Math.abs(size1 - size2) > error) {
			return false;
		}
		const quat = (new THREE.Quaternion()).setFromAxisAngle(in_axis, Math.PI / 2);
		let testCnt = 10;
		const points = boxes.getRandomPoints(testCnt);
		for (let i = 0; i < testCnt; i++) {
			const preRotation = in_group.position.clone().negate();
			const postRotation = in_group.position;
			points[i].add(preRotation).applyQuaternion(quat).add(postRotation);
			if (!boxes.containsPoint(points[i])) {
				return false;
			}
		}
		return true;
	}
	static #uiStates  = {
		DISABLED : Symbol(),
		ENABLED : Symbol(),
		DRAGGING : Symbol(),
		MOVING : Symbol(),
		MOMENTUM : Symbol()
	}
	/*
		ENABLED <-------------------+
		|                           |
		+-[disable]-----+           |
		|               |           |
		|   DISABLED <--+           |
		|   |                       |
		|   +-[enable]--------------+
		|                           |
		+-[drag]--------+           |
		                |           |
		    DRAGGING <--+           |
		    |                       |
		    +-[release]-------------+
		    |                       |
		    +-[movable]-----+       |
		                    |       |
		        MOVING <----+       |
		        |                   |
		        +-[release]-----+   |
		                        |   |
		            MOMENTUM <--+   |
		            |               |
		            +-[stop]--------+
	*/
	static #uiTransitions = {
		[cRubiksCube.#uiStates.DISABLED]: {
			enable : cRubiksCube.#uiStates.ENABLED
		},
		[cRubiksCube.#uiStates.ENABLED]: {
			disable : cRubiksCube.#uiStates.DISABLED,
			drag : cRubiksCube.#uiStates.DRAGGING
		},
		[cRubiksCube.#uiStates.DRAGGING]: {
			release : cRubiksCube.#uiStates.ENABLED,
			movable : cRubiksCube.#uiStates.MOVING
		},
		[cRubiksCube.#uiStates.MOVING]: {
			release : cRubiksCube.#uiStates.MOMENTUM
		},
		[cRubiksCube.#uiStates.MOMENTUM]: {
			stop : cRubiksCube.#uiStates.ENABLED
		}
	};
	#uiSession = {
		state : cRubiksCube.#uiStates.ENABLED,
		ctx : {}
	};
	#transition(in_action) {
		const newState = cRubiksCube.#uiTransitions[this.#uiSession.state]?.[in_action];
		if (newState) {
			this.#uiSession.state = newState;
		} else {
			throw new Error('invalid transition : ' + in_action);
		}
	}
	uiEnable() {
		if (this.#uiSession.state !== cRubiksCube.#uiStates.DISABLED) {
			console.log('state is not DISABLED');
			return;
		}
		this.#transition('enable');
	}
	uiDisable() {
		if (this.#uiSession.state !== cRubiksCube.#uiStates.ENABLED) {
			console.log('state is not ENABLED');
			return;
		}
		this.#transition('disable');
	}
	#uiInitSession() {
		if (this.#uiSession.ctx.roGroup) {
			this.#releaseGroup(this.#uiSession.ctx.roGroup);
		}
		this.#uiSession.ctx = {};
	}
	uiSetInitPosition(in_piece, in_surfaceV3, in_posV3, in_posV2) {
		// in_posV3 : intersection with a in_piece
		// in_posV2 : NDC (Normalized Device Coordinates)
		if (this.#uiSession.state !== cRubiksCube.#uiStates.ENABLED) {
			console.log('state is not ENABLED');
			return;
		}
		this.#uiSession.ctx = {
			piece : in_piece,
			initPosV3 : in_posV3,
			initPosV2 : in_posV2,
			surfaceV3 : in_surfaceV3,
			roGroup : null,
			roUnitAngle : Math.PI,
			roRadian : 0,
			roAxisDir : 0,
			roAxisXYZ : null,
			initDirV2 : null
		};
		this.#transition('drag');
	}
	uiDeltaFromStartV2(in_posV2) {
		return in_posV2.distanceTo(this.#uiSession.ctx.initPosV2);
	}
	uiDeltaFromStartV3(in_posV3) {
		return in_posV3.distanceTo(this.#uiSession.ctx.initPosV3);
	}
	uiIsDragging() {
		return (this.#uiSession.state === cRubiksCube.#uiStates.DRAGGING);
	}
	uiIsMoving() {
		return (this.#uiSession.state === cRubiksCube.#uiStates.MOVING);
	}
	static uiSetDeltaPositionRC = {
		NOOP : Symbol(),
		// as delta is not enough, need to call uiNotifyDeltaPosition again
		NOTENOUGH : Symbol(),
		// though delta is enough, can't make group
		UNMOVABLE : Symbol(),
		// as delta is enough, can call uiUpdatePosition
		MOVABLE : Symbol()
	};
	uiNotifyDeltaPosition(in_piece, in_posV3, in_posV2) {
		// in_posV3 : intersection with a in_piece
		// in_posV2 : NDC (Normalized Device Coordinates)
		const RC = cRubiksCube.uiSetDeltaPositionRC;
		if (this.#uiSession.state !== cRubiksCube.#uiStates.DRAGGING) {
			console.log('state is not DRAGGING');
			return RC.NOOP;
		}
		const ctx = this.#uiSession.ctx;
		const moving = cRubiksCube.#detectMovingDirection(in_posV3, ctx.initPosV3, ctx.surfaceV3);
		const angle22_5 = Math.PI / 8;
		if (moving.minAngle > angle22_5) {
			return RC.NOTENOUGH;
		}
		// component for makeRotationGroup should be +1
		const axis = moving.rotationAxis.clone().multiply(moving.rotationAxis);
		const pieces = this.#makeRotationGroup(ctx.piece, axis);
		if (pieces.length < this.children.length) {
			this.#transition('movable');
			ctx.roGroup = this.#setupGroup(pieces);
			if (cRubiksCube.#groupIsMovable90(ctx.roGroup, axis)) {
				ctx.roUnitAngle = Math.PI / 2;
			}
			// use Vector3(1, 1, 1) to extruct +1 or -1
			ctx.roAxisDir = moving.rotationAxis.dot(new THREE.Vector3(1, 1, 1));
			ctx.roAxisXYZ = cRubiksCube.#axisProp(axis);
			ctx.initDirV2 = in_posV2.clone().sub(ctx.initPosV2);
			return RC.MOVABLE;
		} else {
			return RC.UNMOVABLE;
		}
	}
	uiUpdatePosition(in_posV2) {
		// in_posV2 : NDC (Normalized Device Coordinates)
		if (this.#uiSession.state !== cRubiksCube.#uiStates.MOVING) {
			return;
		}
		const ctx = this.#uiSession.ctx;
		const currentDirV2 = in_posV2.clone().sub(ctx.initPosV2);
		let speedupWhen180 = ctx.roUnitAngle / (Math.PI / 2);
		let rad = in_posV2.distanceTo(ctx.initPosV2) * ctx.roAxisDir * speedupWhen180;
		if (ctx.initDirV2.dot(currentDirV2) > 0) {
			// currentDirV2 & initDirV2 --> SAME direction
			rad *= +1;
		} else {
			// currentDirV2 & initDirV2 --> OPPOSITE direction
			rad *= -1;
		}
		/*
			*** NOTE ***
			if using rotateOnAxis() several times, small errors will be expanded.
			if making group every time too, the same issue will happen.
		*/
		ctx.roGroup.rotation[ctx.roAxisXYZ] = rad;
		let snap;
		if (ctx.roUnitAngle === Math.PI) {
			snap = snapToPI;
		} else {
			snap = snapTo05PI;
		}
		const overTheTop = ((snap)(rad) != (snap)(ctx.roRadian));
		ctx.roRadian = rad;
		// if true, caller may show some effects.
		return overTheTop;
	}
	uiRelease(in_ending_callback) {
		if (this.#uiSession.state === cRubiksCube.#uiStates.DRAGGING) {
			this.#uiInitSession();
			this.#transition('release');
			return null;
		}
		if (this.#uiSession.state !== cRubiksCube.#uiStates.MOVING) {
			return null;
		}
		this.#transition('release');
		const ctx = this.#uiSession.ctx;
		const startRad = ctx.roRadian;
		let snap;
		if (ctx.roUnitAngle === Math.PI) {
			snap = snapToPI;
		} else {
			snap = snapTo05PI;
		}
		const finalRad = (snap)(ctx.roRadian);
		const duration = 100;
		const ease = new cEase(startRad, finalRad, duration);
		// this progress function assumes to be called by requestAnimationFrame()
		const progress = () => {
			ctx.roRadian = ease.currentEasingIn();
			ctx.roGroup.rotation[ctx.roAxisXYZ] = ctx.roRadian;
			if (ctx.roRadian !== finalRad) {
				return;
			}
			// execute once at the end
			this.#uiInitSession();
			this.#transition('stop');
			(in_ending_callback)();
			if (!this.#settingVal.shuffled) {
				// when without shuffled, do nothing
				return;
			}
			this.#settingVal.rotationCount++;
			if (this.#settingVal.completeCallback && this.isComplete()) {
				(this.#settingVal.completeCallback)(this.#settingVal.rotationCount);
			}
		};
		return progress;
	}
}

function test_makeGroupOnAxis(in_arr) {
	const scalarMap = new cApproximateMap(cRubiksCube.err);
	in_arr.forEach(in_elem => {
		in_elem[0] += Math.random() / 10000;
		in_elem[1].edgeL += Math.random() / 10000;
		in_elem[1].edgeR += Math.random() / 10000;
		scalarMap.set(in_elem[0], in_elem[1]);
	});
	(new cRubiksCube()).unitTest('#splitGroupByAxis', scalarMap);
}

/*
	--x-x---x-x-->

	+---+---+---+
	| x |   x   |
	+---+---+---+
	|   x   | x |
	+---+---+---+

test_makeGroupOnAxis([
	[ 3.0000, {edgeL : 1.0000, edgeR :  5.0000, pieces : ['a']}],
	[ 5.0000, {edgeL : 1.0000, edgeR :  9.0000, pieces : ['b']}],
	[ 9.0000, {edgeL : 5.0000, edgeR : 13.0000, pieces : ['c']}],
	[11.0000, {edgeL : 9.0000, edgeR : 13.0000, pieces : ['d']}]
]);

*/

/*
	--x-x-x-x-x-->

	+---+---+---+
	| x | x | x |
	+---+---+---+
	| x |   x   |
	+---+---+---+
	|   x   | x |
	+---+---+---+

test_makeGroupOnAxis([
	[ 3.0000, {edgeL : 1.0000, edgeR :  5.0000, pieces : ['a','b']}],
	[ 5.0000, {edgeL : 1.0000, edgeR :  9.0000, pieces : ['c']}],
	[ 7.0000, {edgeL : 5.0000, edgeR :  9.0000, pieces : ['d']}],
	[ 9.0000, {edgeL : 5.0000, edgeR : 13.0000, pieces : ['e']}],
	[11.0000, {edgeL : 9.0000, edgeR : 13.0000, pieces : ['f','g']}]
]);

*/

/*
	--x---x-x-x-x-x---x---x-->

	+---+---+---+---+---+---+
	| x | x | x | x | x | x |
	+---+---+---+---+---+---+
	| x |   x   | x | x | x |
	+---+---+---+---+---+---+
	| x |       x       | x |
	+---+---+---+---+---+---+

test_makeGroupOnAxis([
	[ 3.0000, {edgeL :  1.0000, edgeR :  5.0000, pieces : ['a','b','c']}],
	[ 7.0000, {edgeL :  5.0000, edgeR :  9.0000, pieces : ['d']}],
	[ 9.0000, {edgeL :  5.0000, edgeR : 13.0000, pieces : ['f']}],
	[11.0000, {edgeL :  9.0000, edgeR : 13.0000, pieces : ['g']}],
	[13.0000, {edgeL :  5.0000, edgeR : 21.0000, pieces : ['e']}],
	[15.0000, {edgeL : 13.0000, edgeR : 17.0000, pieces : ['h','i']}],
	[19.0000, {edgeL : 17.0000, edgeR : 21.0000, pieces : ['j','k']}],
	[23.0000, {edgeL : 21.0000, edgeR : 25.0000, pieces : ['l','m','n']}]
]);

*/

/*
	(6) ui & dom setting

	gWorld (cSphericalWorld)
	|
	+-- gCube (cRubiksCube)
		|
		+-- meshes <--- gMeshLevelMap
*/

const WORLD_RADIUS = CUBE_SIZE * 10;
const WORLD_INIT_ZOOM = WORLD_RADIUS / 2;

const gWorld = new cSphericalWorld(WORLD_RADIUS);

const gCube = new cRubiksCube();

gWorld.add(gCube);

gWorld.moveView(2.5, 0.5);
gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);

/*
	*** NOTE ***
	when you use AxesHelper,
	// gWorld.add(new THREE.AxesHelper(WORLD_RADIUS));
	gWorld.setZoom() can not work well.
*/

class cWarpLine {
	static #speed = 10;
	static #gradation = 10;
	constructor(in_canvas) {
		const w = in_canvas.width;
		const h = in_canvas.height;
		this.ctx = in_canvas.getContext('2d');
		this.box = new THREE.Box2(
			new THREE.Vector2(0, 0),
			new THREE.Vector2(w, h)
		);
		this.from = new THREE.Vector2(w / 2, h / 2);
		this.#reset();
	}
	#reset() {
		const angle = Math.random() * Math.PI * 2;
		this.direction = new THREE.Vector2(Math.cos(angle), Math.sin(angle));
		this.speed = Math.random() * cWarpLine.#speed + 5;
		this.length = 0;
	}
	#curVec(in_scalar) {
		return this.from.clone().add(this.direction.clone().multiplyScalar(in_scalar));
	}
	#drawGrayLine(in_from, in_to, in_grayScale) {
		const gray = (in_grayScale << 16) | (in_grayScale << 8) | in_grayScale;
		this.ctx.strokeStyle = '#' + gray.toString(16).padStart(6, '0');
		this.ctx.beginPath();
		this.ctx.moveTo(in_from.x, in_from.y);
		this.ctx.lineTo(in_to.x, in_to.y);
		this.ctx.stroke();
	}
	update() {
		this.length += this.speed;
		const to = this.#curVec(this.length);
		if (this.box.containsPoint(to)) {
			const notch = this.length / cWarpLine.#gradation;
			for (let i = 0; i < cWarpLine.#gradation; i++) {
				this.#drawGrayLine(
					this.#curVec(notch * i),
					this.#curVec(notch * (i + 1)),
					255 / cWarpLine.#gradation * (i + 1)
				);
			}
		} else {
			/*
				*** NOTE ***
				even if overwritung using black,
				this.#drawGrayLine(this.from, to, 0x00);
				smudge of white line will remain.
			*/
			this.#reset();
		}
	}
}

function warpViewProgress(in_canvas, in_lineCount) {
	const warpLines = [];
	for (let i = 0; i < in_lineCount; i++) {
		warpLines.push(new cWarpLine(in_canvas));
	}
	return () => {
		warpLines.forEach(in_line => {
			in_line.update();
		});
	}
}

function complete() {
	const progress = warpViewProgress(gBackgroundCanvas, 50);
	gWorld.addAnimationHook(progress);
	const duration = 2000;
	gWorld.motionZoom2(gWorld.zoomMin, duration * 0.9);
	window.setTimeout(() => {
		gWorld.removeAnimationHook(progress);
		gCube.removeCompleteCallback();
		const dialog = document.createElement('div');
		Object.assign(dialog.style, {
			width : 'auto',
			height : 'auto',
			background : 'black',
			borderRadius : '1em',
			padding : '1.5em'
		});
		([
			'<div>Congratulation !!</div>',
			'<div>( Your score is : ' + gCube.getScore() + ' )</div>',
			'<div>Thanks to your wisdom, peace in the universe has been preserved.</div>',
			'<div>Click to go next stage.</div>',
		]).forEach(in_fragment => {
			dialog.innerHTML += in_fragment;
		});
		setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white');
		startDialog(dialog, () => {
			drawCosmicView(gBackgroundCanvas, 400, 50);
			gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);
		});
		nextLevel(false);
	}, duration);
}

function shuffle(in_count) {
	const randomRotation = (in_remaining_count) => {
		let overTheTop = false;
		const callback = (in_ratio) => {
			if ((in_ratio > 0.4) && !overTheTop) {
				AUDIO_ROTATION.play();
				overTheTop = true;
			}
			if (in_ratio < 1) {
				return;
			}
			gWorld.removeAnimationHook(progress);
			if (in_remaining_count > 1) {
				(randomRotation)(in_remaining_count - 1);
			} else {
				gWorld.stopRotation();
				gCube.uiEnable();
			}
		};
		const progress = gCube.makeRandomRotationProgress(callback);
		gWorld.addAnimationHook(progress);
	};
	gCube.registerCompleteCallback(complete);
	gCube.uiDisable();
	gWorld.startRotation(VEC3().random().multiplyScalar(0.05));
	(randomRotation)(in_count);
}

function setTransition(in_elem, in_shorthand, in_val1, in_val2) {
	const components = in_shorthand.split(/\s+/);
	in_elem.style.transition = in_shorthand;
	in_elem.style[components[0]] = in_val1;
	window.setTimeout(() => {
		/*
			*** NOTE ***
			to fire the transition function,
			the final style should be set in the next event loop.
		*/
		in_elem.style[components[0]] = in_val2;
	}, 0);
}

function startDialog(in_element, in_callback = null) {
	const background = document.createElement('div');
	Object.assign(background.style, {
		position : 'fixed',
		left : '0px',
		top : '0px',
		width : '100%',
		height : '100%',
		zIndex : 2 ** 31 - 1
	});
	background.appendChild(in_element);
	Object.assign(in_element.style, {
		position : 'absolute',
		left : '50%',
		top : '50%',
		transform : 'translate(-50%, -50%)'
	});
	document.body.appendChild(background);
	const closeDialog = () => {
		document.body.removeChild(background);
		if (in_callback) {
			(in_callback)();
		}
	};
	background.addEventListener('mousedown', closeDialog);
	background.addEventListener('touchstart', closeDialog);
}

function shuffle3() {
	shuffle(3);
}

function shuffle10() {
	shuffle(10);
}

function uiHelp() {
	const url = {
		ver : './version.txt',
		im1 : 'https://pj-corridor.net/images/cube-2-03.png',
		im2 : 'https://pj-corridor.net/images/diamond-2-4.png',
		im3 : 'https://pj-corridor.net/images/cube-6-03.png',
		im4 : 'https://pj-corridor.net/images/diamond-6-4.png',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div>';
	[url.im1, url.im2, url.im3, url.im4].forEach(in_img => {
		dialog.innerHTML += '<img width="100" src="' + in_img + '" />';
	});
	dialog.innerHTML += '</div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getVersion(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.log(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Rights</dt>',
		'<dd>This software is based on MIT License.</dd>',
		'<dd>The code can be freely modified and reused.</dd>',
		'<dd>For full license details, please refer to :</dd>',
		'<dd>https://opensource.org/licenses/MIT</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white')
	startDialog(dialog);
}

const ID_PREV_LEVEL = randomString();
const ID_NEXT_LEVEL = randomString();

function updateLevelText() {
	const prev = gMeshLevelMap.prevItemByOrder(gMeshCurrentLevel);
	const next = gMeshLevelMap.nextItemByOrder(gMeshCurrentLevel);
	document.getElementById(ID_PREV_LEVEL).innerText = prev.k;
	document.getElementById(ID_NEXT_LEVEL).innerText = next.k;
}

async function changeLevel(in_delta) {
	const color = 0x000000;
	await gWorld.motionFog(color, 0, 100);
	gMeshCurrentLevel = (gMeshCurrentLevel + in_delta + gMeshLevelMap.size) % gMeshLevelMap.size;
	gCube.removePieces();
	const current = gMeshLevelMap.currItemByOrder(gMeshCurrentLevel);
	gCube.addPieces(current.v);
	await gWorld.motionFog(color, 100, 0);
	updateLevelText();
}

function prevLevel(in_sound = true) {
	if (in_sound) {
		AUDIO_ROTATION.play();
	}
	changeLevel(-1);
}

function nextLevel(in_sound = true) {
	if (in_sound) {
		AUDIO_ROTATION.play();
	}
	changeLevel(+1);
}

(() => {
	const settings = [
		{
			id : ID_PREV_LEVEL,
			text : '(Prev)',
			func : prevLevel
		},
		{
			id : ID_NEXT_LEVEL,
			text : '(Next)',
			func : nextLevel
		},
		{
			text : 'Shuffle x3',
			func : shuffle3
		},
		{
			text : 'Shuffle x10',
			func : shuffle10
		},
		{
			text : 'help',
			func : uiHelp
		},
		{
			text : 'Rights',
			func : uiRights
		}
	];
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	settings.forEach(in_setting => {
		let button = document.createElement('button');
		if (in_setting.id) {
			button.id = in_setting.id;
		}
		if (in_setting.text) {
			button.innerText = in_setting.text;
		}
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})();

changeLevel(0);

function hex2rgb(in_hex) {
	const mask = 0xFF;
	const r = (in_hex >> 16) & mask;
	const g = (in_hex >> 8) & mask;
	const b = in_hex & mask;
	return [r, g, b];
}

function drawCosmicView(in_canvas, in_stars, in_nebulae_patterns, in_color = 0x000064) {
	const ctx = in_canvas.getContext('2d');
	const w = in_canvas.width;
	const h = in_canvas.height;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	for (let i = 0; i < in_nebulae_patterns; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 100 + 50;
		const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
		const rgb = hex2rgb(in_color);
		gradient.addColorStop(0, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0.5)');
		gradient.addColorStop(1, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0)');
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = gradient;
		ctx.fill();
	}
	for (let i = 0; i < in_stars; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 1;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = 'white';
		ctx.fill();
	}
}

const gBackgroundCanvas = document.createElement('CANVAS');

Object.assign(gBackgroundCanvas.style, {
	position : 'absolute',
	left : 0,
	top : 0,
	zIndex : -1
});

document.addEventListener('DOMContentLoaded', (() => {
	let resizeWorld = (() => {
		gWorld.resize(
			window.innerWidth,
			window.innerHeight);
		gBackgroundCanvas.width = window.innerWidth;
		gBackgroundCanvas.height = window.innerHeight;
		drawCosmicView(gBackgroundCanvas, 400, 50);
	});
	let resizeTimeout = null;
	const debounce_delay = 300;
	window.addEventListener('resize', () => {
		if (resizeTimeout) {
			window.clearTimeout(resizeTimeout);
		}
		resizeTimeout = window.setTimeout(resizeWorld, debounce_delay);
	});
	(resizeWorld)();
	if (!document.body) {
		document.documentElement.appendChild(document.createElement('BODY'));
	}
	document.body.style.margin = '0';
	document.body.style.overflow = 'hidden';
	document.body.appendChild(gWorld.canvas);
	document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

/*
	(7) event handlers + emulation
*/

(() => {
	/*
		*** NOTE ***
		Safari may restrict sound without user interaction.
		because of this, the sound does not work without this code.
	*/
	const once = (in_ev) => {
		AUDIO_DUMMY.play();
		gWorld.canvas.removeEventListener('mousedown', once);
	};
	gWorld.canvas.addEventListener('mousedown', once);
})();

gWorld.canvas.addEventListener('mousedown', async (in_ev) => {
	const vec2 = eventPos2RaycasterPos(in_ev);
	const vec2Scaled = vec2.clone().multiplyScalar(EV_DISTANCE_MULTIPLIER);
	let intersects = gWorld.intersectPositive(vec2);
	if (intersects.length > 0) {
		const matrix = (new THREE.Matrix3()).getNormalMatrix(intersects[0].object.matrixWorld);
		const normal = intersects[0].face.normal.clone().applyMatrix3(matrix).normalize();
		const snap = (in_err => {
			return (in_value, ...in_targets) => {
				let snapped = in_value;
				in_targets.forEach(in_target => {
					if (Math.abs(in_value - in_target) < in_err) {
						snapped = in_target;
					}
				});
				return snapped;
			};
		})(0.0001);
		XYZ.forEach(in_xyz => {
			normal[in_xyz] = snap(normal[in_xyz], -1, 0, +1);
		});
		gCube.uiSetInitPosition(intersects[0].object, normal, intersects[0].point, vec2Scaled);
	}
});

let canKnock = true;

gWorld.canvas.addEventListener('mousemove', async (in_ev) => {
	const vec2 = eventPos2RaycasterPos(in_ev);
	const vec2Scaled = vec2.clone().multiplyScalar(EV_DISTANCE_MULTIPLIER);
	if (gCube.uiIsMoving()) {
		if (gCube.uiUpdatePosition(vec2Scaled)) {
			AUDIO_ROTATION.play();
		}
		return;
	}
	if (!gCube.uiIsDragging()) {
		return;
	}
	// to avoid frequent using of THREE.Raycaster, need to adjust
	const threshold = 0.1;
	if (gCube.uiDeltaFromStartV2(vec2) < threshold) {
		return;
	}
	let intersects = gWorld.intersectPositive(vec2);
	if (intersects.length === 0) {
		return;
	}
	const RC = cRubiksCube.uiSetDeltaPositionRC;
	const result = gCube.uiNotifyDeltaPosition(intersects[0].object, intersects[0].point, vec2Scaled);
	if (result === RC.UNMOVABLE) {
		if (!canKnock) {
			return;
		} else {
			canKnock = false;
		}
		AUDIO_ERROR.play();
		await gWorld.motionKnock();
		canKnock = true;
	}
});

async function dragstop() {
	const progress = gCube.uiRelease(() => {
		gWorld.removeAnimationHook(progress);
	});
	if (progress) {
		gWorld.addAnimationHook(progress);
	}
}

gWorld.canvas.addEventListener('mouseleave', dragstop);
gWorld.canvas.addEventListener('mouseout', dragstop);
gWorld.canvas.addEventListener('mouseup', dragstop);

</script>
</body>
</html>
