<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports" : {
		"three" : "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.min.js",
		"utils" : "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/utils/BufferGeometryUtils.js",
		"basic" : "./basic-functions.js",
		"sound" : "./sound-effect.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';
import {
	getVersion,
	getParam,
	DEBUG,
	randomString,
	snapToPI,
	snapTo05PI,
	createPeriodicSin,
	createPeriodicCos,
	pseudoMessageDigest1,
	pseudoMessageDigest2,
	beep,
	isEmulated,
	throttling,
	thresholding,
	debouncing,
	nonReentrantAsync,
	arrRand,
	cEase,
	cApproximateMap,
	cApproximateSet,
	cCyclicMap,
	cCyclicValues,
	forEachCombination,
	clipArea,
	clipClearArea,
	fillRoundRect,
	XYZ,
	VEC3,
	DIRECTION,
	ndcFromEvent,
	ndcToAbs,
	getWorldVec3,
	getWorldUp,
	instanceInAncestor,
	lookAtWithoutRotation,
	safeMergeGeometry,
	makeTrapezoidGeometryParts,
	trapezoidGeometryUtil,
	roundBoxGeometry,
	roundRegularBoxGeometry,
	roundTrapezoidGeometry,
	capsuleConfigure,
	customCapsuleGeometry,
	cSphericalWorld
} from 'basic';
import * as SOUND from 'sound';

/*
	(1) Texture, MeshLambertMaterial, and BoxGeometry using cCache, which returns the same object in cache without creating.
*/

function factoryBuilder(in_constructor) {
	const group = pseudoMessageDigest2(in_constructor.toString().substring(0, 200));
	class cCache {
		static #cache = {};
		constructor(...in_args) {
			this.entity = (in_constructor)(...in_args);
		}
		static #genKey(...in_args) {
			const args = [];
			// assume in_args is primitive
			in_args.forEach(in_arg => {
				if (Number.isFinite(in_arg)) {
					args.push(Math.ceil(in_arg));
				} else {
					args.push(in_arg);
				}
			});
			return '_' + args.join('-');
		}
		static getRef(...in_args) {
			const key = cCache.#genKey(...in_args);
			if (key in cCache.#cache) {
				// console.log('cache hit ( cCache key : ' + key + ' )');
			} else {
				cCache.#cache[key] = new cCache(...in_args);
			}
			if (DEBUG) {
				(debouncing(() => {
					console.log(Object.keys(cCache.#cache).length, cCache.#cache);
				}, 500, group))(new Event('dummy'));
			}
			return cCache.#cache[key].entity;
		}
		static allClear(in_callback = null) {
			if (in_callback) {
				Object.keys(cCache.#cache).forEach(in_key => {
					(in_callback)(cCache.#cache[in_key].entity);
				});
			}
			cCache.#cache = {};
		}
	}
	/*
		*** NOTE ***
		when there are a lot of the same objects,
		and they can be shared using reference,
		cCache.getRef() returns reference.
	*/
	return {
		create : cCache.getRef,
		allClear : cCache.allClear
	};
}

const textureFactory = factoryBuilder((in_w, in_h) => {
	const gradation = 4
	// gradation (from black to white)
	let maxDepth = 255;
	let styles = [];
	for (let i = 0; i < gradation; i++) {
		let depth = Math.ceil(maxDepth / (gradation - 1) * i);
		styles[i] = 'rgb(' + depth + ',' + depth + ',' + depth + ')';
	}
	// draw and convert using toDataUR
	let canvas = document.createElement('CANVAS');
	canvas.width = in_w;
	canvas.height = in_h;
	const ctx = canvas.getContext('2d');
	let radius = gradation + 2;
	/*
		Rect           RoundRect      RoundRect

		##########     ##########     ##########
		##########     ##******##     ##******##
		##########     #********#     #**++++**#
		##########     #********#     #*++++++*#
		########## --> #********# --> #*++++++*# --> ...
		##########     #********#     #*++++++*#
		##########     #********#     #**++++**#
		##########     ##******##     ##******##
		##########     ##########     ##########
	*/
	for (let i = 0; i < gradation; i++) {
		ctx.fillStyle = styles[i];
		if (i > 0) {
			ctx[fillRoundRect](i, i, in_w - i * 2, in_h - i * 2, radius - i);
		} else {
			ctx.fillRect(i, i, in_w - i * 2, in_h - i * 2);
		}
	}
	return (new THREE.TextureLoader()).load(canvas.toDataURL());
});

const materialFactory = factoryBuilder((in_w, in_h, in_color) => {
	return new THREE.MeshLambertMaterial({
		color : in_color,
		map : textureFactory.create(in_w, in_h)
	});
});

function boxMaterials(in_x, in_y, in_z, in_colors) {
	/*
		     2    
		     |   5
		     |  /
		    ###/
		    ###
		1 --#*#-- 0
		    /##
		   /###
		  /  |
		 4   |
		     3
	*/
	return [
		materialFactory.create(in_z, in_y, in_colors[0]),
		materialFactory.create(in_y, in_z, in_colors[1]),
		materialFactory.create(in_x, in_z, in_colors[2]),
		materialFactory.create(in_x, in_z, in_colors[3]),
		materialFactory.create(in_x, in_y, in_colors[4]),
		materialFactory.create(in_x, in_y, in_colors[5])
	];
}

const boxGeometryFactory = factoryBuilder((in_x, in_y, in_z) => {
	const radian = 6;
	const geometry = roundBoxGeometry(in_x - radian * 2, in_y - radian * 2, in_z - radian * 2, radian);
	geometry.parameters = {
		x : in_x,
		y : in_y,
		z : in_z
	};
	return geometry;
});

const DARKGRAY = 0x222222;
const LIGHTGRAY = 0x555555;
const HIGHLIGHT = 0x888888;

const ORANGE = 0xFFAA00;
const RED = 0xFF0000;
const WHITE = 0xFFFFFF;
const YELLOW = 0xFFFF00;
const BLUE = 0x3333FF;
const GREEN = 0x33CC33;

const EDGECOLOR = DARKGRAY;
let INSIDECOLOR;

const SURFACEPROP = [];

if (getParam('color') === 'easy') {
	SURFACEPROP.push({V3 : DIRECTION.XP, COLOR : WHITE});
	SURFACEPROP.push({V3 : DIRECTION.XN, COLOR : WHITE});
	SURFACEPROP.push({V3 : DIRECTION.YP, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.YN, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.ZP, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.ZN, COLOR : BLUE});
	INSIDECOLOR = BLUE;
} else {
	// standard color scheme
	SURFACEPROP.push({V3 : DIRECTION.XP, COLOR : ORANGE});
	SURFACEPROP.push({V3 : DIRECTION.XN, COLOR : RED});
	SURFACEPROP.push({V3 : DIRECTION.YP, COLOR : WHITE});
	SURFACEPROP.push({V3 : DIRECTION.YN, COLOR : YELLOW});
	SURFACEPROP.push({V3 : DIRECTION.ZP, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.ZN, COLOR : GREEN});
	INSIDECOLOR = DARKGRAY;
}

const edgeMaterial = new THREE.MeshLambertMaterial({color : EDGECOLOR});

function pieceColorList(in_dimV3, in_ixV3) {
	/*
		piece ( hexahedron ) has surface x6
		|
		+- edge surface x0-3
		|	|
		|	+- orange, red, white, ...
		|
		+- inner surface x3-6
			|
			+- dark gray
	*/
	const colorList = [];
	// when in_ixV3 is on an edge, the color of SURFACEPROP is used
	SURFACEPROP.forEach(({V3, COLOR}) => {
		XYZ.forEach(in_xyz => {
			switch (V3[in_xyz]) {
			// the surface is facing the positive direction
			case +1 :
				// the position is at the positive edge
				if (in_ixV3[in_xyz] === in_dimV3[in_xyz] - 1) {
					colorList.push(COLOR);
				} else {
					colorList.push(INSIDECOLOR);
				}
				break;
			// the surface is facing the negative direction
			case -1 :
				// the position is at the negative edge
				if (in_ixV3[in_xyz] === 0) {
					colorList.push(COLOR);
				} else {
					colorList.push(INSIDECOLOR);
				}
				break;
			case 0 :
				break;
			}
		});
	});
	return colorList;
}

/*
	(2) dimension of Cube and Meshes of them
*/

class cCubeDimV3 extends THREE.Vector3 {
	get maxDim() {
		return Math.max(...this.toArray());
	}
	#sizeList(in_unitSize = 1) {
		const list = {};
		/*
			in case of 3x2x2, ...
			list.x = [in_unitSize, in_unitSize, in_unitSize]
			list.y = [in_unitSize, in_unitSize * 2]
			list.z = [in_unitSize, in_unitSize * 2]
		*/
		XYZ.forEach(in_xyz => {
			if (this[in_xyz] < this.maxDim) {
				// separate not 4=3+1 but 4=2+2
				if (this.maxDim % this[in_xyz] === 0) {
					const quotient = this.maxDim / this[in_xyz];
					list[in_xyz] = Array(this[in_xyz]).fill(in_unitSize * quotient);
				} else {
					list[in_xyz] = Array(this[in_xyz] - 1).fill(in_unitSize);
					list[in_xyz].push((this.maxDim - this[in_xyz] + 1) * in_unitSize);
				}
			} else {
				list[in_xyz] = Array(this[in_xyz]).fill(in_unitSize);
			}
		});
		return list;
	}
	#indexLoop(in_callback) {
		// first surface is at "new THREE.Vector3(0, 0, -1)"
		for (let z = 0; z < this.z; z++) {
			for (let y = 0; y < this.y; y++) {
				for (let x = 0; x < this.x; x++) {
					(in_callback)(VEC3(x, y, z));
				}
			}
		}
	}
	positionLoop(in_callback, in_unitSize, in_moveToV3 = VEC3()) {
		const sizeList = this.#sizeList(in_unitSize);
		/*
			each piece should be translated using translateV3

			before translated :

			   |
			   +---+
			   |   |
			   |   |
			   |   |
			---+---+-
			   |
			   |
			   |

			after translated :

			   |
			   |
			   |
			 +-+-+
			 | | |
			-+-+-+---
			 | | |
			 +-+-+
			   |
		*/
		const cubeCneter = this.maxDim * in_unitSize / 2;
		const translateV3 = in_moveToV3.clone().sub(VEC3(cubeCneter, cubeCneter, cubeCneter));
		this.#indexLoop(in_ixV3 => {
			const pieceSizeV3 = VEC3();
			const piecePosV3 = VEC3();
			XYZ.forEach(in_xyz => {
				const curr = in_ixV3[in_xyz];
				let start = 0;
				for (let i = 0; i < curr; i++) {
					start += sizeList[in_xyz][i];
				}
				pieceSizeV3[in_xyz] = sizeList[in_xyz][curr];
				piecePosV3[in_xyz] = start + pieceSizeV3[in_xyz] / 2;
			});
			piecePosV3.add(translateV3);
			(in_callback)(in_ixV3, piecePosV3, pieceSizeV3);
		});
	}
	isInsideCube(in_ixV3) {
		return XYZ.every(in_xyz => {
			return (0 < in_ixV3[in_xyz]) && (in_ixV3[in_xyz] < this[in_xyz] - 1);
		});
	}
}

const CUBE_SIZE = 400;

const gMeshLevelMap = ((in_cubeSize) => {
	const map = new cCyclicMap();
	const cubeDimList = [
		new cCubeDimV3(2, 2, 1),	/* =  4 */
		new cCubeDimV3(3, 2, 1),	/* =  6 */
		new cCubeDimV3(2, 2, 2),	/* =  8 */
		new cCubeDimV3(3, 2, 2),	/* = 12 */
		new cCubeDimV3(4, 2, 2),	/* = 16 */
		new cCubeDimV3(3, 3, 2),	/* = 18 */
		new cCubeDimV3(4, 3, 2),	/* = 24 */
		new cCubeDimV3(3, 3, 3),	/* = 27 */
		new cCubeDimV3(4, 4, 2),	/* = 32 */
		new cCubeDimV3(4, 3, 3),	/* = 36 */
		new cCubeDimV3(4, 4, 3),	/* = 48 */
		new cCubeDimV3(4, 4, 4)		/* = 64 */
	];
	cubeDimList.forEach(in_cubeDim => {
		const unitSize = in_cubeSize / in_cubeDim.maxDim;
		const pieces = [];
		// see cCubeDimV3 implementation
		in_cubeDim.positionLoop((in_ixV3, in_posV3, in_sizeV3) => {
			if (in_cubeDim.isInsideCube(in_ixV3)) {
				// console.log('inside', in_ixV3);
				return;
			}
			const geometry = boxGeometryFactory.create(...in_sizeV3.toArray());
			// geometry has 7 groups (sub meshes)
			const colors = pieceColorList(in_cubeDim, in_ixV3);
			const materials = boxMaterials(...in_sizeV3.toArray(), colors);
			materials.push(edgeMaterial);
			/*
				*** NOTE ***
				when you use materials (= array) for "new THREE.Mesh",
				the geometry should be devided into groups (= sub meshes).
			*/
			const piece = new THREE.Mesh(geometry, materials);
			piece.position.copy(in_posV3);
			pieces.push(piece);
		}, unitSize);
		const LEVEL1 = 27;
		let level = in_cubeDim.toArray().reduce((product, current) => {
			return product * current;
		}, 1);
		level = (level / LEVEL1).toFixed(1);
		const keyString = in_cubeDim.toArray().join('x') + ' = lv ' + level;
		map.set(keyString, pieces);
	});
	return map;
})(CUBE_SIZE);

let gMeshCurrentLevel = getParam('level');

if (gMeshCurrentLevel === false) {
	gMeshCurrentLevel = 7;
}

function getColorBySide(in_mesh, in_targetV3) {
	const matrix = (new THREE.Matrix4()).makeRotationFromQuaternion(in_mesh.quaternion);
	const invertV3 = in_targetV3.clone().applyMatrix4(matrix.invert());
	const error = 0.001;
	for (let i = 0; i < SURFACEPROP.length; i++) {
		const surfaceV3 = SURFACEPROP[i].V3;
		if (XYZ.every(in_xyz => Math.abs(invertV3[in_xyz] - surfaceV3[in_xyz]) < error)) {
			return in_mesh.material[i].color.getHex();
		}
	}
	return -1;
}

/*
	(3) Rubik's Cube related functions
*/

class cRubiksCube extends THREE.Object3D {
	static error = 0.01;
	static #axes = {
		x : VEC3(1, 0, 0),
		y : VEC3(0, 1, 0),
		z : VEC3(0, 0, 1)
	};
	static #axisProp(in_axis, in_match = true) {
		const props = Object.keys(cRubiksCube.#axes).filter(in_key => {
			const equal = cRubiksCube.#axes[in_key].equals(in_axis);
			return in_match ? equal : !equal;
		});
		if (props.length > 1) {
			return props;
		} else {
			return props[0];
		}
	}
	get #settingVal() {
		if (this.userData.currentSettingKey) {
			return this.userData.settingPerPieces[this.userData.currentSettingKey];
		} else {
			throw new Error('no currentSettingKey');
		}
	}
	set #settingKey(in_value) {
		if (!this.userData.settingPerPieces) {
			this.userData.settingPerPieces = {};
		}
		if (!this.userData.settingPerPieces[in_value]) {
			this.userData.settingPerPieces[in_value] = {};
		}
		this.userData.currentSettingKey = in_value;
	}
	removePieces() {
		const pieces = this.children.slice();
		pieces.forEach(in_piece => {
			this.remove(in_piece);
		});
		this.userData.currentSettingKey = null;
	}
	addPieces(in_pieces) {
		this.removePieces();
		const uuids = [];
		in_pieces.forEach(in_piece => {
			if (!in_piece.userData.initialPosition) {
				// all pieces should have initial position to check complete
				in_piece.userData.initialPosition = in_piece.position.clone();
			}
			uuids.push(in_piece.uuid);
			this.add(in_piece);
		});
		this.#settingKey = pseudoMessageDigest1(uuids);
		if (!this.#settingVal.initialized) {
			this.#settingVal.completeCallback = null;
			this.#settingVal.rotationCount = 0;
			this.#settingVal.shuffled = false;
			this.#settingVal.initialized = true;
		}
	}
	getScore() {
		const max = 100;
		return Math.max(Math.ceil((max - this.#settingVal.rotationCount) / 10) * 10, 0);
	}
	#isSurface(in_piece, in_surface, in_scale = 1000) {
		const far = VEC3();
		XYZ.forEach(in_xyz => {
			if (in_surface[in_xyz] === 0) {
				far[in_xyz] = in_piece.position[in_xyz];
			} else {
				far[in_xyz] = in_surface[in_xyz] * in_scale;
			}
		});
		const raycaster = new THREE.Raycaster(far, in_surface.clone().negate());
		const intersects = raycaster.intersectObjects(this.children, false);
		return (intersects[0].object === in_piece);
	}
	#isComplete() {
		return SURFACEPROP.every(in_prop => {
			let sameColor = -1;
			return this.children.every(in_piece => {
				if (!this.#isSurface(in_piece, in_prop.V3)) {
					return true;
				}
				const color = getColorBySide(in_piece, in_prop.V3);
				if (sameColor < 0) {
					sameColor = color;
					return true;
				}
				if (sameColor === color) {
					return true;
				} else {
					return false;
				}
			});
		});
	}
	#setupGroup(in_pieces) {
		const buffer = new THREE.Box3();
		const unionBox = new THREE.Box3();
		in_pieces.forEach(in_piece => {
			unionBox.union(buffer.setFromObject(in_piece));
		});
		/*
			*** NOTE ***
			property of rotation will be changed in uiUpdatePosition().
			at that time, it will be decided based on position of group.
			though position was fixed to (0, 0, 0) before,
			center of the box is used now.
		*/
		const group = new THREE.Object3D();
		this.add(group);
		group.position.copy(unionBox.getCenter(VEC3()));
		in_pieces.forEach(in_piece => {
			group.attach(in_piece);
		});
		return group;
	}
	#releaseGroup(in_group) {
		const copiedPieces = [...in_group.children];
		copiedPieces.forEach(in_piece => {
			/*
				*** NOTE ***
				"add" follows parent position.
				"attach" keeps world position.
				in addition, both of them internally call "remove" from other object.
			*/
			this.attach(in_piece);
		});
		this.remove(in_group);
	}
	makeRotationGroup(in_piece, in_axis) {
		const groups = [];
		const component = in_piece.position.dot(in_axis);
		this.children.forEach(in_child => {
			if (Math.abs(component - in_child.position.dot(in_axis)) < cRubiksCube.error) {
				groups.push(in_child);
			}
		});
		return groups;
	}
	static #rotatableAngle(in_group, in_axis) {
		const aabb = new THREE.Box3();
		const objBoxes = [];
		in_group.children.forEach(in_object => {
			const box = (new THREE.Box3()).setFromObject(in_object);
			aabb.union(box);
			objBoxes.push(box);
		});
		// 1. divide #aabb into 8 areas
		const center = aabb.getCenter(VEC3());
		const range = {};
		XYZ.forEach(in_xyz => {
			range[in_xyz] = [
				{
					min : -Infinity,
					max : center[in_xyz]
				},
				{
					min : center[in_xyz],
					max : +Infinity
				}
			];
		});
		const areaBoxes = [];
		range.x.forEach(in_x => {
			range.y.forEach(in_y => {
				range.z.forEach(in_z => {
					areaBoxes.push(new THREE.Box3(
						VEC3(in_x.min, in_y.min, in_z.min),
						VEC3(in_x.max, in_y.max, in_z.max)
					));
				});
			});
		});
		// 2. divide objBoxes into 8 areas
		const intersectBoxes = [];
		areaBoxes.forEach(in_area => {
			const boxes = [];
			objBoxes.forEach(in_box => {
				const box = in_area.clone().intersect(in_box);
				if (box.isEmpty()) {
					return;
				}
				boxes.push(box);
			});
			intersectBoxes.push(boxes);
		});
		// 3. use 4 boxes by in_axis ("x", "y", or "z")
		const target = {
			x : {arr : [0, 1, 2, 3], a1 : 'y', a2 : 'z'},
			y : {arr : [0, 1, 4, 5], a1 : 'z', a2 : 'x'},
			z : {arr : [0, 2, 4, 6], a1 : 'x', a2 : 'y'},
		}[in_axis];
		// 4. compute area
		const areas = [];
		target.arr.forEach(in_ix => {
			const boxes = intersectBoxes[in_ix];
			let area = 0;
			boxes.forEach(in_box => {
				const size = in_box.getSize(VEC3());
				area += size[target.a1] * size[target.a2];
			});
			areas.push(area);
		});
		// 5. check angle
		const error = 0.01;
		const allEqual = (...in_args) => {
			return in_args.every(in_arg => Math.abs(in_arg - in_args[0]) < error);
		};
		if (allEqual(areas[0], areas[1], areas[2], areas[3])) {
			return Math.PI / 2;
		} else {
			if (allEqual(areas[0] + areas[1], areas[2] + areas[3])) {
				return Math.PI;
			} else {
				return Math.PI * 2;
			}
		}
	}
	static #rotate(in_group, in_xyz, in_rad) {
		in_group.rotation[in_xyz] = in_rad;
	}
	#makeRotationProgress(in_group, in_xyz, in_start_rad, in_final_rad, in_callback) {
		const distance = Math.abs(in_final_rad - in_start_rad);
		const duration = distance / (Math.PI / 2) * 500;
		const ease = new cEase(in_start_rad, in_final_rad, duration);
		const progress = () => {
			const currRad = ease.currentEasingIn();
			cRubiksCube.#rotate(in_group, in_xyz, currRad);
			let ratio = Math.abs(currRad - in_start_rad) / distance;
			if (currRad === in_final_rad) {
				this.#releaseGroup(in_group);
				this.#settingVal.shuffled = true;
				// this progress function should be stopped in callback
				ratio = 1.0;
			}
			(in_callback)(ratio);
		};
		return progress;
	}
	makeRandomRotationProgress(in_callback) {
		let axis;
		let pieces;
		let maxLoopCount = 100;
		while (true) {
			if (--maxLoopCount === 0) {
				throw new Error('maxLoopCount'); 
			}
			const _piece = (this.children)[arrRand]();
			axis = (Object.values(cRubiksCube.#axes))[arrRand]();
			pieces = this.makeRotationGroup(_piece, axis);
			if (pieces.length < this.children.length) {
				break;
			}
		}
		const group = this.#setupGroup(pieces);
		const xyz = cRubiksCube.#axisProp(axis);
		return this.#makeRotationProgress(group, xyz, 0, Math.PI / 2, in_callback);
	}
	registerCompleteCallback(in_callback) {
		this.#settingVal.completeCallback = in_callback;
	}
	removeCompleteCallback() {
		this.#settingVal.completeCallback = null;
	}
	static #getRotationAxis(in_surfaceV3, in_directionV3) {
		/*
			{surface : new THREE.Vector3(+1, 0, 0), direction : new THREE.Vector3(0, +1, 0), expected : new THREE.Vector3(0, 0, +1)},
			{surface : new THREE.Vector3(+1, 0, 0), direction : new THREE.Vector3(0, -1, 0), expected : new THREE.Vector3(0, 0, -1)},
			{surface : new THREE.Vector3(-1, 0, 0), direction : new THREE.Vector3(0, +1, 0), expected : new THREE.Vector3(0, 0, -1)},
			{surface : new THREE.Vector3(-1, 0, 0), direction : new THREE.Vector3(0, -1, 0), expected : new THREE.Vector3(0, 0, +1)},
			...
		*/
		const rotationAxis = VEC3();
		rotationAxis.crossVectors(in_surfaceV3, in_directionV3);
		return rotationAxis;
	}
	static #detectMovingDirection(in_dstV3, in_srcV3, in_surfaceV3) {
		const vec3 = VEC3().subVectors(in_dstV3, in_srcV3);
		const axes = [
			VEC3(+1, 0, 0),
			VEC3(-1, 0, 0),
			VEC3(0, +1, 0),
			VEC3(0, -1, 0),
			VEC3(0, 0, +1),
			VEC3(0, 0, -1)
		];
		const ret = {
			minAngle : Infinity,
			directionAxis : null,
			rotationAxis : null
		};
		axes.forEach(in_axis => {
			if (in_axis.dot(in_surfaceV3) !== 0) {
				// in_axis which is not the same as in_surfaceV3 will be taken for rotation
				return;
			}
			const angle = vec3.angleTo(in_axis);
			if (angle < ret.minAngle) {
				ret.minAngle = angle;
				ret.directionAxis = in_axis;
				// rotationAxis may have negative value as component
				ret.rotationAxis = cRubiksCube.#getRotationAxis(in_surfaceV3, in_axis);
			}
		});
		return ret;
	}
	static #uiStates  = {
		DISABLED : Symbol(),
		ENABLED : Symbol(),
		DRAGGING : Symbol(),
		MOVING : Symbol(),
		MOMENTUM : Symbol()
	}
	/*
		ENABLED <-------------------+
		|                           |
		+-[disable]-----+           |
		|               |           |
		|   DISABLED <--+           |
		|   |                       |
		|   +-[enable]--------------+
		|                           |
		+-[drag]--------+           |
		                |           |
		    DRAGGING <--+           |
		    |                       |
		    +-[release]-------------+
		    |                       |
		    +-[movable]-----+       |
		                    |       |
		        MOVING <----+       |
		        |                   |
		        +-[release]-----+   |
		                        |   |
		            MOMENTUM <--+   |
		            |               |
		            +-[stop]--------+
	*/
	static #uiTransitions = {
		[cRubiksCube.#uiStates.DISABLED]: {
			enable : cRubiksCube.#uiStates.ENABLED
		},
		[cRubiksCube.#uiStates.ENABLED]: {
			disable : cRubiksCube.#uiStates.DISABLED,
			drag : cRubiksCube.#uiStates.DRAGGING
		},
		[cRubiksCube.#uiStates.DRAGGING]: {
			release : cRubiksCube.#uiStates.ENABLED,
			movable : cRubiksCube.#uiStates.MOVING
		},
		[cRubiksCube.#uiStates.MOVING]: {
			release : cRubiksCube.#uiStates.MOMENTUM
		},
		[cRubiksCube.#uiStates.MOMENTUM]: {
			stop : cRubiksCube.#uiStates.ENABLED
		}
	};
	#uiSession = {
		state : cRubiksCube.#uiStates.ENABLED,
		ctx : {}
	};
	#transition(in_action) {
		const newState = cRubiksCube.#uiTransitions[this.#uiSession.state]?.[in_action];
		if (newState) {
			this.#uiSession.state = newState;
		} else {
			throw new Error('invalid transition : ' + in_action);
		}
	}
	uiEnable() {
		if (this.#uiSession.state !== cRubiksCube.#uiStates.DISABLED) {
			console.log('state is not DISABLED');
			return;
		}
		this.#transition('enable');
	}
	uiDisable() {
		if (this.#uiSession.state !== cRubiksCube.#uiStates.ENABLED) {
			console.log('state is not ENABLED');
			return;
		}
		this.#transition('disable');
	}
	#uiInitSession() {
		if (this.#uiSession.ctx.roGroup) {
			this.#releaseGroup(this.#uiSession.ctx.roGroup);
		}
		this.#uiSession.ctx = {};
	}
	uiSetInitPosition(in_piece, in_surfaceV3, in_posV3, in_posV2) {
		// in_posV3 : intersection with a in_piece
		// in_posV2 : abs value generated from NDC (Normalized Device Coordinates)
		if (this.#uiSession.state !== cRubiksCube.#uiStates.ENABLED) {
			console.log('state is not ENABLED');
			return;
		}
		this.#uiSession.ctx = {
			piece : in_piece,
			initPosV3 : in_posV3,
			initPosV2 : in_posV2,
			surfaceV3 : in_surfaceV3,
			roGroup : null,
			roUnitAngle : Math.PI,
			roRadian : 0,
			roAxisDir : 0,
			roAxisXYZ : null,
			initDirV2 : null
		};
		this.#transition('drag');
	}
	uiIsDragging() {
		return (this.#uiSession.state === cRubiksCube.#uiStates.DRAGGING);
	}
	uiIsMoving() {
		return (this.#uiSession.state === cRubiksCube.#uiStates.MOVING);
	}
	static uiSetDeltaPositionRC = {
		NOOP : Symbol(),
		// as delta is not enough, need to call uiNotifyDeltaPosition again
		NOTENOUGH : Symbol(),
		// though delta is enough, can't make group
		UNMOVABLE : Symbol(),
		// as delta is enough, can call uiUpdatePosition
		MOVABLE : Symbol()
	};
	uiNotifyDeltaPosition(in_piece, in_posV3, in_posV2) {
		// in_posV3 : intersection with a in_piece
		// in_posV2 : abs value generated from NDC (Normalized Device Coordinates)
		const RC = cRubiksCube.uiSetDeltaPositionRC;
		if (this.#uiSession.state !== cRubiksCube.#uiStates.DRAGGING) {
			console.log('state is not DRAGGING');
			return RC.NOOP;
		}
		const ctx = this.#uiSession.ctx;
		const moving = cRubiksCube.#detectMovingDirection(in_posV3, ctx.initPosV3, ctx.surfaceV3);
		const angle22_5 = Math.PI / 8;
		if (moving.minAngle > angle22_5) {
			return RC.NOTENOUGH;
		}
		// component for makeRotationGroup should be +1
		const axis = moving.rotationAxis.clone().multiply(moving.rotationAxis);
		const pieces = this.makeRotationGroup(ctx.piece, axis);
		if (pieces.length < this.children.length) {
			this.#transition('movable');
			ctx.roGroup = this.#setupGroup(pieces);
			// use Vector3(1, 1, 1) to extruct +1 or -1
			ctx.roAxisDir = moving.rotationAxis.dot(VEC3(1, 1, 1));
			ctx.roAxisXYZ = cRubiksCube.#axisProp(axis);
			ctx.roUnitAngle = cRubiksCube.#rotatableAngle(ctx.roGroup, ctx.roAxisXYZ);
			ctx.initDirV2 = in_posV2.clone().sub(ctx.initPosV2);
			return RC.MOVABLE;
		} else {
			return RC.UNMOVABLE;
		}
	}
	uiUpdatePosition(in_posV2) {
		// in_posV2 : abs value generated from NDC (Normalized Device Coordinates)
		if (this.#uiSession.state !== cRubiksCube.#uiStates.MOVING) {
			return;
		}
		const ctx = this.#uiSession.ctx;
		const currentDirV2 = in_posV2.clone().sub(ctx.initPosV2);
		let speedupWhen180 = ctx.roUnitAngle / (Math.PI / 2);
		let rad = in_posV2.distanceTo(ctx.initPosV2) * ctx.roAxisDir * speedupWhen180;
		if (ctx.initDirV2.dot(currentDirV2) > 0) {
			// currentDirV2 & initDirV2 --> SAME direction
			rad *= +1;
		} else {
			// currentDirV2 & initDirV2 --> OPPOSITE direction
			const thresholdToStopWarp = Math.PI / 8;
			if (Math.abs(ctx.roRadian + rad) < thresholdToStopWarp) {
				rad *= -1;
			}
		}
		/*
			*** NOTE ***
			if using rotateOnAxis() several times, small errors will be expanded.
			if making group every time too, the same issue will happen.
		*/
		cRubiksCube.#rotate(ctx.roGroup, ctx.roAxisXYZ, rad);
		let snap;
		if (ctx.roUnitAngle === Math.PI) {
			snap = snapToPI;
		} else {
			snap = snapTo05PI;
		}
		const overTheTop = ((snap)(rad) != (snap)(ctx.roRadian));
		ctx.roRadian = rad;
		// if true, caller may show some effects.
		return overTheTop;
	}
	uiRelease(in_ending_callback) {
		if (this.#uiSession.state === cRubiksCube.#uiStates.DRAGGING) {
			this.#uiInitSession();
			this.#transition('release');
			return null;
		}
		if (this.#uiSession.state !== cRubiksCube.#uiStates.MOVING) {
			return null;
		}
		this.#transition('release');
		const ctx = this.#uiSession.ctx;
		const startRad = ctx.roRadian;
		let snap;
		if (ctx.roUnitAngle === Math.PI) {
			snap = snapToPI;
		} else {
			snap = snapTo05PI;
		}
		const finalRad = (snap)(ctx.roRadian);
		return this.#makeRotationProgress(ctx.roGroup, ctx.roAxisXYZ, startRad, finalRad, in_ratio => {
			if (in_ratio < 1) {
				return;
			}
			this.#uiInitSession();
			this.#transition('stop');
			(in_ending_callback)();
			if (!this.#settingVal.shuffled) {
				// when without shuffled, do nothing
				return;
			}
			this.#settingVal.rotationCount++;
			if (this.#settingVal.completeCallback && this.#isComplete()) {
				(this.#settingVal.completeCallback)(this.#settingVal.rotationCount);
			}
		});
	}
}

class cExRubiksCube extends cRubiksCube {
	static #staticTest = {mode : false, obj : null};
	static unitTest(in_method, in_testObj = {}, ...in_args) {
		cExRubiksCube.#staticTest.mode = true;
		cExRubiksCube.#staticTest.obj = in_testObj
		const ret = eval('cExRubiksCube.' + in_method + '(...in_args)');
		console.log(ret);
		throw new Error('end of unitTest'); 
	}
	#instanceTest = {mode : false, obj : null};
	unitTest(in_method, in_testObj = {}, ...in_args) {
		this.#instanceTest.mode = true;
		this.#instanceTest.obj = in_testObj
		const ret = eval('this.' + in_method + '(...in_args)');
		console.log(ret);
		throw new Error('unitTest'); 
	}
	static #orderBy(...in_args) {
		for (let i = 0; i < in_args.length - 1 ; i++) {
			if (in_args[i + 1] - in_args[i] < cRubiksCube.error) {
				return false;
			}
		}
		return true;
	}
	#splitGroupByAxis_1_groupBySameScalar(io_scalarMap, in_axis) {
		this.children.forEach(in_piece => {
			const component = in_piece.position.dot(in_axis);
			const reference = io_scalarMap.get(component);
			if (reference) {
				// there already exists almost the same component
				reference.pieces.push(in_piece);
				reference.tmpBox.union(new THREE.Box3().setFromObject(in_piece));
			} else {
				io_scalarMap.set(component, {
					pieces : [in_piece],
					tmpBox : (new THREE.Box3()).setFromObject(in_piece)
				});
			}
		});
	}
	static #splitGroupByAxis_2_calculateEdges(io_scalarMap, in_axis) {
		for (const [scalar, info] of io_scalarMap.entries()) {
			const length = (VEC3().subVectors(info.tmpBox.max, info.tmpBox.min)).dot(in_axis);
			info.edgeL = scalar - length / 2;
			info.edgeR = scalar + length / 2;
			delete info.tmpBox;
		}
	}
	static #splitGroupByAxis_3_makeCandidatesBorder(in_scalarMap) {
		const candidateBorderSet = new cApproximateSet(cRubiksCube.error);
		for (const info of in_scalarMap.values()) {
			candidateBorderSet.add(info.edgeL);
			candidateBorderSet.add(info.edgeR);
		}
		const candidateBorder = Array.from(candidateBorderSet);
		candidateBorder.sort((a, b) => a - b);
		candidateBorder.shift();
		candidateBorder.pop();
		return candidateBorder;
	}
	static #splitGroupByAxis_4_makeActualBorder(in_scalarMap, in_candidateBorder) {
		const actualBorder = [];
		for (let i = 0; i < in_candidateBorder.length; i++) {
			let isBorder = true;
			for (const info of in_scalarMap.values()) {
				if (cExRubiksCube.#orderBy(info.edgeL, in_candidateBorder[i], info.edgeR)) {
					isBorder = false;
					break;
				}
			}
			if (isBorder) {
				actualBorder.push(in_candidateBorder[i]);
			}
		}
		return actualBorder;
	}
	static #splitGroupByAxis_5_makeActualBorder(in_scalarMap, in_actualBorder) {
		const groups = [];
		let next = 0;
		in_actualBorder.push(Infinity);
		in_actualBorder.forEach(border => {
			const pieces = [];
			for (let i = next; i < in_scalarMap.size; i++) {
				const ascendingScalar = in_scalarMap.sortedKey(i);
				if (ascendingScalar < border) {
					const info = in_scalarMap.get(ascendingScalar);
					pieces.push(...info.pieces);
				} else {
					next = i;
					break;
				}
			}
			groups.push(pieces);
		});
		return groups;
	}
	#splitGroupByAxis(in_axis) {
		/*
			step #1 : scalarMap is the group of position based on in_axis. for example ...

				+---+---+---+---+---+---+
				| x | x | x | x | x | x |
				+---+---+---+---+---+---+
				| x |   x   | x | x | x |
				+---+---+---+---+---+---+
				| x |       x       | x |
				+---+---+---+---+---+---+

				--x---x-x-x-x-x---x---x--> : in_axis

				 3.00, {tmpBox, piece + piece + piece}
				 7.00, {tmpBox, piece}
				 9.00, {tmpBox, piece}
				11.00, {tmpBox, piece}
				13.00, {tmpBox, piece}
				15.00, {tmpBox, piece + piece}
				19.00, {tmpBox, piece + piece}
				23.00, {tmpBox, piece + piece + piece}

			step #2 : calculate edges for the bounding box. for example ...

				 3.00, {edgeL =  1.00, edgeR =  5.00, piece + piece + piece}
				 7.00, {edgeL =  5.00, edgeR =  9.00, piece}
				 9.00, {edgeL =  5.00, edgeR = 13.00, piece}
				11.00, {edgeL =  9.00, edgeR = 13.00, piece}
				13.00, {edgeL =  5.00, edgeR = 21.00, piece}
				15.00, {edgeL = 13.00, edgeR = 17.00, piece + piece}
				19.00, {edgeL = 17.00, edgeR = 21.00, piece + piece}
				23.00, {edgeL = 21.00, edgeR = 25.00, piece + piece + piece}
		*/
		let scalarMap = new cApproximateMap(cRubiksCube.error);
		if (this.#instanceTest.mode) {
			scalarMap = this.#instanceTest.obj;
		} else {
			this.#splitGroupByAxis_1_groupBySameScalar(scalarMap, in_axis);
			cExRubiksCube.#splitGroupByAxis_2_calculateEdges(scalarMap, in_axis);
		}
		/*
			step #3 : make candidates of border which decides group
		*/
		const candidateBorder = cExRubiksCube.#splitGroupByAxis_3_makeCandidatesBorder(scalarMap);
		if (this.#instanceTest.mode) {
			/*
				*** NOTE ***
				to display a reference using "console.log", you should use a copy of the reference.
				without it, the entity may appear updated when displayed because the console holds a reference,
				and any subsequent changes to the object will be reflected in the console.
			*/
			console.log('#3', [...candidateBorder]);
		}
		/*
			step #4 : check if candidates is actual border

			    v   v
			+---+---+---+
			| x | x | x |
			+---+---+---+ : border = 2
			| x | x | x |
			+---+---+---+

			        v
			+---+---+---+
			| x | x | x |
			+---+---+---+ : border = 1
			|   x   | x |
			+---+---+---+

			+---+---+---+
			| x |   x   |
			+---+---+---+ : border = 0
			|   x   | x |
			+---+---+---+
		*/
		const actualBorder = cExRubiksCube.#splitGroupByAxis_4_makeActualBorder(scalarMap, candidateBorder);
		if (this.#instanceTest.mode) {
			console.log('#4', [...actualBorder]);
		}
		/*
			step #5 : finally, make group which will move together
		*/
		const groups = cExRubiksCube.#splitGroupByAxis_5_makeActualBorder(scalarMap, actualBorder)
		if (this.#instanceTest.mode) {
			console.log('#5', [...groups]);
		}
		return groups;
	}
	makeRotationGroup(in_piece, in_axis) {
		const groups = this.#splitGroupByAxis(in_axis);
		for (let i = 0; i < groups.length; i++) {
			if (groups[i].includes(in_piece)) {
				return groups[i];
			}
		}
		return null;
	}
}

function test_makeGroupOnAxis(in_arr) {
	const scalarMap = new cApproximateMap(cRubiksCube.error);
	in_arr.forEach(in_elem => {
		in_elem[0] += Math.random() / 10000;
		in_elem[1].edgeL += Math.random() / 10000;
		in_elem[1].edgeR += Math.random() / 10000;
		scalarMap.set(in_elem[0], in_elem[1]);
	});
	(new cExRubiksCube()).unitTest('#splitGroupByAxis', scalarMap);
}

/*
	--x-x---x-x-->

	+---+---+---+
	| x |   x   |
	+---+---+---+
	|   x   | x |
	+---+---+---+

test_makeGroupOnAxis([
	[ 3.0000, {edgeL : 1.0000, edgeR :  5.0000, pieces : ['a']}],
	[ 5.0000, {edgeL : 1.0000, edgeR :  9.0000, pieces : ['b']}],
	[ 9.0000, {edgeL : 5.0000, edgeR : 13.0000, pieces : ['c']}],
	[11.0000, {edgeL : 9.0000, edgeR : 13.0000, pieces : ['d']}]
]);

*/

/*
	--x-x-x-x-x-->

	+---+---+---+
	| x | x | x |
	+---+---+---+
	| x |   x   |
	+---+---+---+
	|   x   | x |
	+---+---+---+

test_makeGroupOnAxis([
	[ 3.0000, {edgeL : 1.0000, edgeR :  5.0000, pieces : ['a','b']}],
	[ 5.0000, {edgeL : 1.0000, edgeR :  9.0000, pieces : ['c']}],
	[ 7.0000, {edgeL : 5.0000, edgeR :  9.0000, pieces : ['d']}],
	[ 9.0000, {edgeL : 5.0000, edgeR : 13.0000, pieces : ['e']}],
	[11.0000, {edgeL : 9.0000, edgeR : 13.0000, pieces : ['f','g']}]
]);

*/

/*
	--x---x-x-x-x-x---x---x-->

	+---+---+---+---+---+---+
	| x | x | x | x | x | x |
	+---+---+---+---+---+---+
	| x |   x   | x | x | x |
	+---+---+---+---+---+---+
	| x |       x       | x |
	+---+---+---+---+---+---+

test_makeGroupOnAxis([
	[ 3.0000, {edgeL :  1.0000, edgeR :  5.0000, pieces : ['a','b','c']}],
	[ 7.0000, {edgeL :  5.0000, edgeR :  9.0000, pieces : ['d']}],
	[ 9.0000, {edgeL :  5.0000, edgeR : 13.0000, pieces : ['f']}],
	[11.0000, {edgeL :  9.0000, edgeR : 13.0000, pieces : ['g']}],
	[13.0000, {edgeL :  5.0000, edgeR : 21.0000, pieces : ['e']}],
	[15.0000, {edgeL : 13.0000, edgeR : 17.0000, pieces : ['h','i']}],
	[19.0000, {edgeL : 17.0000, edgeR : 21.0000, pieces : ['j','k']}],
	[23.0000, {edgeL : 21.0000, edgeR : 25.0000, pieces : ['l','m','n']}]
]);

*/

/*
	(4) ui & dom setting

	gWorld (cSphericalWorld)
	|
	+-- gCube (cExRubiksCube)
		|
		+-- meshes <--- gMeshLevelMap
*/

const WORLD_RADIUS = CUBE_SIZE * 10;
const WORLD_INIT_ZOOM = WORLD_RADIUS / 3;

const gWorld = new cSphericalWorld(WORLD_RADIUS);

const gCube = new cExRubiksCube();

gWorld.add(gCube);

gWorld.moveView(2.5, 0.5);
gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);

/*
	*** NOTE ***
	when you use AxesHelper,
	// gWorld.add(new THREE.AxesHelper(WORLD_RADIUS));
	gWorld.setZoom() can not work well.
*/

class cWarpLine {
	static #speed = 10;
	static #gradation = 10;
	constructor(in_canvas) {
		const w = in_canvas.width;
		const h = in_canvas.height;
		this.ctx = in_canvas.getContext('2d');
		this.box = new THREE.Box2(
			new THREE.Vector2(0, 0),
			new THREE.Vector2(w, h)
		);
		this.from = new THREE.Vector2(w / 2, h / 2);
		this.#reset();
	}
	#reset() {
		const angle = Math.random() * Math.PI * 2;
		this.direction = new THREE.Vector2(Math.cos(angle), Math.sin(angle));
		this.speed = Math.random() * cWarpLine.#speed + 5;
		this.length = 0;
	}
	#curVec(in_scalar) {
		return this.from.clone().add(this.direction.clone().multiplyScalar(in_scalar));
	}
	#drawGrayLine(in_from, in_to, in_grayScale) {
		const gray = (in_grayScale << 16) | (in_grayScale << 8) | in_grayScale;
		this.ctx.strokeStyle = '#' + gray.toString(16).padStart(6, '0');
		this.ctx.beginPath();
		this.ctx.moveTo(in_from.x, in_from.y);
		this.ctx.lineTo(in_to.x, in_to.y);
		this.ctx.stroke();
	}
	update() {
		this.length += this.speed;
		const to = this.#curVec(this.length);
		if (this.box.containsPoint(to)) {
			const notch = this.length / cWarpLine.#gradation;
			for (let i = 0; i < cWarpLine.#gradation; i++) {
				this.#drawGrayLine(
					this.#curVec(notch * i),
					this.#curVec(notch * (i + 1)),
					255 / cWarpLine.#gradation * (i + 1)
				);
			}
		} else {
			/*
				*** NOTE ***
				even if overwritung using black,
				this.#drawGrayLine(this.from, to, 0x00);
				smudge of white line will remain.
			*/
			this.#reset();
		}
	}
}

function warpViewProgress(in_canvas, in_lineCount) {
	const warpLines = [];
	for (let i = 0; i < in_lineCount; i++) {
		warpLines.push(new cWarpLine(in_canvas));
	}
	return () => {
		warpLines.forEach(in_line => {
			in_line.update();
		});
	}
}

function complete() {
	const progress = warpViewProgress(gBackgroundCanvas, 50);
	gWorld.addAnimationHook(progress);
	const duration = 2000;
	gWorld.motionZoom2(WORLD_RADIUS * 1.5, duration * 0.9);
	window.setTimeout(() => {
		gWorld.removeAnimationHook(progress);
		gCube.removeCompleteCallback();
		const dialog = document.createElement('div');
		Object.assign(dialog.style, {
			width : 'auto',
			height : 'auto',
			background : 'black',
			borderRadius : '1em',
			padding : '1.5em'
		});
		([
			'<div>Congratulation !!</div>',
			'<div>( Your score is : ' + gCube.getScore() + ' )</div>',
			'<div>Thanks to your wisdom, peace in the universe has been preserved.</div>',
			'<div>Click to go next stage.</div>',
		]).forEach(in_fragment => {
			dialog.innerHTML += in_fragment;
		});
		setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white');
		startDialog(dialog, () => {
			drawCosmicView(gBackgroundCanvas, 400, 50);
			gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);
		});
		nextLevel(false);
	}, duration);
}

/*
	*** NOTE ***
	in Safari, using await to get audio will cause the process to fail.
	I'm not sure of the reason, but top-level await might be the cause.
	this time use then() to avoid the issue.
*/

let SE_BEEP = beep(2000);
let SE_DUMMY = beep(10);
let SE_MOVED = SE_BEEP;
let SE_ERROR = SE_BEEP;

SOUND.MOVED.then(in_decompress => {
	SE_MOVED = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

SOUND.ERROR.then(in_decompress => {
	SE_ERROR = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

function shuffle(in_count) {
	const randomRotation = (in_remaining_count) => {
		let overTheTop = false;
		const callback = (in_ratio) => {
			if ((in_ratio > 0.4) && !overTheTop) {
				SE_MOVED.play();
				overTheTop = true;
			}
			if (in_ratio < 1) {
				return;
			}
			gWorld.removeAnimationHook(progress);
			if (in_remaining_count > 1) {
				(randomRotation)(in_remaining_count - 1);
			} else {
				gWorld.stopRotation();
				gCube.uiEnable();
			}
		};
		const progress = gCube.makeRandomRotationProgress(callback);
		gWorld.addAnimationHook(progress);
	};
	gCube.registerCompleteCallback(complete);
	gCube.uiDisable();
	gWorld.startRotation(VEC3().random().multiplyScalar(0.05));
	(randomRotation)(in_count);
}

function setTransition(in_elem, in_shorthand, in_val1, in_val2) {
	const components = in_shorthand.split(/\s+/);
	in_elem.style.transition = in_shorthand;
	in_elem.style[components[0]] = in_val1;
	window.setTimeout(() => {
		/*
			*** NOTE ***
			to fire the transition function,
			the final style should be set in the next event loop.
		*/
		in_elem.style[components[0]] = in_val2;
	}, 0);
}

function startDialog(in_element, in_callback = null) {
	const maxInt = 2 ** 31 - 1;
	const background = document.createElement('div');
	Object.assign(background.style, {
		position : 'fixed',
		left : '0px',
		top : '0px',
		width : '100%',
		height : '100%',
		zIndex : maxInt
	});
	background.appendChild(in_element);
	Object.assign(in_element.style, {
		position : 'absolute',
		left : '50%',
		top : '50%',
		transform : 'translate(-50%, -50%)'
	});
	document.body.appendChild(background);
	const closeDialog = () => {
		document.body.removeChild(background);
		if (in_callback) {
			(in_callback)();
		}
	};
	background.addEventListener('mousedown', closeDialog);
	background.addEventListener('touchstart', closeDialog);
}

function shuffle3() {
	shuffle(3);
}

function shuffle10() {
	shuffle(10);
}

function uiHelp() {
	const url = {
		ver : './version.txt',
		im1 : 'https://pj-corridor.net/images/cube-2-03.png',
		im2 : 'https://pj-corridor.net/images/diamond-2-4.png',
		im3 : 'https://pj-corridor.net/images/cube-6-03.png',
		im4 : 'https://pj-corridor.net/images/diamond-6-4.png',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div>';
	[url.im1, url.im2, url.im3, url.im4].forEach(in_img => {
		dialog.innerHTML += '<img width="100" src="' + in_img + '" />';
	});
	dialog.innerHTML += '</div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getVersion(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.log(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Rights</dt>',
		'<dd>This software is based on MIT License.</dd>',
		'<dd>The code can be freely modified and reused.</dd>',
		'<dd>For full license details, please refer to :</dd>',
		'<dd>https://opensource.org/licenses/MIT</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white')
	startDialog(dialog);
}

const ID_PREV_LEVEL = randomString();
const ID_NEXT_LEVEL = randomString();

function updateLevelText() {
	const prev = gMeshLevelMap.prevItemByOrder(gMeshCurrentLevel);
	const next = gMeshLevelMap.nextItemByOrder(gMeshCurrentLevel);
	document.getElementById(ID_PREV_LEVEL).innerText = prev.k;
	document.getElementById(ID_NEXT_LEVEL).innerText = next.k;
}

async function changeLevel(in_delta) {
	const color = 0x000000;
	await gWorld.motionFog(color, 0, 100);
	gMeshCurrentLevel = (gMeshCurrentLevel + in_delta + gMeshLevelMap.size) % gMeshLevelMap.size;
	gCube.removePieces();
	const current = gMeshLevelMap.currItemByOrder(gMeshCurrentLevel);
	gCube.addPieces(current.v);
	await gWorld.motionFog(color, 100, 0);
	updateLevelText();
}

function prevLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	changeLevel(-1);
}

function nextLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	changeLevel(+1);
}

(in_settings => {
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	in_settings.forEach(in_setting => {
		let button = document.createElement('button');
		if (in_setting.id) {
			button.id = in_setting.id;
		}
		if (in_setting.text) {
			button.innerText = in_setting.text;
		}
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})([
	{
		id : ID_PREV_LEVEL,
		text : '(Prev)',
		func : prevLevel
	},
	{
		id : ID_NEXT_LEVEL,
		text : '(Next)',
		func : nextLevel
	},
	{
		text : 'shuffle x3',
		func : shuffle3
	},
	{
		text : 'shuffle x10',
		func : shuffle10
	},
	{
		text : 'help',
		func : uiHelp
	},
	{
		text : 'rights',
		func : uiRights
	}
]);

changeLevel(0);

function hex2rgb(in_hex) {
	const mask = 0xFF;
	const r = (in_hex >> 16) & mask;
	const g = (in_hex >> 8) & mask;
	const b = in_hex & mask;
	return [r, g, b];
}

function drawCosmicView(in_canvas, in_stars, in_nebulae_patterns, in_color = 0x000064) {
	const ctx = in_canvas.getContext('2d');
	const w = in_canvas.width;
	const h = in_canvas.height;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	for (let i = 0; i < in_nebulae_patterns; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 100 + 50;
		const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
		const rgb = hex2rgb(in_color);
		gradient.addColorStop(0, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0.5)');
		gradient.addColorStop(1, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0)');
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = gradient;
		ctx.fill();
	}
	for (let i = 0; i < in_stars; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 1;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = 'white';
		ctx.fill();
	}
}

const gBackgroundCanvas = document.createElement('CANVAS');

Object.assign(gBackgroundCanvas.style, {
	position : 'absolute',
	left : 0,
	top : 0,
	zIndex : -1
});

document.addEventListener('DOMContentLoaded', (() => {
	let resizeWorld = in_ev => {
		gWorld.resize(
			window.innerWidth,
			window.innerHeight);
		gBackgroundCanvas.width = window.innerWidth;
		gBackgroundCanvas.height = window.innerHeight;
		drawCosmicView(gBackgroundCanvas, 400, 50);
	};
	window.addEventListener('resize', debouncing(resizeWorld, 300));
	window.dispatchEvent(new Event('resize'));
	if (!document.body) {
		document.documentElement.appendChild(document.createElement('BODY'));
	}
	Object.assign(document.body.style, {
		margin : '0',
		overflow : 'hidden'
	});
	document.body.appendChild(gWorld.canvas);
	document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

/*
	(5) event handlers
*/

const knock = nonReentrantAsync(async () => {
	SE_ERROR.play();
	await gWorld.motionKnock();
});

const notifyDelta = (() => {
	const RC = cRubiksCube.uiSetDeltaPositionRC;
	return in_ndc => {
		const intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			return;
		}
		const result = gCube.uiNotifyDeltaPosition(intersects[0].object, intersects[0].point, ndcToAbs(in_ndc));
		if (result === RC.UNMOVABLE) {
			knock();
		}
	}
})();

function colorUtil(in_target, in_index, in_callback) {
	const colors = [];
	for (let i = 0; i < in_target.material.length; i++) {
		const hex = in_target.material[i].color.getHex();
		if ((in_index < 0) || (i === in_index)) {
			colors.push(in_callback(hex));
		} else {
			colors.push(hex);
		}
	}
	const setting = in_target.geometry.parameters;
	const materials = boxMaterials(setting.x, setting.y, setting.z, colors);
	materials.push(edgeMaterial);
	/*
		*** NOTE ***
		materials created by boxMaterials are cached using cCache.
		therefore, you don't need to worry about memory leaks without calling dispose().
	*/
	in_target.material = materials;
}

function highlight(in_target, in_index, in_alpha) {
	colorUtil(in_target, in_index, in_currHex => {
		return (new THREE.Color(in_currHex)).lerp(new THREE.Color(0xFFFFFF), in_alpha).getHex();
	});
}

function highlightAll(in_target, in_alpha) {
	highlight(in_target, -1, in_alpha);
}

function changeColor(in_target, in_index, in_nextHex) {
	colorUtil(in_target, in_index, in_currHex => {
		return in_nextHex;
	});
}

function changeColorAll(in_target, in_nextHex) {
	changeColor(in_target, -1, in_nextHex);
}

const setFocus = (() => {
	const c = {
		prev : null,
		materials : []
	};
	return in_ndc => {
		let intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			if (c.prev) {
				c.prev.target.material = c.materials;
				/*
					*** NOTE ***
					as materials made by boxMaterials will be cached using cCache,
					you don't need to call dispose() when mouseout.
				*/
				c.materials = [];
				c.prev = null;
			}
			return;
		}
		const currTarget = intersects[0].object;
		// assume that each face is composed of two faces
		const currSurface = Math.floor(intersects[0].faceIndex / 2);
		if (currSurface >= SURFACEPROP.length) {
			// faces included in the edge
			return;
		}
		if (c.prev) {
			if ((c.prev.target === currTarget) && (c.prev.surface === currSurface)) {
				return;
			} else {
				c.prev.target.material = c.materials;
			}
		}
		c.prev = {
			target : currTarget,
			surface : currSurface
		};
		c.materials = currTarget.material;
		const alpha = 0.3;
		highlight(currTarget, currSurface, alpha);
	}
})();

function decideSurface(in_intersects) {
	// as face.normal is local coordination of the object, need to convert
	const matrix = (new THREE.Matrix3()).getNormalMatrix(in_intersects[0].object.matrixWorld);
	const surface = in_intersects[0].face.normal.clone().applyMatrix3(matrix).normalize();
	const snap = (in_err => {
		return (in_value, ...in_targets) => {
			let snapped = in_value;
			in_targets.forEach(in_target => {
				if (Math.abs(in_value - in_target) < in_err) {
					snapped = in_target;
				}
			});
			return snapped;
		};
	})(0.0001);
	XYZ.forEach(in_xyz => {
		surface[in_xyz] = snap(surface[in_xyz], -1, 0, +1);
	});
	return surface;
}

function choose(in_ev) {
	const ndc = ndcFromEvent(in_ev);
	let intersects = gWorld.intersectPositive(ndc);
	if (intersects.length === 0) {
		return;
	}
	knock();
}

const gHandlers = (() => {
	const c = {
		x : -1,
		y : -1,
		once : false
	};
	const start = in_ev => {
		if (!c.once) {
			/*
				*** NOTE ***
				Safari may restrict sound without user interaction.
				because of this, the sound does not work without this code.
			*/
			SE_DUMMY.play();
			c.once = true;
		}
		const ndc = ndcFromEvent(in_ev);
		const intersects = gWorld.intersectPositive(ndc);
		if (intersects.length === 0) {
			return;
		}
		c.x = in_ev.clientX;
		c.y = in_ev.clientY;
		const surface = decideSurface(intersects);
		gCube.uiSetInitPosition(intersects[0].object, surface, intersects[0].point, ndcToAbs(ndc));
	};
	const move = thresholding(in_ev => {
		c.x = -1;
		c.y = -1;
		const ndc = ndcFromEvent(in_ev);
		if (gCube.uiIsMoving()) {
			if (gCube.uiUpdatePosition(ndcToAbs(ndc))) {
				SE_MOVED.play();
			}
		} else {
			if (gCube.uiIsDragging()) {
				notifyDelta(ndc);
			} else {
				if (!in_ev[isEmulated]) {
					// setFocus(ndc);
				}
			}
		}
	});
	const stop = in_ev => {
		const releaseProgress = gCube.uiRelease(() => {
			gWorld.removeAnimationHook(releaseProgress);
		});
		if (releaseProgress) {
			gWorld.addAnimationHook(releaseProgress);
		} else {
			if ((c.x !== in_ev.clientX) || (c.y !== in_ev.clientY)) {
				return;
			}
			choose(in_ev);
		}
	};
	return {
		'mousedown' : start,
		'mousemove' : move,
		'mouseleave' : stop,
		'mouseout' : stop,
		'mouseup' : stop
	};
})();

for (let [name, func] of Object.entries(gHandlers)) {
	gWorld.canvas.addEventListener(name, func.bind(this));
}

</script>
</body>
</html>
