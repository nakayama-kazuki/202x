<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports": {
		"three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.min.js",
		"utils": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/utils/BufferGeometryUtils.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';

/*
	(1) utilities
*/

function parseParam(in_url = location.href) {
	const req = new URL(in_url);
	const parsed = {
		q : {},
		h : []
	};
	req.searchParams.forEach((value, key) => {
		parsed.q[key] = value;
	});
	if (req.hash) {
		const hashValues = req.hash.substring(1).split('#');
	}
	return parsed;
}

function getParam(in_name) {
	const parsed = parseParam();
	if (in_name in parsed.q) {
		const value = parsed.q[in_name];
		const checkNum = parseInt(value, 10);
		if (checkNum.toString() === value) {
			return checkNum;
		} else {
			return value;
		}
	}
	if (in_name in parsed.h) {
		return true;
	}
	return false;
}

function randomString(in_length = 5)
{
	return Math.floor(Math.random() * (10 ** in_length)).toString(16).padStart(in_length, '0');
}

function convertUnit(in_u1_value, in_u1_from, in_u1_to, in_u2_from, in_u2_to) {
	return in_u2_from + ((in_u1_value - in_u1_from) / (in_u1_to - in_u1_from)) * (in_u2_to - in_u2_from);
}

/*

const testSets = [
	[+0.1,  0, +1,   0, +10, +1],
	[+0.1, +1,  0,   0, +10, +9],
	[+0.1,  0, +1, +10,   0, +9],
	[+0.1, +1,  0, +10,   0, +1],
	[-0.1,  0, -1,   0, +10, +1],
	[-0.1, -1,  0,   0, +10, +9],
	[-0.1,  0, -1, +10,   0, +9],
	[-0.1, -1,  0, +10,   0, +1],
	[+0.1,  0, +1,   0, -10, -1],
	[+0.1, +1,  0,   0, -10, -9],
	[+0.1,  0, +1, -10,   0, -9],
	[+0.1, +1,  0, -10,   0, -1],
	[-0.1,  0, -1,   0, -10, -1],
	[-0.1, -1,  0,   0, -10, -9],
	[-0.1,  0, -1, -10,   0, -9],
	[-0.1, -1,  0, -10,   0, -1]
];

testSets.forEach(test => {
	if (convertUnit(test[0], test[1], test[2], test[3], test[4]) !== test[5]) {
		console.log('failed');
	}
});

*/

function convertUnitRect(in_src_x, in_src_y, in_src_rect, in_dst_rect)
{
	return (new THREE.Vector2(
		convertUnit(in_src_x, in_src_rect.l, in_src_rect.r, in_dst_rect.l, in_dst_rect.r),
		convertUnit(in_src_y, in_src_rect.t, in_src_rect.b, in_dst_rect.t, in_dst_rect.b)
	));
}

function convertRaycasterUnit(in_src_x, in_src_y, in_src_w, in_src_h)
{
	const src_rect = {
		l : 0,
		t : 0,
		r : in_src_w,
		b : in_src_h
	};
	const dst_rect = {
		l : -1,
		t : -1,
		r : 1,
		b : 1
	};
	const vec2 = convertUnitRect(in_src_x, in_src_y, src_rect, dst_rect);
	// finally, dst_rect.t and dst_rect.b should be inverted
	vec2.y *= -1;
	return vec2;
}

function eventPos2RaycasterPos(in_ev)
{
	const elem = in_ev.currentTarget
	return convertRaycasterUnit(
		in_ev.clientX - elem.offsetLeft,
		in_ev.clientY - elem.offsetTop,
		elem.offsetWidth,
		elem.offsetHeight);
}

const EVPOS_MULTIPLY_PARAM = 3;

function snapToNotch(in_value, in_notch)
{
	let notch = in_notch / 2;
	let abs = Math.abs(in_value);
	let cnt = Math.floor(abs / notch);
	if (cnt % 2 === 1) {
		cnt += 1;
	}
	if (abs === 0) {
		return 0;
	} else {
		return notch * cnt * (in_value / abs);
	}
}

function snapTo05PI(in_value)
{
	/*
		{in : Math.PI / 4 - delta, expected : 0},
		{in : Math.PI / 4 + delta, expected : Math.PI / 2}
	*/
	return snapToNotch(in_value, Math.PI / 2);
}

function nearlyEqual(in_a, in_b, in_error = 0.01) {
	const diff = Math.abs(in_a - in_b);
	const comp = Math.max(Math.abs(in_a), Math.abs(in_b));
	return diff < comp * in_error;
}

const arrRand = Symbol();

Array.prototype[arrRand] = function() {
	return this[Math.floor(Math.random() * this.length)];
};

const forEachCombination = Symbol();

Array.prototype[forEachCombination] = function(in_n, in_callback) {
	const combine = (in_args, in_start, in_decrement) => {
		if (in_decrement === 0) {
			return (in_callback)(...in_args);
		} else {
			for (let i = in_start; i <= this.length - in_decrement; i++) {
				in_args.push(this[i]);
				if (combine(in_args, i + 1, in_decrement - 1)) {
					return true;
				} else {
					in_args.pop();
				}
			}
		}
		return false;
	}
	return (combine)([], 0, in_n);
};

function pseudoMessageDigest1(in_array) {
	let hash = 0;
	in_array.sort().forEach(in_entry => {
		for (let i = 0; i < in_entry.length; i++) {
			hash = (hash << 5) - hash + in_entry.charCodeAt(i);
			hash |= 0;
		}
	});
	return hash >>> 0;
}

function pseudoMessageDigest2(in_string) {
	return pseudoMessageDigest1([in_string]);
}

const createAudio = (() => {
	async function deflate(in_arrBuff) {
		const stream1 = new Blob([in_arrBuff]).stream();
		const stream2 = stream1.pipeThrough(new CompressionStream('deflate'));
		return await new Response(stream2).arrayBuffer();
	}
	async function inflate(in_arrBuff) {
		const stream1 = new Blob([in_arrBuff]).stream();
		const stream2 = stream1.pipeThrough(new DecompressionStream('deflate'));
		return await new Response(stream2).arrayBuffer();
	}
	async function deflate_and_base64encode(in_src) {
		const originalArrBuff = new TextEncoder().encode(in_src);
		const deflatedArrBuff = await deflate(originalArrBuff);
		return btoa(String.fromCharCode(...new Uint8Array(deflatedArrBuff)));
	}
	async function base64decode_and_inflate(in_base64) {
		const bin = atob(in_base64);
		const arr = new Uint8Array(bin.length);
		for (let i = 0; i < bin.length; i++) {
			arr[i] = bin.charCodeAt(i);
		}
		const inflatedArrBuff = await inflate(arr.buffer);
		return new TextDecoder().decode(inflatedArrBuff);
	}
	return async (in_base64) => {
		return new Audio('data:audio/mpeg;base64,' + await base64decode_and_inflate(in_base64));
	}
})();

class cEase {
	constructor(in_from, in_to, in_duration) {
		this.from = in_from;
		this.to = in_to;
		this.duration = in_duration;
		this.start = Date.now();
	}
	#currentEasing(in_quad) {
		const elapsed = Date.now() - this.start;
		if (elapsed > this.duration) {
			return this.to;
		} else {
			return this.from + (this.to - this.from) * (in_quad)(elapsed / this.duration);
		}
	}
	currentEasingLinear() {
		return this.#currentEasing(t => t);
	}
	currentEasingIn() {
		return this.#currentEasing(t => t * t);
	}
	currentEasingOut() {
		return this.#currentEasing(t => t * (2 - t));
	}
}

/*
	*** NOTE ***
	when the app uses position of the mesh to find overlapping etc,
	need to ignore very small error.
*/

class cApproximateMap extends Map {
	// to use this class, key should be numeric
	constructor(in_error) {
		super();
		this.error = in_error;
	}
	#sortedKeys = null;
	#approximateKey(in_key) {
		for (const registeredKey of this.keys()) {
			if (Math.abs(registeredKey - in_key) < this.error) {
				return registeredKey;
			}
		}
		return in_key;
	}
	sortedKey(in_index) {
		if (!this.#sortedKeys) {
			this.#sortedKeys = Array.from(this.keys()).sort((a, b) => a - b);
		}
		return this.#sortedKeys[in_index];
	}
	get(in_key) {
		return super.get(this.#approximateKey(in_key));
	}
	set(in_key, in_value) {
		this.#sortedKeys = null;
		return super.set(this.#approximateKey(in_key), in_value);
	}
	delete(in_key) {
		this.#sortedKeys = null;
		return super.delete(this.#approximateKey(in_key));
	}
}

class cApproximateSet extends Set {
	constructor(in_error) {
		super();
		this.error = in_error;
	}
	#approximateValue(in_value) {
		for (let item of this) {
			if (Math.abs(item - in_value) < this.error) {
				return item;
			}
		}
		return in_value;
	}
	add(in_value) {
		return super.add(this.#approximateValue(in_value));
	}
	has(in_value) {
		return super.has(this.#approximateValue(in_value));
	}
	delete(in_value) {
		return super.delete(this.#approximateValue(in_value));
	}
}

class cCyclicMap extends Map {
	get #keysArray() {
		return Array.from(this.keys());
	}
	#deltaItemByOrder(in_order, in_delta) {
		const length = this.#keysArray.length;
		const deltaIndex = (in_order + in_delta + length) % length;
		const deltaKey = this.#keysArray[deltaIndex];
		return {
			k : deltaKey,
			v : this.get(deltaKey)
		};
	}
	nextItemByOrder(in_order) {
		return this.#deltaItemByOrder(in_order, +1);
	}
	currItemByOrder(in_order) {
		return this.#deltaItemByOrder(in_order, 0);
	}
	prevItemByOrder(in_order) {
		return this.#deltaItemByOrder(in_order, -1);
	}
	#deltaItemByKey(in_key, in_delta) {
		const index = this.#keysArray.indexOf(in_key);
		if (index === -1) {
			return null;
		} else {
			return this.#deltaItemByOrder(index, in_delta);
		}
	}
	nextItemByKey(in_key) {
		return this.#deltaItemByKey(in_key, +1);
	}
	prevItemByKey(in_key) {
		return this.#deltaItemByKey(in_key, -1);
	}
}

class cCyclicValues extends Array {
	#currIndex;
	constructor(...args) {
		super(...args);
		this.#currIndex = 0;
	}
	get #nextIndex() {
		return (this.#currIndex + 1) % this.length;
	}
	#increment() {
		this.#currIndex = this.#nextIndex;
	}
	currValue() {
		return this[this.#currIndex];
	}
	nextValue() {
		return this[this.#nextIndex];
	}
	incrementedValue() {
		this.#increment();
		return this.currValue();
	}
}

function emulateTouchEvent(in_elem) {
	const eventMapper = [
		{
			src : 'touchstart',
			dst : 'mousedown'
		},
		{
			src : 'touchmove',
			dst : 'mousemove'
		},
		{
			src : 'touchleave',
			dst : 'mouseleave'
		},
		{
			src : 'touchend',
			dst : 'mouseup'
		}
	];
	let lastDistance = null;
	function createAltWheelEv(in_ev) {
		const t1 = in_ev.touches[0];
		const t2 = in_ev.touches[1];
		const currentDistance = Math.sqrt(Math.pow(t2.clientX - t1.clientX, 2) + Math.pow(t2.clientY - t1.clientY, 2));
		if (lastDistance === null) {
			lastDistance = currentDistance;
			return null;
		}
		const speed = 2;
		const delta = (lastDistance - currentDistance) * speed;
		lastDistance = currentDistance;
		return new WheelEvent('wheel', {
			deltaY : delta,
			clientX : (t1.clientX + t2.clientX) / 2,
			clientY : (t1.clientY + t2.clientY) / 2,
			ctrlKey : in_ev.ctrlKey,
			altKey : in_ev.altKey,
			shiftKey : in_ev.shiftKey,
			metaKey : in_ev.metaKey
		});
	}
	function createAltMouseEv(in_type, in_ev) {
		return new MouseEvent(in_type, {
			bubbles : true,
			cancelable : true,
			view : window,
			screenX : in_ev.changedTouches[0].screenX,
			screenY : in_ev.changedTouches[0].screenY,
			clientX : in_ev.changedTouches[0].clientX,
			clientY : in_ev.changedTouches[0].clientY,
			ctrlKey : in_ev.ctrlKey,
			altKey : in_ev.altKey,
			shiftKey : in_ev.shiftKey,
			metaKey : in_ev.metaKey,
			button : 0,
			relatedTarget : null
		});
	}
	eventMapper.forEach(in_pair => {
		in_elem.addEventListener(in_pair.src, in_ev => {
			in_ev.preventDefault();
			in_ev.stopPropagation();
			let alternative = null;
			if (in_ev.touches.length > 1) {
				if ((in_ev.touches.length === 2) && (in_pair.src === 'touchmove')) {
					alternative = createAltWheelEv(in_ev);
				} else {
					lastDistance = null;
				}
			} else {
				alternative = createAltMouseEv(in_pair.dst, in_ev);
			}
			if (alternative) {
				in_ev.target.dispatchEvent(alternative);
			}
		});
	});
}

const clipArea = Symbol();
const clipClearArea = Symbol();

HTMLCanvasElement.prototype[clipArea] = function(in_margin, in_callback) {
	const w = this.width;
	const h = this.height;
	let ctx = this.getContext('2d');
	if (!ctx) {
		/*
			*** NOTE ***
			sometimes can't get 2D context ( ex. Three.js ).
			so, to get it, copy bitmap to alternative canvas.
		*/
		const alternative = document.createElement('canvas');
		alternative.width = w;
		alternative.height = h;
		ctx = alternative.getContext('2d');
		ctx.drawImage(this, 0, 0);
	}
	const rgba = (ctx.getImageData(0, 0, w, h)).data;
	let l = Number.POSITIVE_INFINITY;
	let t = Number.POSITIVE_INFINITY;
	let r = Number.NEGATIVE_INFINITY;
	let b = Number.NEGATIVE_INFINITY;
	for (let y = 0; y < h; y++) {
		for (let x = 0; x < w; x++) {
			const pt = (y * w + x) * 4;
			if (!(in_callback)(rgba[pt + 0], rgba[pt + 1], rgba[pt + 2], rgba[pt + 3])) {
				continue;
			}
			if (x < l) {
				l = x;
			}
			if (y < t) {
				t = y;
			}
			if (x > r) {
				r = x;
			}
			if (y > b) {
				b = y;
			}
		}
	}
	l = Math.max(l - in_margin, 0);
	t = Math.max(t - in_margin, 0);
	r = Math.min(r + in_margin, w - 1);
	b = Math.min(b + in_margin, h - 1);
	return {
		l : l,
		t : t,
		r : r,
		b : b,
		w : r - l + 1,
		h : b - t + 1
	};
};

HTMLCanvasElement.prototype[clipClearArea] = function(in_margin) {
	return this[clipArea](in_margin, (in_r, in_g, in_b, in_a) => {
		return (in_a > 0);
	});
}

const XYZ = ['x', 'y', 'z'];

const ROTATE = (in_obj, in_vec3) => {
	XYZ.forEach(in_xyz => {
		// for THREE.Object3D, THREE.Geometry
		const rotateAxis = 'rotate' + in_xyz.toUpperCase();
		in_obj[rotateAxis](in_vec3[in_xyz]);
	});
};

const VEC3 = (x = 0, y = 0, z = 0) => new THREE.Vector3(x, y, z);

const DIRECTION = {
	XP : VEC3(+1, 0, 0),
	XN : VEC3(-1, 0, 0),
	YP : VEC3(0, +1, 0),
	YN : VEC3(0, -1, 0),
	ZP : VEC3(0, 0, +1),
	ZN : VEC3(0, 0, -1)
}

function safeMergeGeometry(in_arr, in_dispose = true) {
	const merged = UTILS.mergeGeometries(in_arr);
	if (in_dispose) {
		in_arr.forEach(in_geo => in_geo.dispose());
	}
	return merged;
}

function makeTrapezoidGeometryParts(in_txLen, in_tzLen, in_bxLen, in_bzLen, in_yLen, in_rad = 0) {
	const parts = [];
	/*
		|
		+- geometry
		|	|
		|	+- userData.isSurface : true / false
		|	|
		|	+- userData.groupName : 'top' / 'bottom' / 'middle'
		|
		+- geometry
		|
		+- ...
	*/
	const DEG90 = Math.PI * 1 / 2;
	const setGroupName = (in_vertices) => {
		if (in_vertices.every(vertex => vertex.y > 0)) {
			return 'top';
		}
		if (in_vertices.every(vertex => vertex.y < 0)) {
			return 'bottom';
		}
		return 'middle';
	};
	/*
			 (+)
			  |
			  0-----1
			 /|    /|
			3-----2 |
			| |   | |
		   -|-4---|-5---(+)
			|/|   |/
			7-----6
		   /  |
		 (+)
	*/
	const baseVertices = {
		v0 : VEC3(in_txLen / 2 * -1, in_yLen / 2 * +1, in_tzLen / 2 * -1),
		v1 : VEC3(in_txLen / 2 * +1, in_yLen / 2 * +1, in_tzLen / 2 * -1),
		v2 : VEC3(in_txLen / 2 * +1, in_yLen / 2 * +1, in_tzLen / 2 * +1),
		v3 : VEC3(in_txLen / 2 * -1, in_yLen / 2 * +1, in_tzLen / 2 * +1),
		v4 : VEC3(in_bxLen / 2 * -1, in_yLen / 2 * -1, in_bzLen / 2 * -1),
		v5 : VEC3(in_bxLen / 2 * +1, in_yLen / 2 * -1, in_bzLen / 2 * -1),
		v6 : VEC3(in_bxLen / 2 * +1, in_yLen / 2 * -1, in_bzLen / 2 * +1),
		v7 : VEC3(in_bxLen / 2 * -1, in_yLen / 2 * -1, in_bzLen / 2 * +1)
	};
	/*
		1. Surface (BufferGeometry)
			even you can also make surface using PlaneGeometry,
			it is a little complicated to decide position before rotation.
	*/
	const surfaceMap = new Map([
		[DIRECTION.XP, [baseVertices.v1, baseVertices.v2, baseVertices.v6, baseVertices.v5]],
		[DIRECTION.XN, [baseVertices.v0, baseVertices.v4, baseVertices.v7, baseVertices.v3]],
		[DIRECTION.YP, [baseVertices.v3, baseVertices.v2, baseVertices.v1, baseVertices.v0]],
		[DIRECTION.YN, [baseVertices.v6, baseVertices.v7, baseVertices.v4, baseVertices.v5]],
		[DIRECTION.ZP, [baseVertices.v7, baseVertices.v6, baseVertices.v2, baseVertices.v3]],
		[DIRECTION.ZN, [baseVertices.v5, baseVertices.v4, baseVertices.v0, baseVertices.v1]]
	]);
	const translatedSurfaceMap = new Map();
	const equal = (in_vec, ...in_vecArr) => in_vecArr.some(vec => in_vec.equals(vec));
	surfaceMap.forEach((in_val, in_key) => {
		let translate;
		if (equal(in_key, DIRECTION.YP, DIRECTION.YN)) {
			// top or bottom
			translate = in_key.clone().multiplyScalar(in_rad);
		} else {
			const normal = VEC3();
			in_val[forEachCombination](3, (a, b, c) => {
				let v1 = (VEC3()).subVectors(a, b);
				let v2 = (VEC3()).subVectors(b, c);
				if ((v1.lengthSq() > 0) && (v2.lengthSq() > 0)) {
					normal.crossVectors(v1, v2);
					if (normal.lengthSq() > 0) {
						normal.normalize();
						return true;
					}
				}
				return false;
			});
			translate = normal.multiplyScalar(in_rad);
		}
		const vertices = [];
		in_val.forEach(in_vertex => {
			vertices.push(in_vertex.clone().add(translate));
		});
		translatedSurfaceMap.set(in_key, vertices);
	});
	for (const vertices of translatedSurfaceMap.values()) {
		const uniqueFilter = (in_vertices) => {
			const unique = [];
			in_vertices.forEach(in_vertex => {
				if (unique.some(in_v => in_v.equals(in_vertex))) {
					return;
				}
				unique.push(in_vertex);
			});
		    return unique;
		};
		const unique = uniqueFilter(vertices);
		if (unique.length < 3) {
			continue;
		}
		const geometry = new THREE.BufferGeometry();
		const flat = [];
		unique.forEach(in_vec3 => {
			flat.push(in_vec3.x, in_vec3.y, in_vec3.z);
		});
		geometry.setAttribute('position', new THREE.Float32BufferAttribute(flat, 3));
		let ix, uv;
		if (unique.length === 3) {
			ix = [0, 1, 2];
			uv = [0, 0, 1, 0, 0.5, 1];
		} else {
			ix = [0, 1, 2, 0, 2, 3];
			uv = [0, 0, 1, 0, 1, 1, 0, 1];
		}
		geometry.setIndex(ix);
		geometry.setAttribute('uv', new THREE.Float32BufferAttribute(new Float32Array(uv), 2));
		geometry.computeVertexNormals();
		geometry.userData.isSurface = true;
		geometry.userData.groupName = setGroupName(vertices);
		parts.push(geometry);
	}
	/*
		2. Edge (CylinderGeometry)
			2.1. Edge for top & bottom surface (applying rotation by prepared setting)
			2.2. Edge for sloped side surface (applying rotation automatically)
	*/
	const makeEdgeCylinder = (in_height, in_start, in_theta) => {
		const defaultRadialSegments = 32;
		const defaultHeightSegments = 1;
		const openEnded = true;
		return new THREE.CylinderGeometry(
			in_rad,
			in_rad,
			in_height,
			defaultRadialSegments,
			defaultHeightSegments,
			openEnded,
			in_start,
			in_theta
		);
	};
	const centroid = (in_vecArr) => {
		const ret = VEC3();
		in_vecArr.forEach(in_vector => {
			ret.add(in_vector);
		});
		return ret.divideScalar(in_vecArr.length);
	};
	const theta = (a, b) => Math.atan(Math.abs(a - b) / 2 / in_yLen) * (a > b ? +1 : -1);
	const thetaX = theta(in_txLen, in_bxLen);
	const thetaZ = theta(in_tzLen, in_bzLen);
	const edgeConfigSet1 = [
		/*
			E : Edge (Vector3 x2)
			R : Rotation from Vector3(0, 1, 0)
			P : Parameter for THREE.CylinderGeometry
		*/
		{E : [baseVertices.v2, baseVertices.v3], R : VEC3(0, 0, DEG90 * -1), P : [DEG90 * 3, DEG90 + thetaZ]},
		{E : [baseVertices.v3, baseVertices.v0], R : VEC3(DEG90 * +1, 0, 0), P : [DEG90 * 2, DEG90 + thetaX]},
		{E : [baseVertices.v0, baseVertices.v1], R : VEC3(0, 0, DEG90 * +1), P : [DEG90 * 1, DEG90 + thetaZ]},
		{E : [baseVertices.v1, baseVertices.v2], R : VEC3(DEG90 * -1, 0, 0), P : [DEG90 * 0, DEG90 + thetaX]},
		{E : [baseVertices.v6, baseVertices.v7], R : VEC3(0, 0, DEG90 * +1), P : [DEG90 * 3, DEG90 - thetaZ]},
		{E : [baseVertices.v7, baseVertices.v4], R : VEC3(DEG90 * -1, 0, 0), P : [DEG90 * 2, DEG90 - thetaX]},
		{E : [baseVertices.v4, baseVertices.v5], R : VEC3(0, 0, DEG90 * -1), P : [DEG90 * 1, DEG90 - thetaZ]},
		{E : [baseVertices.v5, baseVertices.v6], R : VEC3(DEG90 * +1, 0, 0), P : [DEG90 * 0, DEG90 - thetaX]}
	];
	const edgeConfigSet2 = [
		{E : [baseVertices.v3, baseVertices.v7], P : [DEG90 * 3, DEG90]},
		{E : [baseVertices.v0, baseVertices.v4], P : [DEG90 * 2, DEG90]},
		{E : [baseVertices.v1, baseVertices.v5], P : [DEG90 * 1, DEG90]},
		{E : [baseVertices.v2, baseVertices.v6], P : [DEG90 * 0, DEG90]}
	];
	edgeConfigSet1.forEach(in_conf => {
		const length = in_conf.E[0].distanceTo(in_conf.E[1]);
		if (length === 0) {
			return;
		}
		const geometry = makeEdgeCylinder(length, in_conf.P[0], in_conf.P[1]);
		ROTATE(geometry, in_conf.R);
		geometry.translate(centroid(in_conf.E));
		geometry.userData.isSurface = false;
		geometry.userData.groupName = setGroupName(in_conf.E);
		parts.push(geometry);
	});
	const vertical = VEC3(0, 1, 0);
	edgeConfigSet2.forEach(in_conf => {
		const length = in_conf.E[0].distanceTo(in_conf.E[1]);
		const geometry = makeEdgeCylinder(length, in_conf.P[0], in_conf.P[1]);
		/*
			at first, I mistook it for the opposite direction.
			( in_conf.E[0] --> in_conf.E[1] )
			because of it, parameter of theta couldn't be stable.
		*/
		const slope = in_conf.E[0].clone().sub(in_conf.E[1]).normalize();
		const quaternion = new THREE.Quaternion();
		quaternion.setFromUnitVectors(vertical, slope);
		geometry.applyQuaternion(quaternion);
		geometry.translate(centroid(in_conf.E));
		geometry.userData.isSurface = false;
		geometry.userData.groupName = setGroupName(in_conf.E);
		parts.push(geometry);
	});
	/*
		3. Corner (SphereGeometry)
	*/
	const makeCornerSphere = (in_phi_start, in_theta_start, in_theta) => {
		const error = 0.01;
		const widthSegments = 32;
		const heightSegments = 16;
		return new THREE.SphereGeometry(
			in_rad,
			widthSegments,
			heightSegments,
			in_phi_start - error,
			DEG90 + error * 2,
			in_theta_start - error,
			in_theta + error * 2
		);
	};
	const uTheta = (in_txLen > in_bxLen) || (in_tzLen > in_bzLen) ? DEG90 * 2 : DEG90 * 1;
	const bTheta = (in_txLen < in_bxLen) || (in_tzLen < in_bzLen) ? DEG90 * 2 : DEG90 * 1;
	const cornerConfigSet = [
		/*
			C : Corner (Vector3 x1)
			P : Parameter for THREE.SphereGeometry
		*/
		{C : baseVertices.v0, P : [DEG90 * 3, 0, uTheta]},
		{C : baseVertices.v1, P : [DEG90 * 2, 0, uTheta]},
		{C : baseVertices.v2, P : [DEG90 * 1, 0, uTheta]},
		{C : baseVertices.v3, P : [DEG90 * 0, 0, uTheta]},
		{C : baseVertices.v4, P : [DEG90 * 3, DEG90 * 2 - bTheta, bTheta]},
		{C : baseVertices.v5, P : [DEG90 * 2, DEG90 * 2 - bTheta, bTheta]},
		{C : baseVertices.v6, P : [DEG90 * 1, DEG90 * 2 - bTheta, bTheta]},
		{C : baseVertices.v7, P : [DEG90 * 0, DEG90 * 2 - bTheta, bTheta]}
	];
	cornerConfigSet.forEach(in_conf => {
		const geometry = makeCornerSphere(...in_conf.P);
		geometry.translate(in_conf.C);
		geometry.userData.isSurface = false;
		geometry.userData.groupName = setGroupName([in_conf.C]);
		parts.push(geometry);
	});
	return parts;
}

function trapezoidGeometryUtil(in_txLen, in_tzLen, in_bxLen, in_bzLen, in_yLen, in_rad = 0) {
	const parts = makeTrapezoidGeometryParts(in_txLen, in_tzLen, in_bxLen, in_bzLen, in_yLen, in_rad);
	// assume order of groups ( BufferGeometry x6, other geometries ... )
	const groups = [];
	let edgeGroup = 0;
	parts.forEach(in_part => {
		if (in_part.userData.isSurface) {
			groups.push(in_part.index.count);
		} else {
			edgeGroup += in_part.index.count;
		}
	});
	groups.push(edgeGroup);
	const merged = safeMergeGeometry(parts);
	let start = 0;
	for (let i = 0; i < groups.length; i++) {
		merged.addGroup(start, groups[i], i);
		start += groups[i];
	}
	return merged;
}

function roundBoxGeometry(in_xLen, in_yLen, in_zLen, in_rad) {
	return trapezoidGeometryUtil(in_xLen, in_zLen, in_xLen, in_zLen, in_yLen, in_rad);
}

function roundRegularBoxGeometry(in_len, in_rad) {
	return trapezoidGeometryUtil(in_len, in_len, in_len, in_len, in_len, in_rad);
}

function roundTrapezoidGeometry(in_tLen, in_bLen, in_height, in_rad) {
	return trapezoidGeometryUtil(in_tLen, 0, in_bLen, 0, in_height, in_rad);
}

function capsuleConfigure(in_rad_t, in_rad_b, in_h) {
	/*
	                  +-(rad_t)-+
		             /|         |
		            / |         |
		           /  |         | in_h
		          /   |         |
		         /    |         |
		theta : +-----+-(rad_b)-+
	*/
	const ratio = (in_rad_b - in_rad_t) / in_h;
	const atan = Math.atan(1 / ratio);
	return {
		/*
			when in_rad_t < in_rad_b, atan will be "+"
			when in_rad_t = in_rad_b, atan will be "Math.PI / 2"
			when in_rad_t > in_rad_b, atan will be "-"
		*/
		theta : atan > 0 ? atan : Math.PI + atan,
		/*
			when in_rad_t < in_rad_b, delta will be "+"
			when in_rad_t = in_rad_b, delta will be "0"
			when in_rad_t > in_rad_b, delta will be "-"
		*/
		delta : {
			t : in_rad_t * ratio,
			b : in_rad_b * ratio
		},
		/*
			radius (real radius) will be always "+"
		*/
		radius : {
			t : (in_rad_t ** 2 + (in_rad_t * ratio) ** 2) ** 0.5,
			b : (in_rad_b ** 2 + (in_rad_b * ratio) ** 2) ** 0.5
		},
	};
}

/*

console.log(capsuleConfigure(10, 11, 50));
//theta: 1.5507989928...
console.log(capsuleConfigure(10, 10, 50));
//theta: 1.5707963267...
console.log(capsuleConfigure(11, 10, 50));
//theta: 1.5907936607...

*/

function customCapsuleGeometry(in_rad_t, in_rad_b, in_h, in_rSeg = 32, in_hSeg = 1) {
	const conf = capsuleConfigure(in_rad_t, in_rad_b, in_h);
	const sphereParams = [32, 16, 0, Math.PI * 2];
	const parts = [];
	// top
	parts.push(new THREE.SphereGeometry(conf.radius.t, ...sphereParams, 0, conf.theta));
	parts[parts.length - 1].translate(0, conf.delta.t * -1 + in_h / 2, 0);
	// bottom
	parts.push(new THREE.SphereGeometry(conf.radius.b, ...sphereParams, conf.theta, Math.PI - conf.theta));
	parts[parts.length - 1].translate(0, conf.delta.b * -1 - in_h / 2, 0);
	// middle
	parts.push(new THREE.CylinderGeometry(in_rad_t, in_rad_b, in_h, in_rSeg, in_hSeg, true));
	return safeMergeGeometry(parts);
}

/*
	(2) cSphericalWorld

	|
	+-- Scene
	|
	+-- WebGLRenderer
	|
	+-- Object3D ( to control camera )
		|
		+- PerspectiveCamera
*/

const DEVICE_PIXEL_RATIO = window.devicePixelRatio;

class cSphericalWorld {
	static #defaultCameraSetting = 2;
	static #view = [
		{
			cameraFrom : DIRECTION.ZN,
			cameraUp : DIRECTION.YP,
			dxDir : -1,
			dyDir : -1
		},
		{
			cameraFrom : DIRECTION.ZN,
			cameraUp : DIRECTION.YN,
			dxDir : 1,
			dyDir : 1
		},
		{
			cameraFrom : DIRECTION.ZP,
			cameraUp : DIRECTION.YP,
			dxDir : -1,
			dyDir : 1
		},
		{
			cameraFrom : DIRECTION.ZP,
			cameraUp : DIRECTION.YN,
			dxDir : 1,
			dyDir : -1
		}
	][cSphericalWorld.#defaultCameraSetting];
	static #rotationCallbackName = Symbol();
	static #cameraName = randomString();
	#scene = null;
	#renderer = null;
	#cameraCtrl = null;
	#anchorPosV2 = null;
	zoomMin = Number.NEGATIVE_INFINITY;
	zoomMax = Number.POSITIVE_INFINITY;
	#userObjects = new Set();
	#animationHooks = new Set();
	static #deltaThreshold = 0.05;
	constructor(in_radius) {
		// scene
		this.#scene = new THREE.Scene();
		//this.#scene.background = new THREE.Color(0xFFFFFF);
		// renderer
		this.#renderer = new THREE.WebGLRenderer({alpha : true, antialias : true});
		this.#renderer.setPixelRatio(DEVICE_PIXEL_RATIO);
		// camera
		const camera = new THREE.PerspectiveCamera();
		camera.name = cSphericalWorld.#cameraName;
		camera.fov = 45;
		camera.near = 1;
		camera.far = in_radius * 2;
		camera.position.set(
			0,
			0,
			in_radius * cSphericalWorld.#view.cameraFrom.z);
		camera.up.copy(cSphericalWorld.#view.cameraUp);
		camera.lookAt(VEC3(0, 0, 0));
		if (false) {
			camera.layers.enableAll();
		}
		this.#cameraCtrl = new THREE.Object3D();
		this.#cameraCtrl.add(camera);
		// light
		const lightColor = 0xFFFFFF;
		const light = new THREE.DirectionalLight(lightColor);
		light.position.set(
			0,
			in_radius * cSphericalWorld.#view.cameraUp.y,
			in_radius * cSphericalWorld.#view.cameraFrom.z);
		this.#cameraCtrl.add(light);
		this.add(new THREE.AmbientLight(lightColor), true);
		// other
		this.resize(this.canvas.width, this.canvas.height);
		this.canvas.addEventListener('mousedown', this.#evMoveStart.bind(this));
		this.canvas.addEventListener('mousemove', this.#evMoveUpdate.bind(this));
		this.canvas.addEventListener('mouseleave', this.#evMoveStop.bind(this));
		this.canvas.addEventListener('mouseout', this.#evMoveStop.bind(this));
		this.canvas.addEventListener('mouseup', this.#evMoveStop.bind(this));
		this.canvas.addEventListener('wheel', this.#evZoom.bind(this));
		emulateTouchEvent(this.canvas);
	}
	get canvas() {
		return this.#renderer.domElement;
	}
	get #camera() {
		return this.#cameraCtrl.getObjectByName(cSphericalWorld.#cameraName);
	}
	getLookAt() {
		return this.#camera.position.clone().negate();
	}
	#moveCameraCtrl(in_world_dx, in_world_dy) {
		this.#cameraCtrl.rotateY(in_world_dx * cSphericalWorld.#view.dxDir);
		this.#cameraCtrl.rotateX(in_world_dy * cSphericalWorld.#view.dyDir);
	}
	moveView(in_world_dx, in_world_dy) {
		this.#moveCameraCtrl(in_world_dx * -1, in_world_dy * -1);
	}
	#setZoom(in_distance) {
		this.#camera.position.normalize().multiplyScalar(in_distance);
	}
	#evMoveStart(in_ev) {
		const vec2 = eventPos2RaycasterPos(in_ev);
		if (this.intersectPositive(vec2).length > 0) {
			return;
		}
		this.#anchorPosV2 = vec2;
	}
	#evMoveUpdate(in_ev) {
		if (!this.#anchorPosV2) {
			return;
		}
		const vec2 = eventPos2RaycasterPos(in_ev);
		let delta = vec2.clone().sub(this.#anchorPosV2);
		if (delta.length() < cSphericalWorld.#deltaThreshold) {
			return;
		}
		delta.multiplyScalar(EVPOS_MULTIPLY_PARAM);
		this.#moveCameraCtrl(delta.x, delta.y);
		this.#anchorPosV2 = vec2;
	}
	#evMoveStop(in_ev) {
		if (!this.#anchorPosV2) {
			return;
		}
		this.#anchorPosV2 = null;
	}
	#evZoom(in_ev) {
		const distance = this.#camera.position.length() + in_ev.deltaY;
		if ((this.zoomMax < distance) && (distance < this.zoomMin)) {
			this.#setZoom(distance);
		}
	}
	#intersectObjects(in_vec2, in_direction, in_layer) {
		const raycaster = new THREE.Raycaster();
		raycaster.layers.set(in_layer);
		// camera ---[ raycast ]---> object
		raycaster.setFromCamera(in_vec2, this.#camera);
		const intersects = raycaster.intersectObjects(this.#scene.children);
		if (in_direction || (intersects.length === 0)) {
			return intersects;
		}
		// camera ---> object ( intersects[0].point ) ---[ raycaster.ray.direction ]---> opposit
		const opposit = (intersects[0].point.clone()).add(raycaster.ray.direction.multiplyScalar(this.#camera.far));
		// camera ---> object <---[ raycast again ]--- opposit
		raycaster.set(opposit, (raycaster.ray.direction.clone()).negate());
		return raycaster.intersectObjects(this.#scene.children);
	}
	intersectPositive(in_vec2, in_layer = 0) {
		return this.#intersectObjects(in_vec2, true, in_layer);
	}
	intersectNegative(in_vec2, in_layer = 0) {
		return this.#intersectObjects(in_vec2, false, in_layer);
	}
	copyCameraPosition() {
		return this.#camera.getWorldPosition(VEC3());
	}
	#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, in_method) {
		return new Promise(resolve => {
			if (nearlyEqual(in_initValue, in_stopValue)) {
				(in_progressCallback)(in_stopValue);
				// to the next then in the chain
				(resolve)();
				return;
			}
			const ease = new cEase(in_initValue, in_stopValue, in_duration);
			const hook = () => {
				let currValue;
				switch (in_method) {
				case 10 :
					currValue = ease.currentEasingIn();
					break;
				case 20 :
					currValue = ease.currentEasingOut();
					break;
				case 30 :
				default :
					currValue = ease.currentEasingLinear();
					break;
				}
				if (currValue === in_stopValue) {
					this.removeAnimationHook(hook);
					(in_progressCallback)(in_stopValue);
					// to the next then in the chain
					(resolve)();
				} else {
					(in_progressCallback)(currValue);
				}
			};
			this.addAnimationHook(hook);
		});
	}
	easeIn(in_initValue, in_stopValue, in_duration, in_progressCallback) {
		return this.#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, 10);
	}
	easeOut(in_initValue, in_stopValue, in_duration, in_progressCallback) {
		return this.#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, 20);
	}
	easeLinear(in_initValue, in_stopValue, in_duration, in_progressCallback) {
		return this.#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, 30);
	}
	addAnimationHook(in_hook) {
		this.#animationHooks.add(in_hook);
	}
	removeAnimationHook(in_hook) {
		this.#animationHooks.delete(in_hook);
	}
	motionZoom1(in_initDistance, in_stopDistance, in_duration) {
		return this.easeOut(in_initDistance, in_stopDistance, in_duration, in_currDistance => {
			this.#setZoom(in_currDistance);
		});
	}
	motionZoom2(in_stopDistance, in_duration) {
		return this.motionZoom1(this.#camera.position.length(), in_stopDistance, in_duration);
	}
	motionKnock(in_duration = 100) {
		const currentDistance = this.#camera.position.length();
		return this.motionZoom1(currentDistance * 1.1, currentDistance, in_duration);
	}
	motionDefaultView(in_duration = 2000) {
		const targetQuat = new THREE.Quaternion();
		const targetRad = this.#cameraCtrl.quaternion.angleTo(targetQuat);
		return this.easeIn(0, targetRad, in_duration, in_currRad => {
			this.#cameraCtrl.quaternion.rotateTowards(targetQuat, in_currRad);
		});
	}
	motionFog(in_color, in_initFogged, in_stopFogged, in_duration = 500) {
		return new Promise(resolve => {
			if (this.#scene.fog) {
				// to the next then in the chain
				(resolve)();
				return;
			}
			const distance = this.#camera.position.length();
			const margin = 100;
			const radius = this.#getUserObjectRadius() + margin;
			const initNear = convertUnit(in_initFogged, 0, 100, distance + radius, distance - radius * 3);
			const stopNear = convertUnit(in_stopFogged, 0, 100, distance + radius, distance - radius * 3);
			this.#scene.fog = new THREE.Fog(in_color, initNear, initNear + radius * 2);
			this.easeLinear(initNear, stopNear, in_duration, in_currNear => {
				this.#scene.fog.near = in_currNear;
				this.#scene.fog.far = in_currNear + radius * 2;
			}).then(() => {
				this.#scene.fog = null;
				// to the next then in the chain
				(resolve)();
			});
		});
	}
	startRotation(in_vec3) {
		this[cSphericalWorld.#rotationCallbackName] = () => {
			ROTATE(this.#cameraCtrl, in_vec3);
		};
		this.addAnimationHook(this[cSphericalWorld.#rotationCallbackName]);
	}
	stopRotation() {
		this.removeAnimationHook(this[cSphericalWorld.#rotationCallbackName]);
		delete this[cSphericalWorld.#rotationCallbackName];
	}
	resize(in_w, in_h) {
		this.#renderer.setSize(in_w, in_h);
		this.#camera.aspect = in_w / in_h;
		this.#camera.updateProjectionMatrix();
	}
	#getUserObjectRadius() {
		let max = Number.NEGATIVE_INFINITY;
		this.#userObjects.forEach(in_obj => {
			const box = (new THREE.Box3()).setFromObject(in_obj);
			const sphere = new THREE.Sphere();
			box.getBoundingSphere(sphere);
			max = Math.max(max, sphere.radius);
		});
		return max;
	}
	#updateZoomParams() {
		let delayed = 1000;
		const update = () => {
			const radius = this.#getUserObjectRadius();
			if (radius < 0) {
				// don't have visible object
				delayed *= 2;
				window.setTimeout(update, delayed);
			} else {
				this.zoomMin = this.#camera.far - radius;
				this.zoomMax = radius
			}
		};
		(update)();
	}
	add(in_added, in_isSystemObject = false) {
		this.#scene.add(in_added);
		if (in_isSystemObject) {
			return;
		}
		this.#userObjects.add(in_added);
		this.#updateZoomParams();
	}
	remove(in_removed, in_isSystemObject = false) {
		/*
			*** NOTE ***
			as remove is idempotent,
			children will be removed safety.
		*/
		this.#scene.remove(in_removed);
		if (in_isSystemObject) {
			return;
		}
		this.#userObjects.delete(in_removed);
		this.#updateZoomParams();
	}
	render() {
		this.#renderer.render(this.#scene, this.#camera);
	}
	start() {
		this.add(this.#cameraCtrl, true);
		this.#renderer.setAnimationLoop(() => {
			this.render();
			this.#animationHooks.forEach(in_hook => {
				(in_hook)();
			});
		});
	}
}

/*
	(3) Texture, MeshLambertMaterial, and BoxGeometry using cCache, which returns the same object in cache without creating.
*/

function factoryBuilder(in_constructor) {
	class cCache {
		static #cache = {};
		constructor(...in_args) {
			this.entity = (in_constructor)(...in_args);
		}
		static #genKey(...in_args) {
			const args = [];
			// assume in_args is primitive
			in_args.forEach(in_arg => {
				if (Number.isFinite(in_arg)) {
					args.push(Math.ceil(in_arg));
				} else {
					args.push(in_arg);
				}
			});
			return '_' + args.join('-');
		}
		static getRef(...in_args) {
			const key = cCache.#genKey(...in_args);
			if (key in cCache.#cache) {
				// console.log('cache hit ( cCache key : ' + key + ' )');
			} else {
				cCache.#cache[key] = new cCache(...in_args);
			}
			return cCache.#cache[key].entity;
		}
		static allClear(in_callback = null) {
			if (in_callback) {
				Object.keys(cCache.#cache).forEach(in_key => {
					(in_callback)(cCache.#cache[in_key].entity);
				});
			}
			cCache.#cache = {};
		}
	}
	/*
		*** NOTE ***
		when there are a lot of the same objects,
		and they can be shared using reference,
		cCache.getRef() returns reference.
	*/
	return {
		create : cCache.getRef,
		allClear : cCache.allClear
	};
}

CanvasRenderingContext2D.prototype.fillRoundRect = function(x, y, w, h, r) {
	this.beginPath();
	this.moveTo(x + r, y);
	this.lineTo(x + w - r, y);
	this.arc(x + w - r, y + r, r, Math.PI * (3 / 2), 0, false);
	this.lineTo(x + w, y + h - r);
	this.arc(x + w - r, y + h - r, r, 0, Math.PI * (1 / 2), false);
	this.lineTo(x + r, y + h);
	this.arc(x + r, y + h - r, r, Math.PI * (1 / 2), Math.PI, false);
	this.lineTo(x, y + r);
	this.arc(x + r, y + r, r, Math.PI, Math.PI * (3 / 2), false);
	this.closePath();
	this.fill();
}

const textureFactory = factoryBuilder((in_w, in_h) => {
	const gradation = 4
	// gradation (from black to white)
	let maxDepth = 255;
	let styles = [];
	for (let i = 0; i < gradation; i++) {
		let depth = Math.ceil(maxDepth / (gradation - 1) * i);
		styles[i] = 'rgb(' + depth + ',' + depth + ',' + depth + ')';
	}
	// draw and convert using toDataUR
	let canvas = document.createElement('CANVAS');
	canvas.width = in_w;
	canvas.height = in_h;
	const ctx = canvas.getContext('2d');
	let radius = gradation + 2;
	/*
		Rect           RoundRect      RoundRect

		##########     ##########     ##########
		##########     ##******##     ##******##
		##########     #********#     #**++++**#
		##########     #********#     #*++++++*#
		########## --> #********# --> #*++++++*# --> ...
		##########     #********#     #*++++++*#
		##########     #********#     #**++++**#
		##########     ##******##     ##******##
		##########     ##########     ##########
	*/
	for (let i = 0; i < gradation; i++) {
		ctx.fillStyle = styles[i];
		if (i > 0) {
			ctx.fillRoundRect(i, i, in_w - i * 2, in_h - i * 2, radius - i);
		} else {
			ctx.fillRect(i, i, in_w - i * 2, in_h - i * 2);
		}
	}
	return (new THREE.TextureLoader()).load(canvas.toDataURL());
});

const materialFactory = factoryBuilder((in_w, in_h, in_color) => {
	return new THREE.MeshLambertMaterial({
		color : in_color,
		map : textureFactory.create(in_w, in_h)
	});
});

function boxMaterials(in_x, in_y, in_z, in_colors) {
	/*
		     2    
		     |   5
		     |  /
		    ###/
		    ###
		1 --#*#-- 0
		    /##
		   /###
		  /  |
		 4   |
		     3
	*/
	return [
		materialFactory.create(in_z, in_y, in_colors[0]),
		materialFactory.create(in_y, in_z, in_colors[1]),
		materialFactory.create(in_x, in_z, in_colors[2]),
		materialFactory.create(in_x, in_z, in_colors[3]),
		materialFactory.create(in_x, in_y, in_colors[4]),
		materialFactory.create(in_x, in_y, in_colors[5])
	];
}

const boxGeometryFactory = factoryBuilder((in_x, in_y, in_z) => {
	const radian = 6;
	return roundBoxGeometry(in_x - radian * 2, in_y - radian * 2, in_z - radian * 2, radian);
});

const GRAY = 0x222222;

const ORANGE = 0xFFAA00;
const RED = 0xFF0000;
const WHITE = 0xFFFFFF;
const YELLOW = 0xFFFF00;
const BLUE = 0x3333FF;
const GREEN = 0x33CC33;

const SURFACEPROP = [];

if (getParam('color') === 'easy') {
	SURFACEPROP.push({V3 : DIRECTION.XP, COLOR : WHITE});
	SURFACEPROP.push({V3 : DIRECTION.XN, COLOR : WHITE});
	SURFACEPROP.push({V3 : DIRECTION.YP, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.YN, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.ZP, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.ZN, COLOR : BLUE});
} else {
	// standard color scheme
	SURFACEPROP.push({V3 : DIRECTION.XP, COLOR : ORANGE});
	SURFACEPROP.push({V3 : DIRECTION.XN, COLOR : RED});
	SURFACEPROP.push({V3 : DIRECTION.YP, COLOR : WHITE});
	SURFACEPROP.push({V3 : DIRECTION.YN, COLOR : YELLOW});
	SURFACEPROP.push({V3 : DIRECTION.ZP, COLOR : BLUE});
	SURFACEPROP.push({V3 : DIRECTION.ZN, COLOR : GREEN});
}

function pieceColorList(in_dimV3, in_ixV3) {
	/*
		piece ( hexahedron ) has surface x6
		|
		+- edge surface x0-3
		|	|
		|	+- orange, red, white, ...
		|
		+- inner surface x3-6
			|
			+- dark gray
	*/
	const colorList = [];
	const insedeColor = GRAY;
	// when in_ixV3 is on an edge, the color of SURFACEPROP is used
	SURFACEPROP.forEach(({V3, COLOR}) => {
		XYZ.forEach(in_xyz => {
			switch (V3[in_xyz]) {
			// the surface is facing the positive direction
			case +1 :
				// the position is at the positive edge
				if (in_ixV3[in_xyz] === in_dimV3[in_xyz] - 1) {
					colorList.push(COLOR);
				} else {
					colorList.push(insedeColor);
				}
				break;
			// the surface is facing the negative direction
			case -1 :
				// the position is at the negative edge
				if (in_ixV3[in_xyz] === 0) {
					colorList.push(COLOR);
				} else {
					colorList.push(insedeColor);
				}
				break;
			case 0 :
				break;
			}
		});
	});
	return colorList;
}

/*
	(4) dimension of Cube and Meshes of them
*/

class cCubeDimV3 extends THREE.Vector3 {
	get maxDim() {
		return Math.max(...this.toArray());
	}
	#sizeList(in_unitSize = 1) {
		const list = {};
		/*
			in case of 3x2x2, ...
			list.x = [in_unitSize, in_unitSize, in_unitSize]
			list.y = [in_unitSize, in_unitSize * 2]
			list.z = [in_unitSize, in_unitSize * 2]
		*/
		XYZ.forEach(in_xyz => {
			if (this[in_xyz] < this.maxDim) {
				// separate not 4=3+1 but 4=2+2
				if (this.maxDim % this[in_xyz] === 0) {
					const quotient = this.maxDim / this[in_xyz];
					list[in_xyz] = Array(this[in_xyz]).fill(in_unitSize * quotient);
				} else {
					list[in_xyz] = Array(this[in_xyz] - 1).fill(in_unitSize);
					list[in_xyz].push((this.maxDim - this[in_xyz] + 1) * in_unitSize);
				}
			} else {
				list[in_xyz] = Array(this[in_xyz]).fill(in_unitSize);
			}
		});
		return list;
	}
	#indexLoop(in_callback) {
		// first surface is at "new THREE.Vector3(0, 0, -1)"
		for (let z = 0; z < this.z; z++) {
			for (let y = 0; y < this.y; y++) {
				for (let x = 0; x < this.x; x++) {
					(in_callback)(new THREE.Vector3(x, y, z));
				}
			}
		}
	}
	positionLoop(in_callback, in_unitSize, in_moveToV3 = new THREE.Vector3(0, 0, 0)) {
		const sizeList = this.#sizeList(in_unitSize);
		/*
			each piece should be translated using translateV3

			before translated :

			   |
			   +---+
			   |   |
			   |   |
			   |   |
			---+---+-
			   |
			   |
			   |

			after translated :

			   |
			   |
			   |
			 +-+-+
			 | | |
			-+-+-+---
			 | | |
			 +-+-+
			   |
		*/
		const cubeCneter = this.maxDim * in_unitSize / 2;
		const translateV3 = in_moveToV3.clone().sub(new THREE.Vector3(cubeCneter, cubeCneter, cubeCneter));
		this.#indexLoop(in_ixV3 => {
			const pieceSizeV3 = VEC3();
			const piecePosV3 = VEC3();
			XYZ.forEach(in_xyz => {
				const curr = in_ixV3[in_xyz];
				let start = 0;
				for (let i = 0; i < curr; i++) {
					start += sizeList[in_xyz][i];
				}
				pieceSizeV3[in_xyz] = sizeList[in_xyz][curr];
				piecePosV3[in_xyz] = start + pieceSizeV3[in_xyz] / 2;
			});
			piecePosV3.add(translateV3);
			(in_callback)(in_ixV3, piecePosV3, pieceSizeV3);
		});
	}
	isInsideCube(in_ixV3) {
		return XYZ.every(in_xyz => {
			return (0 < in_ixV3[in_xyz]) && (in_ixV3[in_xyz] < this[in_xyz] - 1);
		});
	}
}

const CUBE_SIZE = 400;

const gMeshLevelMap = ((in_cubeSize) => {
	const map = new cCyclicMap();
	const edgeMaterial = new THREE.MeshLambertMaterial({color : GRAY});
	const cubeDimList = [
		new cCubeDimV3(2, 2, 1),	/* =  4 */
		new cCubeDimV3(3, 2, 1),	/* =  6 */
		new cCubeDimV3(2, 2, 2),	/* =  8 */
		new cCubeDimV3(3, 2, 2),	/* = 12 */
		new cCubeDimV3(4, 2, 2),	/* = 16 */
		new cCubeDimV3(3, 3, 2),	/* = 18 */
		new cCubeDimV3(4, 3, 2),	/* = 24 */
		new cCubeDimV3(3, 3, 3),	/* = 27 */
		new cCubeDimV3(4, 4, 2),	/* = 32 */
		new cCubeDimV3(4, 3, 3),	/* = 36 */
		new cCubeDimV3(4, 4, 3),	/* = 48 */
		new cCubeDimV3(4, 4, 4)		/* = 64 */
	];
	cubeDimList.forEach(in_cubeDim => {
		const unitSize = in_cubeSize / in_cubeDim.maxDim;
		const pieces = [];
		// see cCubeDimV3 implementation
		in_cubeDim.positionLoop((in_ixV3, in_posV3, in_sizeV3) => {
			if (in_cubeDim.isInsideCube(in_ixV3)) {
				// console.log('inside', in_ixV3);
				return;
			}
			const geometry = boxGeometryFactory.create(...in_sizeV3.toArray());
			// geometry has 7 groups (sub meshes)
			const colors = pieceColorList(in_cubeDim, in_ixV3);
			const materials = boxMaterials(...in_sizeV3.toArray(), colors);
			materials.push(edgeMaterial);
			/*
				*** NOTE ***
				when you use materials (= array) for "new THREE.Mesh",
				the geometry should be devided into groups (= sub meshes).
			*/
			const piece = new THREE.Mesh(geometry, materials);
			piece.position.copy(in_posV3);
			pieces.push(piece);
		}, unitSize);
		const LEVEL1 = 27;
		let level = in_cubeDim.toArray().reduce((product, current) => {
			return product * current;
		}, 1);
		level = (level / LEVEL1).toFixed(1);
		const keyString = in_cubeDim.toArray().join('x') + ' = lv ' + level;
		map.set(keyString, pieces);
	});
	return map;
})(CUBE_SIZE);

let gMeshCurrentLevel = getParam('level');

if (gMeshCurrentLevel === false) {
	gMeshCurrentLevel = 7;
}

function getColorBySide(in_mesh, in_targetV3) {
	const matrix = (new THREE.Matrix4()).makeRotationFromQuaternion(in_mesh.quaternion);
	const invertV3 = in_targetV3.clone().applyMatrix4(matrix.invert());
	const err = 0.001;
	for (let i = 0; i < SURFACEPROP.length; i++) {
		const surfaceV3 = SURFACEPROP[i].V3;
		if (XYZ.every(in_xyz => Math.abs(invertV3[in_xyz] - surfaceV3[in_xyz]) < err)) {
			return in_mesh.material[i].color.getHex();
		}
	}
	return -1;
}

/*
	(5) Rubik's Cube related functions
*/

let AUDIO_ROTATION, AUDIO_ERROR;

createAudio('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').then(in_audio => AUDIO_ROTATION = in_audio);

createAudio('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').then(in_audio => AUDIO_ERROR = in_audio);

class cRubiksCube extends THREE.Object3D {
	static #smallError = 0.01;
	static get err() {
		return cRubiksCube.#smallError;
	}
	static #orderBy(...in_args) {
		for (let i = 0; i < in_args.length - 1 ; i++) {
			if (in_args[i + 1] - in_args[i] < cRubiksCube.err) {
				return false;
			}
		}
		return true;
	}
	static #axes = {
		x : new THREE.Vector3(1, 0, 0),
		y : new THREE.Vector3(0, 1, 0),
		z : new THREE.Vector3(0, 0, 1)
	};
	static #axisKey(in_axis) {
		return Object.keys(cRubiksCube.#axes).filter(in_key => cRubiksCube.#axes[in_key].equals(in_axis));
	}
	static #staticTest = {mode : false, obj : null};
	static unitTest(in_method, in_testObj = {}, ...in_args) {
		cRubiksCube.#staticTest.mode = true;
		cRubiksCube.#staticTest.obj = in_testObj
		const ret = eval('cRubiksCube.' + in_method + '(...in_args)');
		console.log(ret);
		throw new Error('end of unitTest'); 
	}
	#instanceTest = {mode : false, obj : null};
	unitTest(in_method, in_testObj = {}, ...in_args) {
		this.#instanceTest.mode = true;
		this.#instanceTest.obj = in_testObj
		const ret = eval('this.' + in_method + '(...in_args)');
		console.log(ret);
		throw new Error('unitTest'); 
	}
	get #settingVal() {
		if (this.userData.currentSettingKey) {
			return this.userData.settingPerPieces[this.userData.currentSettingKey];
		} else {
			throw new Error('no currentSettingKey');
		}
	}
	set #settingKey(in_value) {
		if (!this.userData.settingPerPieces) {
			this.userData.settingPerPieces = {};
		}
		if (!this.userData.settingPerPieces[in_value]) {
			this.userData.settingPerPieces[in_value] = {};
		}
		this.userData.currentSettingKey = in_value;
	}
	removePieces() {
		const pieces = this.children.slice();
		pieces.forEach(in_piece => {
			this.remove(in_piece);
		});
		this.userData.currentSettingKey = null;
	}
	addPieces(in_pieces) {
		this.removePieces();
		const uuids = [];
		in_pieces.forEach(in_piece => {
			if (!in_piece.userData.initialPosition) {
				// all pieces should have initial position to check complete
				in_piece.userData.initialPosition = in_piece.position.clone();
			}
			uuids.push(in_piece.uuid);
			this.add(in_piece);
		});
		this.#settingKey = pseudoMessageDigest1(uuids);
		if (!this.#settingVal.initialized) {
			this.#settingVal.completeCallback = null;
			this.#settingVal.rotationCount = 0;
			this.#settingVal.shuffled = false;
			this.#settingVal.initialized = true;
		}
	}
	getScore() {
		const max = 100;
		return Math.max(Math.ceil((max - this.#settingVal.rotationCount) / 10) * 10, 0);
	}
	isComplete() {
		return SURFACEPROP.every(in_prop => {
			const surfaceV3 = in_prop.V3;
			let sameColor = -1;
			return this.children.every(in_piece => {
				const color = getColorBySide(in_piece, surfaceV3);
				if (color === GRAY) {
					return true;
				}
				if (sameColor < 0) {
					sameColor = color;
					return true;
				}
				if (sameColor === color) {
					return true;
				} else {
					return false;
				}
			});
		});
	}
	#composeGroup(in_pieces) {
		const group = new THREE.Object3D();
		this.add(group);
		in_pieces.forEach(in_piece => {
			group.add(in_piece);
		});
		return group;
	}
	#releaseGroup(in_group) {
		const copiedPieces = [...in_group.children];
		copiedPieces.forEach(in_piece => {
			/*
				*** NOTE ***
				"add" follows parent position.
				"attach" keeps world position.
				in addition, both of them internally call "remove" from other object.
			*/
			this.attach(in_piece);
		});
		this.remove(in_group);
	}
	#makeGroupOnAxis_1_groupBySameScalar(io_scalarMap, in_axis) {
		this.children.forEach(in_piece => {
			const component = in_piece.position.dot(in_axis);
			const reference = io_scalarMap.get(component);
			if (reference) {
				// there already exists almost the same component
				reference.pieces.push(in_piece);
				reference.tmpBox.union(new THREE.Box3().setFromObject(in_piece));
			} else {
				io_scalarMap.set(component, {
					pieces : [in_piece],
					tmpBox : new THREE.Box3().setFromObject(in_piece)
				});
			}
		});
	}
	static #makeGroupOnAxis_2_calculateEdges(io_scalarMap, in_axis) {
		for (const [scalar, info] of io_scalarMap.entries()) {
			const length = (new THREE.Vector3().subVectors(info.tmpBox.max, info.tmpBox.min)).dot(in_axis);
			info.edgeL = scalar - length / 2;
			info.edgeR = scalar + length / 2;
			delete info.tmpBox;
		}
	}
	static #makeGroupOnAxis_3_makeCandidatesBorder(in_scalarMap) {
		const candidateBorderSet = new cApproximateSet(cRubiksCube.err);
		for (const info of in_scalarMap.values()) {
			candidateBorderSet.add(info.edgeL);
			candidateBorderSet.add(info.edgeR);
		}
		const candidateBorder = Array.from(candidateBorderSet);
		candidateBorder.sort((a, b) => a - b);
		candidateBorder.shift();
		candidateBorder.pop();
		return candidateBorder;
	}
	static #makeGroupOnAxis_4_makeActualBorder(in_scalarMap, in_candidateBorder) {
		const actualBorder = [];
		for (let i = 0; i < in_candidateBorder.length; i++) {
			let isBorder = true;
			for (const info of in_scalarMap.values()) {
				if (cRubiksCube.#orderBy(info.edgeL, in_candidateBorder[i], info.edgeR)) {
					isBorder = false;
					break;
				}
			}
			if (isBorder) {
				actualBorder.push(in_candidateBorder[i]);
			}
		}
		return actualBorder;
	}
	static #makeGroupOnAxis_5_makeActualBorder(in_scalarMap, in_actualBorder) {
		const groups = [];
		let next = 0;
		in_actualBorder.push(Infinity);
		in_actualBorder.forEach(border => {
			const pieces = [];
			for (let i = next; i < in_scalarMap.size; i++) {
				const ascendingScalar = in_scalarMap.sortedKey(i);
				if (ascendingScalar < border) {
					const info = in_scalarMap.get(ascendingScalar);
					pieces.push(...info.pieces);
				} else {
					next = i;
					break;
				}
			}
			groups.push(pieces);
		});
		return groups;
	}
	#makeGroupOnAxis(in_axis) {
		/*
			step #1 : scalarMap is the group of position based on in_axis. for example ...

				+---+---+---+---+---+---+
				| x | x | x | x | x | x |
				+---+---+---+---+---+---+
				| x |   x   | x | x | x |
				+---+---+---+---+---+---+
				| x |       x       | x |
				+---+---+---+---+---+---+

				--x---x-x-x-x-x---x---x--> : in_axis

				 3.00, {tmpBox, piece + piece + piece}
				 7.00, {tmpBox, piece}
				 9.00, {tmpBox, piece}
				11.00, {tmpBox, piece}
				13.00, {tmpBox, piece}
				15.00, {tmpBox, piece + piece}
				19.00, {tmpBox, piece + piece}
				23.00, {tmpBox, piece + piece + piece}

			step #2 : calculate edges for the bounding box. for example ...

				 3.00, {edgeL =  1.00, edgeR =  5.00, piece + piece + piece}
				 7.00, {edgeL =  5.00, edgeR =  9.00, piece}
				 9.00, {edgeL =  5.00, edgeR = 13.00, piece}
				11.00, {edgeL =  9.00, edgeR = 13.00, piece}
				13.00, {edgeL =  5.00, edgeR = 21.00, piece}
				15.00, {edgeL = 13.00, edgeR = 17.00, piece + piece}
				19.00, {edgeL = 17.00, edgeR = 21.00, piece + piece}
				23.00, {edgeL = 21.00, edgeR = 25.00, piece + piece + piece}
		*/
		let scalarMap = new cApproximateMap(cRubiksCube.err);
		if (this.#instanceTest.mode) {
			scalarMap = this.#instanceTest.obj;
		} else {
			this.#makeGroupOnAxis_1_groupBySameScalar(scalarMap, in_axis);
			cRubiksCube.#makeGroupOnAxis_2_calculateEdges(scalarMap, in_axis);
		}
		/*
			step #3 : make candidates of border which decides group
		*/
		const candidateBorder = cRubiksCube.#makeGroupOnAxis_3_makeCandidatesBorder(scalarMap);
		if (this.#instanceTest.mode) {
			/*
				*** NOTE ***
				to display a reference using "console.log", you should use a copy of the reference.
				without it, the entity may appear updated when displayed because the console holds a reference,
				and any subsequent changes to the object will be reflected in the console.
			*/
			console.log('#3', [...candidateBorder]);
		}
		/*
			step #4 : check if candidates is actual border

			    v   v
			+---+---+---+
			| x | x | x |
			+---+---+---+ : border = 2
			| x | x | x |
			+---+---+---+

			        v
			+---+---+---+
			| x | x | x |
			+---+---+---+ : border = 1
			|   x   | x |
			+---+---+---+

			+---+---+---+
			| x |   x   |
			+---+---+---+ : border = 0
			|   x   | x |
			+---+---+---+
		*/
		const actualBorder = cRubiksCube.#makeGroupOnAxis_4_makeActualBorder(scalarMap, candidateBorder);
		if (this.#instanceTest.mode) {
			console.log('#4', [...actualBorder]);
		}
		/*
			step #5 : finally, make group which will move together
		*/
		const groups = cRubiksCube.#makeGroupOnAxis_5_makeActualBorder(scalarMap, actualBorder)
		if (this.#instanceTest.mode) {
			console.log('#5', [...groups]);
		}
		return groups;
	}
	makeRotationGroup(in_piece, in_axis) {
		const groups = this.#makeGroupOnAxis(in_axis);
		for (let i = 0; i < groups.length; i++) {
			if (groups[i].includes(in_piece)) {
				return groups[i];
			}
		}
		return null;
	}
	makeRandomRotationProgress(in_ending_callback) {
		let axis;
		let pieces;
		let maxLoopCount = 100;
		while (true) {
			if (--maxLoopCount === 0) {
				throw new Error('maxLoopCount'); 
			}
			const _piece = (this.children)[arrRand]();
			axis = (Object.values(cRubiksCube.#axes))[arrRand]();
			pieces = this.makeRotationGroup(_piece, axis);
			if (pieces.length < this.children.length) {
				break;
			}
		}
		let percentCurrent = 0;
		let sounded = false;
		const percentStep = 1 / 20;
		const group = this.#composeGroup(pieces);
		// this progress function assumes to be called by requestAnimationFrame()
		const progress = () => {
			percentCurrent += percentStep;
			group.rotation[cRubiksCube.#axisKey(axis)] = Math.PI / 2 * percentCurrent;
			if (percentCurrent >= 1) {
				group.rotation[cRubiksCube.#axisKey(axis)] = Math.PI / 2;
				this.#releaseGroup(group);
				(in_ending_callback)();
				this.#settingVal.shuffled = true;
			} else {
				if ((percentCurrent > 0.4) && !sounded) {
					AUDIO_ROTATION.play();
					sounded = true;
				}
			}
		};
		return progress;
	}
	registerCompleteCallback(in_callback) {
		this.#settingVal.completeCallback = in_callback;
	}
	removeCompleteCallback() {
		this.#settingVal.completeCallback = null;
	}
	static #getRotationAxis(in_surfaceV3, in_directionV3) {
		/*
			{surface : new THREE.Vector3(+1, 0, 0), direction : new THREE.Vector3(0, +1, 0), expected : new THREE.Vector3(0, 0, +1)},
			{surface : new THREE.Vector3(+1, 0, 0), direction : new THREE.Vector3(0, -1, 0), expected : new THREE.Vector3(0, 0, -1)},
			{surface : new THREE.Vector3(-1, 0, 0), direction : new THREE.Vector3(0, +1, 0), expected : new THREE.Vector3(0, 0, -1)},
			{surface : new THREE.Vector3(-1, 0, 0), direction : new THREE.Vector3(0, -1, 0), expected : new THREE.Vector3(0, 0, +1)},
			...
		*/
		const rotationAxis = new THREE.Vector3();
		rotationAxis.crossVectors(in_surfaceV3, in_directionV3);
		return rotationAxis;
	}
	static #detectMovingDirection(in_dstV3, in_srcV3, in_surfaceV3) {
		const vec3 = (new THREE.Vector3()).subVectors(in_dstV3, in_srcV3);
		const axes = [
			new THREE.Vector3(+1, 0, 0),
			new THREE.Vector3(-1, 0, 0),
			new THREE.Vector3(0, +1, 0),
			new THREE.Vector3(0, -1, 0),
			new THREE.Vector3(0, 0, +1),
			new THREE.Vector3(0, 0, -1)
		];
		const ret = {
			minAngle : Infinity,
			directionAxis : null,
			rotationAxis : null
		};
		axes.forEach(in_axis => {
			if (in_axis.dot(in_surfaceV3) !== 0) {
				// in_axis which is not the same as in_surfaceV3 will be taken for rotation
				return;
			}
			const angle = vec3.angleTo(in_axis);
			if (angle < ret.minAngle) {
				ret.minAngle = angle;
				ret.directionAxis = in_axis;
				// rotationAxis may have negative value as component
				ret.rotationAxis = cRubiksCube.#getRotationAxis(in_surfaceV3, in_axis);
			}
		});
		return ret;
	}
	static #uiStates  = {
		DISABLED : Symbol(),
		ENABLED : Symbol(),
		DRAGGING : Symbol(),
		MOVING : Symbol(),
		MOMENTUM : Symbol()
	}
	/*
		ENABLED <-------------------+
		|                           |
		+-[disable]-----+           |
		|               |           |
		|   DISABLED <--+           |
		|   |                       |
		|   +-[enable]--------------+
		|                           |
		+-[drag]--------+           |
		                |           |
		    DRAGGING <--+           |
		    |                       |
		    +-[release]-------------+
		    |                       |
		    +-[movable]-----+       |
		                    |       |
		        MOVING <----+       |
		        |                   |
		        +-[release]-----+   |
		                        |   |
		            MOMENTUM <--+   |
		            |               |
		            +-[stop]--------+
	*/
	static #uiTransitions = {
		[cRubiksCube.#uiStates.DISABLED]: {
			enable : cRubiksCube.#uiStates.ENABLED
		},
		[cRubiksCube.#uiStates.ENABLED]: {
			disable : cRubiksCube.#uiStates.DISABLED,
			drag : cRubiksCube.#uiStates.DRAGGING
		},
		[cRubiksCube.#uiStates.DRAGGING]: {
			release : cRubiksCube.#uiStates.ENABLED,
			movable : cRubiksCube.#uiStates.MOVING
		},
		[cRubiksCube.#uiStates.MOVING]: {
			release : cRubiksCube.#uiStates.MOMENTUM
		},
		[cRubiksCube.#uiStates.MOMENTUM]: {
			stop : cRubiksCube.#uiStates.ENABLED
		}
	};
	#uiSession = {
		state : cRubiksCube.#uiStates.ENABLED,
		ctx : {}
	};
	#transition(in_action) {
		const newState = cRubiksCube.#uiTransitions[this.#uiSession.state]?.[in_action];
		if (newState) {
			this.#uiSession.state = newState;
		} else {
			throw new Error('invalid transition : ' + in_action);
		}
	}
	uiEnable() {
		if (this.#uiSession.state !== cRubiksCube.#uiStates.DISABLED) {
			console.log('state is not DISABLED');
			return;
		}
		this.#transition('enable');
	}
	uiDisable() {
		if (this.#uiSession.state !== cRubiksCube.#uiStates.ENABLED) {
			console.log('state is not ENABLED');
			return;
		}
		this.#transition('disable');
	}
	#uiInitSession() {
		if (this.#uiSession.ctx.roGroup) {
			this.#releaseGroup(this.#uiSession.ctx.roGroup);
		}
		this.#uiSession.ctx = {};
	}
	uiSetInitPosition(in_piece, in_surfaceV3, in_posV3, in_posV2) {
		// in_posV3 : intersection with a in_piece
		// in_posV2 : NDC (Normalized Device Coordinates)
		if (this.#uiSession.state !== cRubiksCube.#uiStates.ENABLED) {
			console.log('state is not ENABLED');
			return;
		}
		this.#uiSession.ctx = {
			piece : in_piece,
			initPosV3 : in_posV3,
			initPosV2 : in_posV2,
			surfaceV3 : in_surfaceV3,
			roGroup : null,
			roRadian : 0,
			roAxisDir : 0,
			roAxisXYZ : null,
			initDirV2 : null
		};
		this.#transition('drag');
	}
	uiDeltaFromStartV2(in_posV2) {
		return in_posV2.distanceTo(this.#uiSession.ctx.initPosV2);
	}
	uiDeltaFromStartV3(in_posV3) {
		return in_posV3.distanceTo(this.#uiSession.ctx.initPosV3);
	}
	uiIsDragging() {
		return (this.#uiSession.state === cRubiksCube.#uiStates.DRAGGING);
	}
	uiIsMoving() {
		return (this.#uiSession.state === cRubiksCube.#uiStates.MOVING);
	}
	static uiSetDeltaPositionRC = {
		NOOP : Symbol(),
		// as delta is not enough, need to call uiNotifyDeltaPosition again
		NOTENOUGH : Symbol(),
		// though delta is enough, can't make group
		UNMOVABLE : Symbol(),
		// as delta is enough, can call uiUpdatePosition
		MOVABLE : Symbol()
	};
	uiNotifyDeltaPosition(in_piece, in_posV3, in_posV2) {
		// in_posV3 : intersection with a in_piece
		// in_posV2 : NDC (Normalized Device Coordinates)
		const RC = cRubiksCube.uiSetDeltaPositionRC;
		if (this.#uiSession.state !== cRubiksCube.#uiStates.DRAGGING) {
			console.log('state is not DRAGGING');
			return RC.NOOP;
		}
		const ctx = this.#uiSession.ctx;
		const moving = cRubiksCube.#detectMovingDirection(in_posV3, ctx.initPosV3, ctx.surfaceV3);
		const angle22_5 = Math.PI / 8;
		if (moving.minAngle > angle22_5) {
			return RC.NOTENOUGH;
		}
		// component for makeRotationGroup should be +1
		const axis = moving.rotationAxis.clone().multiply(moving.rotationAxis);
		const pieces = this.makeRotationGroup(ctx.piece, axis);
		if (pieces.length < this.children.length) {
			this.#transition('movable');
			ctx.roGroup = this.#composeGroup(pieces);
			// use Vector3(1, 1, 1) to extruct +1 or -1
			ctx.roAxisDir = moving.rotationAxis.dot(new THREE.Vector3(1, 1, 1));
			ctx.roAxisXYZ = cRubiksCube.#axisKey(axis);
			ctx.initDirV2 = in_posV2.clone().sub(ctx.initPosV2);
			return RC.MOVABLE;
		} else {
			return RC.UNMOVABLE;
		}
	}
	uiUpdatePosition(in_posV2) {
		// in_posV2 : NDC (Normalized Device Coordinates)
		if (this.#uiSession.state !== cRubiksCube.#uiStates.MOVING) {
			return;
		}
		const ctx = this.#uiSession.ctx;
		const currentDirV2 = in_posV2.clone().sub(ctx.initPosV2);
		let rad = in_posV2.distanceTo(ctx.initPosV2) * ctx.roAxisDir;
		if (ctx.initDirV2.dot(currentDirV2) > 0) {
			// currentDirV2 & initDirV2 --> SAME direction
			rad *= +1;
		} else {
			// currentDirV2 & initDirV2 --> OPPOSITE direction
			rad *= -1;
		}
		/*
			*** NOTE ***
			if using rotateOnAxis() several times, small errors will be expanded.
			if making group every time too, the same issue will happen.
		*/
		ctx.roGroup.rotation[ctx.roAxisXYZ] = rad;
		if (snapTo05PI(rad) != snapTo05PI(ctx.roRadian)) {
			AUDIO_ROTATION.play();
		}
		ctx.roRadian = rad;
	}
	uiRelease(in_ending_callback) {
		if (this.#uiSession.state === cRubiksCube.#uiStates.DRAGGING) {
			this.#uiInitSession();
			this.#transition('release');
			return null;
		}
		if (this.#uiSession.state !== cRubiksCube.#uiStates.MOVING) {
			return null;
		}
		this.#transition('release');
		const ctx = this.#uiSession.ctx;
		const startRad = ctx.roRadian;
		const finalRad = snapTo05PI(ctx.roRadian);
		const duration = 100;
		const ease = new cEase(startRad, finalRad, duration);
		// this progress function assumes to be called by requestAnimationFrame()
		const progress = () => {
			ctx.roRadian = ease.currentEasingIn();
			ctx.roGroup.rotation[ctx.roAxisXYZ] = ctx.roRadian;
			if (ctx.roRadian !== finalRad) {
				return;
			}
			// execute once at the end
			this.#uiInitSession();
			this.#transition('stop');
			(in_ending_callback)();
			if (!this.#settingVal.shuffled) {
				// when without shuffled, do nothing
				return;
			}
			this.#settingVal.rotationCount++;
			if (this.#settingVal.completeCallback && this.isComplete()) {
				(this.#settingVal.completeCallback)(this.#settingVal.rotationCount);
			}
		};
		return progress;
	}
}

function test_makeGroupOnAxis(in_arr) {
	const scalarMap = new cApproximateMap(cRubiksCube.err);
	in_arr.forEach(in_elem => {
		in_elem[0] += Math.random() / 10000;
		in_elem[1].edgeL += Math.random() / 10000;
		in_elem[1].edgeR += Math.random() / 10000;
		scalarMap.set(in_elem[0], in_elem[1]);
	});
	(new cRubiksCube()).unitTest('#makeGroupOnAxis', scalarMap);
}

/*
	--x-x---x-x-->

	+---+---+---+
	| x |   x   |
	+---+---+---+
	|   x   | x |
	+---+---+---+

test_makeGroupOnAxis([
	[ 3.0000, {edgeL : 1.0000, edgeR :  5.0000, pieces : ['a']}],
	[ 5.0000, {edgeL : 1.0000, edgeR :  9.0000, pieces : ['b']}],
	[ 9.0000, {edgeL : 5.0000, edgeR : 13.0000, pieces : ['c']}],
	[11.0000, {edgeL : 9.0000, edgeR : 13.0000, pieces : ['d']}]
]);

*/

/*
	--x-x-x-x-x-->

	+---+---+---+
	| x | x | x |
	+---+---+---+
	| x |   x   |
	+---+---+---+
	|   x   | x |
	+---+---+---+

test_makeGroupOnAxis([
	[ 3.0000, {edgeL : 1.0000, edgeR :  5.0000, pieces : ['a','b']}],
	[ 5.0000, {edgeL : 1.0000, edgeR :  9.0000, pieces : ['c']}],
	[ 7.0000, {edgeL : 5.0000, edgeR :  9.0000, pieces : ['d']}],
	[ 9.0000, {edgeL : 5.0000, edgeR : 13.0000, pieces : ['e']}],
	[11.0000, {edgeL : 9.0000, edgeR : 13.0000, pieces : ['f','g']}]
]);

*/

/*
	--x---x-x-x-x-x---x---x-->

	+---+---+---+---+---+---+
	| x | x | x | x | x | x |
	+---+---+---+---+---+---+
	| x |   x   | x | x | x |
	+---+---+---+---+---+---+
	| x |       x       | x |
	+---+---+---+---+---+---+

test_makeGroupOnAxis([
	[ 3.0000, {edgeL :  1.0000, edgeR :  5.0000, pieces : ['a','b','c']}],
	[ 7.0000, {edgeL :  5.0000, edgeR :  9.0000, pieces : ['d']}],
	[ 9.0000, {edgeL :  5.0000, edgeR : 13.0000, pieces : ['f']}],
	[11.0000, {edgeL :  9.0000, edgeR : 13.0000, pieces : ['g']}],
	[13.0000, {edgeL :  5.0000, edgeR : 21.0000, pieces : ['e']}],
	[15.0000, {edgeL : 13.0000, edgeR : 17.0000, pieces : ['h','i']}],
	[19.0000, {edgeL : 17.0000, edgeR : 21.0000, pieces : ['j','k']}],
	[23.0000, {edgeL : 21.0000, edgeR : 25.0000, pieces : ['l','m','n']}]
]);

*/

/*
	(6) ui & dom setting

	gWorld (cSphericalWorld)
	|
	+-- gCube (cRubiksCube)
		|
		+-- meshes <--- gMeshLevelMap
*/

const WORLD_RADIUS = CUBE_SIZE * 10;
const WORLD_INIT_ZOOM = WORLD_RADIUS / 3;

const gWorld = new cSphericalWorld(WORLD_RADIUS);

const gCube = new cRubiksCube();

gWorld.add(gCube);

gWorld.moveView(0.5, 0.5);
gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);

/*
	*** NOTE ***
	when you use AxesHelper,
	// gWorld.add(new THREE.AxesHelper(WORLD_RADIUS));
	gWorld.setZoom() can not work well.
*/

class cWarpLine {
	static #speed = 10;
	static #gradation = 10;
	constructor(in_canvas) {
		const w = in_canvas.width;
		const h = in_canvas.height;
		this.ctx = in_canvas.getContext('2d');
		this.box = new THREE.Box2(
			new THREE.Vector2(0, 0),
			new THREE.Vector2(w, h)
		);
		this.from = new THREE.Vector2(w / 2, h / 2);
		this.#reset();
	}
	#reset() {
		const angle = Math.random() * Math.PI * 2;
		this.direction = new THREE.Vector2(Math.cos(angle), Math.sin(angle));
		this.speed = Math.random() * cWarpLine.#speed + 5;
		this.length = 0;
	}
	#curVec(in_scalar) {
		return this.from.clone().add(this.direction.clone().multiplyScalar(in_scalar));
	}
	#drawGrayLine(in_from, in_to, in_grayScale) {
		const gray = (in_grayScale << 16) | (in_grayScale << 8) | in_grayScale;
		this.ctx.strokeStyle = '#' + gray.toString(16).padStart(6, '0');
		this.ctx.beginPath();
		this.ctx.moveTo(in_from.x, in_from.y);
		this.ctx.lineTo(in_to.x, in_to.y);
		this.ctx.stroke();
	}
	update() {
		this.length += this.speed;
		const to = this.#curVec(this.length);
		if (this.box.containsPoint(to)) {
			const notch = this.length / cWarpLine.#gradation;
			for (let i = 0; i < cWarpLine.#gradation; i++) {
				this.#drawGrayLine(
					this.#curVec(notch * i),
					this.#curVec(notch * (i + 1)),
					255 / cWarpLine.#gradation * (i + 1)
				);
			}
		} else {
			/*
				*** NOTE ***
				even if overwritung using black,
				this.#drawGrayLine(this.from, to, 0x00);
				smudge of white line will remain.
			*/
			this.#reset();
		}
	}
}

function warpViewProgress(in_canvas, in_lineCount) {
	const warpLines = [];
	for (let i = 0; i < in_lineCount; i++) {
		warpLines.push(new cWarpLine(in_canvas));
	}
	return () => {
		warpLines.forEach(in_line => {
			in_line.update();
		});
	}
}

function complete() {
	const progress = warpViewProgress(gBackgroundCanvas, 50);
	gWorld.addAnimationHook(progress);
	const duration = 2000;
	gWorld.motionZoom2(gWorld.zoomMin, duration * 0.9);
	window.setTimeout(() => {
		gWorld.removeAnimationHook(progress);
		gCube.removeCompleteCallback();
		const dialog = document.createElement('div');
		Object.assign(dialog.style, {
			width : 'auto',
			height : 'auto',
			background : 'black',
			borderRadius : '1em',
			padding : '1.5em'
		});
		([
			'<div>Congratulation !!</div>',
			'<div>( Your score is : ' + gCube.getScore() + ' )</div>',
			'<div>Thanks to your wisdom, peace in the universe has been preserved.</div>',
			'<div>Click to go next stage.</div>',
		]).forEach(in_fragment => {
			dialog.innerHTML += in_fragment;
		});
		setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white');
		startDialog(dialog, () => {
			drawCosmicView(gBackgroundCanvas, 400, 50);
			gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);
		});
		nextLevel(false);
	}, duration);
}

function shuffle(in_count) {
	const randomRotation = (in_remaining_count) => {
		const lastCallback = () => {
			gWorld.removeAnimationHook(progress);
			if (in_remaining_count > 1) {
				(randomRotation)(in_remaining_count - 1);
			} else {
				gWorld.stopRotation();
				gCube.uiEnable();
			}
		};
		const progress = gCube.makeRandomRotationProgress(lastCallback);
		gWorld.addAnimationHook(progress);
	};
	gCube.registerCompleteCallback(complete);
	gCube.uiDisable();
	gWorld.startRotation(VEC3().random().multiplyScalar(0.05));
	(randomRotation)(in_count);
}

function setTransition(in_elem, in_shorthand, in_val1, in_val2) {
	const components = in_shorthand.split(/\s+/);
	in_elem.style.transition = in_shorthand;
	in_elem.style[components[0]] = in_val1;
	window.setTimeout(() => {
		/*
			*** NOTE ***
			to fire the transition function,
			the final style should be set in the next event loop.
		*/
		in_elem.style[components[0]] = in_val2;
	}, 0);
}

function startDialog(in_element, in_callback = null) {
	const background = document.createElement('div');
	Object.assign(background.style, {
		position : 'fixed',
		left : '0px',
		top : '0px',
		width : '100%',
		height : '100%',
		zIndex : 2 ** 31 - 1
	});
	background.appendChild(in_element);
	Object.assign(in_element.style, {
		position : 'absolute',
		left : '50%',
		top : '50%',
		transform : 'translate(-50%, -50%)'
	});
	document.body.appendChild(background);
	const closeDialog = () => {
		document.body.removeChild(background);
		if (in_callback) {
			(in_callback)();
		}
	};
	background.addEventListener('mousedown', closeDialog);
	background.addEventListener('touchstart', closeDialog);
}

function shuffle3() {
	shuffle(3);
}

function shuffle10() {
	shuffle(10);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Rights</dt>',
		'<dd>This software is based on MIT License.</dd>',
		'<dd>The code can be freely modified and reused.</dd>',
		'<dd>For full license details, please refer to :</dd>',
		'<dd>https://opensource.org/licenses/MIT</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white')
	startDialog(dialog);
}

const ID_PREV_LEVEL = randomString();
const ID_NEXT_LEVEL = randomString();

function updateLevelText() {
	const prev = gMeshLevelMap.prevItemByOrder(gMeshCurrentLevel);
	const next = gMeshLevelMap.nextItemByOrder(gMeshCurrentLevel);
	document.getElementById(ID_PREV_LEVEL).innerText = prev.k;
	document.getElementById(ID_NEXT_LEVEL).innerText = next.k;
}

async function changeLevel(in_delta) {
	const color = 0x000000;
	await gWorld.motionFog(color, 0, 100);
	gMeshCurrentLevel = (gMeshCurrentLevel + in_delta + gMeshLevelMap.size) % gMeshLevelMap.size;
	gCube.removePieces();
	const current = gMeshLevelMap.currItemByOrder(gMeshCurrentLevel);
	gCube.addPieces(current.v);
	await gWorld.motionFog(color, 100, 0);
	updateLevelText();
}

function prevLevel(in_sound = true) {
	if (in_sound) {
		AUDIO_ROTATION.play();
	}
	changeLevel(-1);
}

function nextLevel(in_sound = true) {
	if (in_sound) {
		AUDIO_ROTATION.play();
	}
	changeLevel(+1);
}

(() => {
	const settings = [
		{
			id : ID_PREV_LEVEL,
			text : '(Prev)',
			func : prevLevel
		},
		{
			id : ID_NEXT_LEVEL,
			text : '(Next)',
			func : nextLevel
		},
		{
			text : 'Shuffle x3',
			func : shuffle3
		},
		{
			text : 'Shuffle x10',
			func : shuffle10
		},
		{
			text : 'Rights',
			func : uiRights
		}
	];
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	settings.forEach(in_setting => {
		let button = document.createElement('button');
		if (in_setting.id) {
			button.id = in_setting.id;
		}
		if (in_setting.text) {
			button.innerText = in_setting.text;
		}
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})();

changeLevel(0);

function hex2rgb(in_hex) {
	const mask = 0xFF;
	const r = (in_hex >> 16) & mask;
	const g = (in_hex >> 8) & mask;
	const b = in_hex & mask;
	return [r, g, b];
}

function drawCosmicView(in_canvas, in_stars, in_nebulae_patterns, in_color = 0x000064) {
	const ctx = in_canvas.getContext('2d');
	const w = in_canvas.width;
	const h = in_canvas.height;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	for (let i = 0; i < in_nebulae_patterns; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 100 + 50;
		const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
		const rgb = hex2rgb(in_color);
		gradient.addColorStop(0, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0.5)');
		gradient.addColorStop(1, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0)');
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = gradient;
		ctx.fill();
	}
	for (let i = 0; i < in_stars; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 1;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = 'white';
		ctx.fill();
	}
}

const gBackgroundCanvas = document.createElement('CANVAS');

Object.assign(gBackgroundCanvas.style, {
	position : 'absolute',
	left : 0,
	top : 0,
	zIndex : -1
});

document.addEventListener('DOMContentLoaded', (() => {
	let resizeWorld = (() => {
		gWorld.resize(
			window.innerWidth,
			window.innerHeight);
		gBackgroundCanvas.width = window.innerWidth;
		gBackgroundCanvas.height = window.innerHeight;
		drawCosmicView(gBackgroundCanvas, 400, 50);
	});
	let resizeTimeout = null;
	const debounce_delay = 300;
	window.addEventListener('resize', () => {
		if (resizeTimeout) {
			window.clearTimeout(resizeTimeout);
		}
		resizeTimeout = window.setTimeout(resizeWorld, debounce_delay);
	});
	(resizeWorld)();
	if (!document.body) {
		document.documentElement.appendChild(document.createElement('BODY'));
	}
	document.body.style.margin = '0';
	document.body.style.overflow = 'hidden';
	document.body.appendChild(gWorld.canvas);
	document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

/*
	(7) event handlers + emulation
*/

(() => {
	const once = (in_ev) => {
		(new Audio()).play();
		gWorld.canvas.removeEventListener('mousedown', once);
		console.log('sound effect for Safari');
	};
	gWorld.canvas.addEventListener('mousedown', once);
})();

gWorld.canvas.addEventListener('mousedown', async (in_ev) => {
	const vec2 = eventPos2RaycasterPos(in_ev);
	const vec2Scaled = vec2.clone().multiplyScalar(EVPOS_MULTIPLY_PARAM);
	let intersects = gWorld.intersectPositive(vec2);
	if (intersects.length > 0) {
		const matrix = (new THREE.Matrix3()).getNormalMatrix(intersects[0].object.matrixWorld);
		const normal = intersects[0].face.normal.clone().applyMatrix3(matrix).normalize();
		const snap = (in_err => {
			return (in_value, ...in_targets) => {
				let snapped = in_value;
				in_targets.forEach(in_target => {
					if (Math.abs(in_value - in_target) < in_err) {
						snapped = in_target;
					}
				});
				return snapped;
			};
		})(0.0001);
		XYZ.forEach(in_xyz => {
			normal[in_xyz] = snap(normal[in_xyz], -1, 0, +1);
		});
		gCube.uiSetInitPosition(intersects[0].object, normal, intersects[0].point, vec2Scaled);
	}
});

let canKnock = true;

gWorld.canvas.addEventListener('mousemove', async (in_ev) => {
	const vec2 = eventPos2RaycasterPos(in_ev);
	const vec2Scaled = vec2.clone().multiplyScalar(EVPOS_MULTIPLY_PARAM);
	if (gCube.uiIsMoving()) {
		gCube.uiUpdatePosition(vec2Scaled);
		return;
	}
	if (!gCube.uiIsDragging()) {
		return;
	}
	// to avoid frequent using of THREE.Raycaster, need to adjust
	const threshold = 0.1;
	if (gCube.uiDeltaFromStartV2(vec2) < threshold) {
		return;
	}
	let intersects = gWorld.intersectPositive(vec2);
	if (intersects.length === 0) {
		return;
	}
	const RC = cRubiksCube.uiSetDeltaPositionRC;
	const result = gCube.uiNotifyDeltaPosition(intersects[0].object, intersects[0].point, vec2Scaled);
	if (result === RC.UNMOVABLE) {
		if (!canKnock) {
			return;
		} else {
			canKnock = false;
		}
		AUDIO_ERROR.play();
		await gWorld.motionKnock();
		canKnock = true;
	}
});

async function dragstop() {
	const progress = gCube.uiRelease(() => {
		gWorld.removeAnimationHook(progress);
	});
	if (progress) {
		gWorld.addAnimationHook(progress);
	}
}

gWorld.canvas.addEventListener('mouseleave', dragstop);
gWorld.canvas.addEventListener('mouseout', dragstop);
gWorld.canvas.addEventListener('mouseup', dragstop);

</script>
</body>
</html>
