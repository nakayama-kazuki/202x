<body>
<script>

const arrRand = Symbol();

Object.defineProperty(Array.prototype, arrRand, {
	value : function () {
		return this[Math.floor(Math.random() * this.length)];
	},
	writable : true,
	configurable : true,
	enumerable : false
});

const arrTrim = Symbol();

Object.defineProperty(Array.prototype, arrTrim, {
	value : function (in_value) {
		let start = 0;
		let end = this.length;
		for (let i = 0; i < this.length; i++) {
			if (this[i] === in_value) {
				start++;
			} else {
				break;
			}
		}
		for (let i = this.length - 1; i >= start; i--) {
			if (this[i] === in_value) {
				end--;
			} else {
				break;
			}
		}
		return this.slice(start, end);
	},
	writable : true,
	configurable : true,
	enumerable : false
});

const sameValues = Symbol();

Object.defineProperty(Array.prototype, sameValues, {
	value : function (in_compare) {
		if (!Array.isArray(in_compare)) {
			return false;
		}
		// for only primitive value
		const sorted = in_arr => JSON.stringify([...in_arr].sort((a, b) => String(a).localeCompare(String(b))));
		return sorted(this) === sorted(in_compare);
	},
	writable : true,
	configurable : true,
	enumerable : false
});

class cLineParser {
	static #border = -1;
	static #empty = 9;
	static #cntEmpty(in_arr) {
		return in_arr.filter(in_el => in_el === cLineParser.#empty).length;
	}
	static #findOneInnerEmpty(in_arr) {
		let emptyAppear = false;
		for (let i = 1; i < in_arr.length - 1; i++) {
			if (emptyAppear) {
				if (in_arr[i] === cLineParser.#empty) {
					return false;
				} else {
					return true;
				}
			}
			if (in_arr[i] === cLineParser.#empty) {
				emptyAppear = true;
			}
		}
		return false;
	}
	/*
		fmt_eXXXXX is for edge
	*/
	static #fmt_eCriticalToMe(in_l, in_r) {
		// B90011 ---> [B9][11]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty)) {
			if (in_r[0] !== cLineParser.#empty) {
				return true;
			}
		}
		return false;
	}
	static #fmt_ePreRiskToMe(in_l, in_r) {
		// B90090 ---> [B9][9]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty)) {
			if ((in_r.length === 1) &&
				(in_r[0] === cLineParser.#empty)) {
				return true;
			}
		}
		return false;
	}
	static #fmt_ePressureToMe(in_l, in_r) {
		// B900191 ---> [B9][191]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border)) {
			return cLineParser.#fmt_bPressureToMe(in_l, in_r);
		}
		return false;
	}
	static #fmt_ePrePressureToMe(in_l, in_r) {
		// B909191 ---> [B9][9191]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border)) {
			return cLineParser.#fmt_bPrePressureToMe(in_l, in_r);
		}
		return false;
	}
	static #fmt_ePressureByMe(in_l, in_r) {
		// B911090 ---> [B911][9]
		if ((in_l.length >= 3) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty) &&
			(cLineParser.#cntEmpty(in_l) === 1)) {
			return cLineParser.#fmt_bPressureByMe(in_l, in_r);
		}
		return false;
	}
	/*
		fmt_bXXXXX is for both edge and inner
	*/
	static #fmt_bPressureToMe(in_l, in_r) {
		// 9900191 ---> [99][191]
		if (in_l[in_l.length - 1] === cLineParser.#empty) {
			if ((in_r.length >= 3) &&
				(in_r[0] !== cLineParser.#empty)) {
				return cLineParser.#findOneInnerEmpty(in_r);
			}
		}
		return false;
	}
	static #fmt_bPrePressureToMe(in_l, in_r) {
		// 9909191 ---> [99][9191]
		if (in_l[in_l.length - 1] === cLineParser.#empty) {
			if ((in_r.length >= 3) &&
				(in_r[0] === cLineParser.#empty)) {
				return cLineParser.#findOneInnerEmpty(in_r);
			}
		}
		return false;
	}
	static #fmt_bPressureByMe(in_l, in_r) {
		// 9911090 ---> [9911][9]
		if ((in_l[in_l.length - 1] !== cLineParser.#empty) &&
			(cLineParser.#cntEmpty(in_l) >= 1)) {
			if ((in_r.length === 1) &&
				(in_r[0] === cLineParser.#empty)) {
				return true;
			}
		}
		return false;
	}
	static #fmt_bInnerByMe(in_l, in_r) {
		// 110199 --> [11][199]
		if ((in_l[in_l.length - 1] === in_r[0]) &&
			(in_r[0] !== cLineParser.#empty)) {
			return true;
		}
		return false;
	}
	static parse(in_items, in_player, in_loop, in_debug = false) {
		const parsed = {
			eCriticalToMe : false,
			ePreRiskToMe : false,
			ePressureToMe : false,
			ePrePressureToMe : false,
			ePressureByMe : false,
			bFulfilledWith : false,
			bPressureToMe : false,
			bPrePressureToMe : false,
			bPressureByMe : false,
			bPreOuterByMe : false,
			bOuterByMe : false,
			bInnerByMe : false,
			safetyScore : 0
		};
		let items;
		if (in_loop) {
			items = [...in_items];
		} else {
			items = [cLineParser.#border, ...in_items, cLineParser.#border];
		}
		if (items.indexOf(in_player) === -1) {
			return parsed;
		}
		/*
			(1) as in_player should be exist from here, split array using in_player

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : [12],[34]
				ex2 (loop) : [12],[34],[]
				ex3 (loop) : [],[12],[34],[]

				ex1 (non-loop) : [B12],[45B]
				ex2 (non-loop) : [B12],[34],[B]
				ex3 (non-loop) : [B],[12],[34],[B]
		*/
		let meMaxIx = 0;
		let meStart = false;
		// the 1st item may be empty
		const subsets = [[]];
		parsed.bFulfilledWith = true;
		for (let i = 0; i < items.length; i++) {
			if (items[i] === in_player) {
				if (meStart) {
					continue;
				} else {
					meStart = true;
					// the last item may be empty
					subsets[++meMaxIx] = [];
				}
			} else {
				meStart = false;
				if (items[i] === cLineParser.#empty) {
					parsed.bFulfilledWith = false;
				}
				subsets[meMaxIx].push(items[i]);
			}
		}
		if (parsed.bFulfilledWith) {
			return parsed;
		}
		/*
			(2) relate left side / right side to in_player

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : L[12]+R[34]
				ex2 (loop) : L[12]+R[34], L[34]+R[]
				ex3 (loop) : L[]+R[12],L[12]+R[34],L[34]+R[]

				ex1 (non-loop) : L[B12]+R[45B]
				ex2 (non-loop) : L[B12]+R[34],L[34]+R[B]
				ex3 (non-loop) : L[B]+R[12],L[12]+R[34],L[34]+R[B]
		*/
		const meNodes = [];
		for (let i = 0; i < meMaxIx; i++) {
			meNodes[i] = {
				L : subsets[i],
				R : subsets[i + 1]
			};
		}
		/*
			(3) normalize

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : L[3412]+R[3412]
				ex2 (loop) : L[12]+R[34],L[34]+R[12]
				ex3 (loop) : L[34]+R[12],L[12]+R[34]

				ex1 (non-loop) : L[B12]+R[45B]
				ex2 (non-loop) : L[B12]+R[34],L[34]+R[B]
				ex3 (non-loop) : L[B]+R[12],L[12]+R[34],L[34]+R[B]
		*/
		const meFirst = meNodes[0];
		const meLast = meNodes[meNodes.length - 1];
		if (in_loop) {
			if ((meFirst.L.length === 0) && (meLast.R.length === 0)) {
				meFirst.L = [...meLast.L];
				meNodes.pop();
			} else {
				meFirst.L = [...meLast.R, ...meFirst.L];
				meLast.R = meFirst.L;
			}
		}
		/*
			(4) bPreOuterByMe, bOuterByMe
		*/
		if (in_loop) {
			for (let i = 0; i < meNodes.length; i++) {
				const cnt = cLineParser.#cntEmpty(meNodes[i].L);
				parsed['bPreOuterByMe'] ||= (cnt === 1);
				parsed['bOuterByMe'] ||= (cnt === 0);
			}
		} else {
			// except for both edges
			for (let i = 1; i < subsets.length - 1; i++) {
				const cnt = cLineParser.#cntEmpty(subsets[i]);
				parsed['bPreOuterByMe'] ||= (cnt === 1);
				parsed['bOuterByMe'] ||= (cnt === 0);
			}
		}
		/*
			(5) calculate score + check format
		*/
		const formatArr = [
			['eCriticalToMe', cLineParser.#fmt_eCriticalToMe],
			['ePreRiskToMe', cLineParser.#fmt_ePreRiskToMe],
			['ePressureToMe', cLineParser.#fmt_ePressureToMe],
			['ePrePressureToMe', cLineParser.#fmt_ePrePressureToMe],
			['ePressureByMe', cLineParser.#fmt_ePressureByMe],
			['bPressureToMe', cLineParser.#fmt_bPressureToMe],
			['bPrePressureToMe', cLineParser.#fmt_bPrePressureToMe],
			['bPressureByMe', cLineParser.#fmt_bPressureByMe],
			['bInnerByMe', cLineParser.#fmt_bInnerByMe]
		];
		for (let i = 0; i < meNodes.length; i++) {
			const curr = meNodes[i];
			const neighborL = curr.L[curr.L.length - 1];
			const neighborR = curr.R[0];
			if ((neighborL === neighborR) ||
				(neighborL === cLineParser.#border) ||
				(neighborR === cLineParser.#border)) {
				parsed.safetyScore += 1;
			} else {
				parsed.safetyScore -= 1;
			}
			const reversedR = curr.R.toReversed();
			const reversedL = curr.L.toReversed()
			formatArr.forEach(([in_format, in_checker]) => {
				if (parsed[in_format]) {
					return;
				}
				const toL = (in_checker)(curr.L, curr.R);
				const toR = (in_checker)(reversedR, reversedL);
				parsed[in_format] = toL || toR;
			});
		}
		return parsed;
	}
}

(in_test => {

if (!in_test) {
	return;
}

const suites = [

	{group : '*** 1. there is no pc ***'},

		{items : [9,9,9,9,9,9,9,9], loop : false, safetyScore : 0, dp : false},
		{items : [9,9,9,9,1,2,1,2], loop : false, safetyScore : 0, dp : false},
		{items : [1,2,1,2,1,2,1,2], loop : false, safetyScore : 0, dp : false},

		{items : [9,9,9,9,9,9,9,9], loop : true, safetyScore : 0, dp : false},
		{items : [9,9,9,9,1,2,1,2], loop : true, safetyScore : 0, dp : false},
		{items : [1,2,1,2,1,2,1,2], loop : true, safetyScore : 0, dp : false},

	{group : '*** 2. no empty ***'},

		{items : [0,0,0,0,0,0,0,0], loop : false, safetyScore : 0, dp : false},
		{items : [1,2,1,2,0,0,0,0], loop : false, safetyScore : 0, dp : false},

		{items : [0,0,0,0,0,0,0,0], loop : true, safetyScore : 0, dp : false},
		{items : [1,2,1,2,0,0,0,0], loop : true, safetyScore : 0, dp : false},

	{group : '*** 3. pc is on the left side ***'},

		{items : [0,9,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
		{items : [0,9,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},

		{items : [0,9,9,9,9,9,9,9], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,9], loop : true, safetyScore : -1, dp : false},
		{items : [0,9,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
		{items : [0,1,9,9,9,9,9,1], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,2], loop : true, safetyScore : -1, dp : false},

	{group : '*** 4. pc is on the right side ***'},

		{items : [9,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
		{items : [9,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},
		{items : [1,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
		{items : [1,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},

		{items : [9,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
		{items : [9,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,1,0], loop : true, safetyScore : 0, dp : false},
		{items : [2,0,9,9,9,9,1,0], loop : true, safetyScore : -2, dp : false},

	{group : '*** 5. pc is on the both sides ***'},

		{items : [0,9,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,1,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,9,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},

		{items : [0,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
		{items : [0,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : true, safetyScore : 1, dp : false},
		{items : [0,2,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},

	{group : '*** 6. npc is on the both sides ***'},

		{items : [1,9,9,9,9,9,9,1], loop : false, safetyScore : 0, dp : false},
		{items : [1,0,9,9,9,9,9,1], loop : false, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,0,1], loop : false, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,0,1], loop : false, safetyScore : -2, dp : false},

		{items : [1,9,9,9,9,9,9,1], loop : true, safetyScore : 0, dp : false},
		{items : [1,0,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,0,1], loop : true, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,0,1], loop : true, safetyScore : -2, dp : false},

	{group : '*** 7. bFulfilledWith ***'},

		{items : [1,1,1,1,1,1,1,1], loop : false, bFulfilledWith : false, dp : false},
		{items : [1,1,1,9,0,1,1,1], loop : false, bFulfilledWith : false, dp : false},
		{items : [1,1,1,0,0,1,1,1], loop : false, bFulfilledWith : true, dp : false},
		{items : [0,0,0,0,0,0,0,0], loop : false, bFulfilledWith : true, dp : false},
		{items : [0,0,0,9,0,0,0,0], loop : false, bFulfilledWith : false, dp : false},

		{items : [1,1,1,1,1,1,1,1], loop : true, bFulfilledWith : false, dp : false},
		{items : [1,1,1,9,0,1,1,1], loop : true, bFulfilledWith : false, dp : false},
		{items : [1,1,1,0,0,1,1,1], loop : true, bFulfilledWith : true, dp : false},
		{items : [0,0,0,0,0,0,0,0], loop : true, bFulfilledWith : true, dp : false},
		{items : [0,0,0,9,0,0,0,0], loop : true, bFulfilledWith : false, dp : false},

	{group : '*** 8. bOuterByMe ***'},

		{items : [0,1,0,9,9,9,9,9], loop : false, bOuterByMe : true, dp : false},
		{items : [1,0,9,9,9,9,9,0], loop : false, bOuterByMe : false, dp : false},
		{items : [0,9,9,9,9,9,0,1], loop : false, bOuterByMe : false, dp : false},
		{items : [9,9,9,9,9,0,1,0], loop : false, bOuterByMe : true, dp : false},
		{items : [9,9,0,1,2,0,9,9], loop : false, bOuterByMe : true, dp : false},
		{items : [2,0,9,9,9,9,0,1], loop : false, bOuterByMe : false, dp : false},

		{items : [0,1,0,9,9,9,9,9], loop : true, bOuterByMe : true, dp : false},
		{items : [1,0,9,9,9,9,9,0], loop : true, bOuterByMe : true, dp : false},
		{items : [0,9,9,9,9,9,0,1], loop : true, bOuterByMe : true, dp : false},
		{items : [9,9,9,9,9,0,1,0], loop : true, bOuterByMe : true, dp : false},
		{items : [9,9,0,1,2,0,9,9], loop : true, bOuterByMe : true, dp : false},
		{items : [2,0,9,9,9,9,0,1], loop : true, bOuterByMe : true, dp : false},

	{group : '*** 9. bPreOuterByMe ***'},

		{items : [9,0,9,9,9,9,9,0], loop : false, bPreOuterByMe : false, dp : false},
		{items : [0,9,0,9,9,9,9,9], loop : false, bPreOuterByMe : true, dp : false},
		{items : [9,0,9,0,9,9,9,9], loop : false, bPreOuterByMe : true, dp : false},
		{items : [9,0,1,0,9,9,9,9], loop : false, bPreOuterByMe : false, dp : false},
		{items : [9,0,9,9,0,9,9,9], loop : false, bPreOuterByMe : false, dp : false},

		{items : [9,0,9,9,9,9,9,0], loop : true, bPreOuterByMe : true, dp : false},

	{group : '*** 10. eCriticalToMe ***'},

		{items : [0,1,9,9,9,9,9,9], loop : false, eCriticalToMe : false, dp : false},
		{items : [9,0,1,9,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,1,0,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,1,2,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,9,1,9,9,9,9], loop : false, eCriticalToMe : false, dp : false},

		{items : [9,9,9,9,9,9,1,0], loop : false, eCriticalToMe : false, dp : false},
		{items : [9,9,9,9,9,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,0,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,2,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,1,9,0,9], loop : false, eCriticalToMe : false, dp : false},

	{group : '*** 11. ePreRiskToMe ***'},

		{items : [9,0,9,0,9,9,9,9], loop : false, ePreRiskToMe : true, dp : false},
		{items : [9,0,9,9,0,9,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,0,9,0,9,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,0,0,9,0,0,9,9], loop : false, ePreRiskToMe : true, dp : false},

		{items : [9,9,9,9,0,9,0,9], loop : false, ePreRiskToMe : true, dp : false},
		{items : [9,9,9,0,9,9,0,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,9,0,9,0,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,0,0,9,0,0,9], loop : false, ePreRiskToMe : true, dp : false},

	{group : '*** 12. ePressureToMe ***'},

		{items : [9,0,1,9,1,9,9,9], loop : false, ePressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : false, ePressureToMe : false, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : false, ePressureToMe : true, dp : false},
		{items : [9,0,1,9,1,9,9,9], loop : true, ePressureToMe : false, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : true, ePressureToMe : false, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : true, ePressureToMe : false, dp : false},

		{items : [9,9,1,9,1,0,9,9], loop : false, ePressureToMe : false, dp : false},
		{items : [9,1,9,1,1,0,0,9], loop : false, ePressureToMe : true, dp : false},

	{group : '*** 13. bPressureToMe ***'},

		{items : [9,0,1,9,1,9,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,0,1,9,1,9,9,9], loop : true, bPressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : true, bPressureToMe : true, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : true, bPressureToMe : true, dp : false},

		{items : [9,9,1,9,1,0,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,1,9,1,1,0,0,9], loop : false, bPressureToMe : true, dp : false},

	{group : '*** 14. ePrePressureToMe ***'},

		{items : [9,0,9,9,1,9,9,9], loop : false, ePrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : false, ePrePressureToMe : false, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : false, ePrePressureToMe : true, dp : false},
		{items : [9,0,9,9,1,9,9,9], loop : true, ePrePressureToMe : false, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : true, ePrePressureToMe : false, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : true, ePrePressureToMe : false, dp : false},

		{items : [9,9,1,9,9,0,9,9], loop : false, ePrePressureToMe : false, dp : false},
		{items : [9,1,9,1,9,0,0,9], loop : false, ePrePressureToMe : true, dp : false},

	{group : '*** 15. bPrePressureToMe ***'},

		{items : [9,0,9,9,1,9,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,0,9,9,1,9,9,9], loop : true, bPrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : true, bPrePressureToMe : true, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : true, bPrePressureToMe : true, dp : false},

		{items : [9,9,1,9,9,0,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,1,9,1,9,0,0,9], loop : false, bPrePressureToMe : true, dp : false},

	{group : '*** 16. ePressureByMe ***'},

		{items : [1,1,0,9,0,9,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,1,0,9,0,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,1,0,9,0,9,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,0,0,9,0,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : true, ePressureByMe : false, dp : false},

		{items : [9,9,9,0,9,0,1,1], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,0,9,0,1,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,9,0,9,0,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,0,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : true, ePressureByMe : false, dp : false},

	{group : '*** 17. bPressureByMe ***'},

		{items : [1,1,0,9,0,9,9,9], loop : false, bPressureByMe : false, dp : false},
		{items : [9,9,1,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,0,9,0,9,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,0,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : true, bPressureByMe : true, dp : false},

		{items : [9,9,9,0,9,0,1,1], loop : false, bPressureByMe : false, dp : false},
		{items : [9,9,0,9,0,1,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,9,0,9,0,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,0,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : true, bPressureByMe : true, dp : false},

	{group : '*** 18. bInnerByMe ***'},

		{items : [9,9,9,9,9,9,9,9], loop : false, bInnerByMe : false, dp : false},

		{items : [1,0,1,9,9,9,9,9], loop : false, bInnerByMe : true, dp : false},
		{items : [1,0,0,1,9,9,9,9], loop : false, bInnerByMe : true, dp : false},
		{items : [2,0,0,1,9,9,9,9], loop : false, bInnerByMe : false, dp : false},
		{items : [1,9,0,1,9,9,9,9], loop : false, bInnerByMe : false, dp : false},

		{items : [0,1,9,9,9,9,9,1], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,2,0], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,9], loop : false, bInnerByMe : false, dp : false},

		{items : [0,1,9,9,9,9,9,1], loop : true, bInnerByMe : true, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : true, bInnerByMe : true, dp : false},
		{items : [0,1,9,9,9,9,2,0], loop : true, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,9], loop : true, bInnerByMe : false, dp : false}
];
suites.forEach(in_suite => {
	if (in_suite.group) {
		console.log(in_suite.group);
	} else {
		const parsed = cLineParser.parse(in_suite.items, 0, in_suite.loop, in_suite.dp);
		Object.keys(parsed).forEach(in_prop => {
			if (!in_suite.hasOwnProperty(in_prop)) {
				return;
			}
			if (in_suite[in_prop] !== parsed[in_prop]) {
				const loop = in_suite.loop ? ' (loop)' : '';
				console.log('failed : ' + in_suite.items.join() + loop + ' is ' + parsed[in_prop]);
			}
		});
	}
});

})(false);

class cReversi {
	static #maximize(in_evaluator, in_player, in_candArr) {
		const evaluated = new Map();
		in_candArr.forEach(in_ix => evaluated.set(in_ix, (in_evaluator)(in_player, in_ix)));
		const max = {
			value : -Infinity,
			indexes : []
		};
		for (const [index, value] of evaluated.entries()) {
			if (value > max.value) {
				max.value = value;
				max.indexes = [index];
			} else {
				if (value === max.value) {
					max.indexes.push(index);
				}
			}
		}
		if (max.indexes.length === 0) {
			console.log(evaluated);
			throw new Error();
		}
		return max.indexes;
	}
	static #rotateArray(in_array, in_delta) {
		const len = in_array.length;
		const delta = ((in_delta % len) + len) % len;
		return in_array.slice(delta * -1).concat(in_array.slice(0, delta * -1));
	}
	static #dmz = 8;
	static #empty = 9;
	static #maxPlayers = 4;
	static #validData = (() => {
		const arr = [cReversi.#dmz, cReversi.#empty];
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			arr.push(player);
		}
		return arr;
	})();
	static #addUniqueSet(in_newSet, in_arr) {
		const duplicated = in_arr.some(in_addedSet => {
			if (in_newSet.size !== in_addedSet.size) {
				return false;
			}
			for (const item of in_newSet) {
				if (!in_addedSet.has(item)) {
					return false;
				}
			}
			return true;
		});
		if (!duplicated) {
			in_arr.push(in_newSet);
		}
	}
	static #dirStyle = {
		square : {
			onehand : {
				regular : [
					[-1, -1],
					[-1,  0],
					[-1, +1],
					[ 0, -1],
					[ 0, +1],
					[+1, -1],
					[+1,  0],
					[+1, +1]
				],
				offset : [
					[-1, -1],
					[-1,  0],
					[-1, +1],
					[ 0, -1],
					[ 0, +1],
					[+1, -1],
					[+1,  0],
					[+1, +1]
				]
			},
			pair : new Map([
				[  0, [1, 6]],
				[ 45, [2, 5]],
				[ 90, [3, 4]],
				[135, [0, 7]]
			])
		},
		hexPointyTopped : {
			onehand : {
				/*
					@@
					@+@
					@@
				*/
				regular : [
					[-1, -1],
					[-1,  0],
					[ 0, +1],
					[+1,  0],
					[+1, -1],
					[ 0, -1]
				],
				/*
					 @@
					@+@
					 @@
				*/
				offset : [
					[-1,  0],
					[-1, +1],
					[ 0, +1],
					[+1, +1],
					[+1,  0],
					[ 0, -1]
				]
			},
			pair : new Map([
				[ 30, [1, 4]],
				[ 90, [2, 5]],
				[150, [0, 3]]
			])
		},
		hexFlatTopped : {
			onehand : {
				/*
					@@@
					@+@
					 @
				*/
				regular : [
					[-1, -1],
					[-1,  0],
					[-1, +1],
					[ 0, +1],
					[+1,  0],
					[ 0, -1]
				],
				/*
					 @
					@+@
					@@@
				*/
				offset : [
					[ 0, -1],
					[-1,  0],
					[ 0, +1],
					[+1, +1],
					[+1,  0],
					[+1, -1]
				]
			},
			pair : new Map([
				[  0, [1, 4]],
				[ 60, [2, 5]],
				[120, [0, 3]]
			])
		}
	};
	#area = {
		items : [],
		options : new Set(),
		scores : {
			default : [],
			players : []
		}
	};
	#npcArgoPriority = [];
	#history = [];
	#conf = null;
	#rotations = null;
	#getDirections(in_row, in_col) {
		const dirStyle = this.#conf.dirStyle;
		let useOffset = false;
		if (dirStyle.pair.get(0)) {
			// square or hexFlatTopped
			useOffset = (in_col % 2 === this.#conf.offset);
		} else {
			// hexPointyTopped
			useOffset = (in_row % 2 === this.#conf.offset);
		}
		if (useOffset) {
			return dirStyle.onehand.offset;
		} else {
			return dirStyle.onehand.regular;
		}
	}
	#getDirection(in_row, in_col, in_dirIx) {
		return this.#getDirections(in_row, in_col)[in_dirIx];
	}
	#aroundIndexes(in_ix) {
		const pos = this.#indexToPos(in_ix);
		return this.#aroundPositions(pos.row, pos.col).map(([in_row, in_col]) => this.#posToIndex(in_row, in_col));
	}
	#aroundPositions(in_row, in_col) {
		const directions = this.#getDirections(in_row, in_col);
		const aroundPos = [];
		const sizeRow = this.#conf.row.size;
		const sizeCol = this.#conf.col.size;
		directions.forEach(([in_dr, in_dc]) => {
			let row = in_row + in_dr;
			let col = in_col + in_dc;
			if ((row < 0) || (sizeRow -1 < row)) {
				if (this.#conf.row.edge) {
					return;
				} else {
					row = (sizeRow + row) % sizeRow;
				}
			}
			if ((col < 0) || (sizeCol -1 < col)) {
				if (this.#conf.col.edge) {
					return;
				} else {
					col = (sizeCol + col) % sizeCol;
				}
			}
			aroundPos.push([row, col]);
		});
		return aroundPos;
	}
	#indexesUntil(in_indexes, in_item) {
		const toItem = in_indexes.findIndex(in_ix => this.#getItemByIndex(in_ix) === in_item);
		if (toItem < 0) {
			return in_indexes;
		} else {
			return in_indexes.slice(0, toItem);
		}
	}
	constructor(in_table, in_rowEdge, in_colEdge, in_format = 'square', in_offset = 1) {
		const sizeRow = in_table.length;
		const sizeCol = in_table.reduce((in_maxLen, in_row) => {
			return Math.max(in_maxLen, in_row.length);
		}, 0);
		if (cReversi.#dirStyle.hasOwnProperty(in_format)) {
			if (!in_rowEdge && (sizeRow % 2 === 1) && (in_format === 'hexPointyTopped')) {
				throw new Error('invalid rows (' + sizeRow + ') for row-loop of ' + in_format);
			}
			if (!in_colEdge && (sizeCol % 2 === 1) && (in_format === 'hexFlatTopped')) {
				throw new Error('invalid cols (' + sizeRow + ') for col-loop of ' + in_format);
			}
		} else {
			throw new Error('invalid input');
		}
		const dirStyle = cReversi.#dirStyle[in_format];
		this.#conf = {
			row : {
				size : sizeRow,
				edge : in_rowEdge
			},
			col : {
				size : sizeCol,
				edge : in_colEdge
			},
			dirStyle : dirStyle,
			// square can accommodate any offset
			offset : (in_offset % 2),
			rotatable : {
				fixedCol : !in_rowEdge && dirStyle.pair.has(0),
				fixedRow : !in_colEdge && dirStyle.pair.has(90)
			},
			tagIndexes : {
				radiating : [],
				edgeSetArr : [],
				cornerSet : new Set(),
				xInsideSet : new Set()
			}
		};
		this.setTable(in_table);
		this.#initTagIndexes();
		this.#initScore();
		const argoArr = ['safety', 'spiteful', 'balance', 'greedy', 'learner', 'classic', 'beginner', 'monkey'];
		for (let i = 0; i < argoArr.length; i++) {
			this.#npcArgoPriority.push((argoArr.slice(0, i + 1))[arrRand]());
		}
		this.#updateOptionsAll();
		// console.log(this.#conf.tagIndexes);
	}
	#initTagIndexesRadiating() {
		const tagIndexes = this.#conf.tagIndexes;
		for (let areaIx = 0; areaIx < this.#area.items.length; areaIx++) {
			const {row : initRow, col : initCol} = this.#indexToPos(areaIx);
			const radiating = tagIndexes.radiating[areaIx] = [];
			const dirStyle = this.#getDirections(initRow, initCol);
			for (let dirIx = 0; dirIx < dirStyle.length; dirIx++) {
				const towards = [];
				let currRow = initRow;
				let currCol = initCol;
				while (true) {
					const [dr, dc] = this.#getDirection(currRow, currCol, dirIx);
					currRow += dr;
					if (this.#conf.row.edge) {
						if ((currRow < 0) || (this.#conf.row.size - 1 < currRow)) {
							// out of range
							break;
						}
					} else {
						currRow = (currRow + this.#conf.row.size) % this.#conf.row.size;
						if ((currRow === initRow) && (dr !== 0)) {
							// cyclic
							break;
						}
					}
					currCol += dc;
					if (this.#conf.col.edge) {
						if ((currCol < 0) || (this.#conf.col.size - 1 < currCol)) {
							// out of range
							break;
						}
					} else {
						currCol = (currCol + this.#conf.col.size) % this.#conf.col.size;
						if ((currCol === initCol) && (dc !== 0)) {
							// cyclic
							break;
						}
					}
					towards.push(this.#posToIndex(currRow, currCol));
				}
				radiating.push(towards);
			}
		}
	}
	#initTagIndexes() {
		this.#initTagIndexesRadiating();
		const pairs = Array.from(this.#conf.dirStyle.pair.values());
		const edgeAdhocMinLength = 6;
		const tagIndexes = this.#conf.tagIndexes;
		for (let areaIx = 0; areaIx < this.#area.items.length; areaIx++) {
			if (this.#getItemByIndex(areaIx) === cReversi.#dmz) {
				continue;
			}
			const radiating = tagIndexes.radiating[areaIx];
			// (1) edgeSetArr
			pairs.forEach(([in_pos, in_neg]) => {
				const pos = this.#indexesUntil(radiating[in_pos], cReversi.#dmz);
				const neg = this.#indexesUntil(radiating[in_neg], cReversi.#dmz);
				const edgeSet = new Set([...pos, areaIx, ...neg]);
				if (edgeSet.size < edgeAdhocMinLength) {
					return;
				}
				const isEdge = Array.from(edgeSet).every(edgeIx => {
					const aroundArr = this.#aroundIndexes(edgeIx);
					if (aroundArr.length < pairs.length * 2) {
						return true;
					}
					return aroundArr.some(in_aroundIx => {
						return (this.#getItemByIndex(in_aroundIx) === cReversi.#dmz);
					});
				});
				if (isEdge) {
					cReversi.#addUniqueSet(edgeSet, tagIndexes.edgeSetArr);
				}
			});
			// (2) corner
			const isCorner = pairs.every(([in_pos, in_neg]) => {
				const P = radiating[in_pos];
				const N = radiating[in_neg];
				if ((P.length === 0) || (this.#getItemByIndex(P[0]) === cReversi.#dmz)) {
					return true;
				}
				if ((N.length === 0) || (this.#getItemByIndex(N[0]) === cReversi.#dmz)) {
					return true;
				}
				// both sides are available
				return false;
			});
			if (!isCorner) {
				continue;
			} else {
				tagIndexes.cornerSet.add(areaIx);
			}
			// (3) xInsideSet, when areaIx is corner
			const aroundArr = this.#aroundIndexes(areaIx);
			aroundArr.forEach(in_aroundIx => {
				const testArr = this.#aroundIndexes(in_aroundIx);
				if (testArr.length < pairs.length * 2) {
					return;
				}
				if (testArr.every(in_testIx => this.#getItemByIndex(in_testIx) === cReversi.#empty)) {
					tagIndexes.xInsideSet.add(in_aroundIx);
				}
			});
		}
	}
	#indexToPos(in_ix) {
		return {
			row : Math.floor(in_ix / this.#conf.col.size),
			col : in_ix % this.#conf.col.size
		};
	}
	#posToIndex(in_row, in_col) {
		return in_row * this.#conf.col.size + in_col;
	}
	#setItemByIndex(in_ix, in_item) {
		this.#area.items[in_ix] = in_item;
	}
	#setItemByPos(in_row, in_col, in_item) {
		this.#setItemByIndex(this.#posToIndex(in_row, in_col), in_item);
	}
	#getItemByIndex(in_ix) {
		return this.#area.items[in_ix];
	}
	#getItemByPos(in_row, in_col) {
		return this.#getItemByIndex(this.#posToIndex(in_row, in_col));
	}
	#items(in_indexes) {
		const items = [];
		in_indexes.forEach(in_ix => {
			items.push(this.#getItemByIndex(in_ix));
		});
		return items;
	}
	#rotateItems(in_indexes, in_delta) {
		const shifted = cReversi.#rotateArray(in_indexes, in_delta);
		const copy = [...this.#area.items];
		for (let i = 0; i < in_indexes.length; i++) {
			/*
				for example ...
				src = 5, 6, 7, 8
				dst = 8, 5, 6, 7
			*/
			this.#setItemByIndex(in_indexes[i], copy[shifted[i]]);
		}
	}
	#rotateSameRowItems(in_fixedRow, in_deltaCol) {
		const ix = this.#posToIndex(in_fixedRow, 0);
		const radiating = this.#conf.tagIndexes.radiating[ix];
		// in case of loop, forward and backward include the same indexes
		const [forward, backward] = this.#conf.dirStyle.pair.get(90);
		this.#rotateItems([ix, ...radiating[forward]], in_deltaCol);
	}
	#rotateSameColItems(in_fixedCol, in_deltaRow) {
		const ix = this.#posToIndex(0, in_fixedCol);
		const radiating = this.#conf.tagIndexes.radiating[ix];
		// in case of loop, forward and backward include the same indexes
		const [forward, backward] = this.#conf.dirStyle.pair.get(0);
		this.#rotateItems([ix, ...radiating[forward]], in_deltaRow);
	}
	#flip(in_player, in_ix, in_dryRun = false) {
		const radiating = this.#conf.tagIndexes.radiating[in_ix];
		let flipped = false;
		for (let i = 0; i < radiating.length; i++) {
			const towards = radiating[i];
			const ixArr = [];
			let enemyAppears = false;
			for (let j = 0; j < towards.length; j++) {
				const ix = towards[j];
				const item = this.#getItemByIndex(ix);
				if (item === in_player) {
					if (enemyAppears) {
						if (in_dryRun) {
							// the same as Array.some() for dry run
							return true;
						} else {
							flipped = true;
							ixArr.forEach(in_flipped_ix => this.#setItemByIndex(in_flipped_ix, in_player));
						}
					}
					break;
				} else {
					if ((item === cReversi.#dmz) || (item === cReversi.#empty)) {
						break;
					} else {
						ixArr.push(ix);
						enemyAppears = true;
					}
				}
			}
		}
		if (flipped) {
			this.#setItemByIndex(in_ix, in_player);
			this.#updateOptions(in_ix);
			this.#updateScore();
			return true;
		} else {
			return false;
		}
	}
	#tryRotation(in_player, in_action) {
		// step1 : find rows/cols where in_player owns at least one cell
		const rowSet = new Set();
		const colSet = new Set();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) !== in_player) {
				continue;
			}
			const col = ix % this.#conf.col.size;
			const row = (ix - col) / this.#conf.col.size;
			rowSet.add(row);
			colSet.add(col);
		}
		// step2 : test for in_action. this algorithm can be improved
		const setting = {
			'fixed-row-rotate' : {
				targetArr : Array.from(rowSet),
				rotateFunc : this.#rotateSameRowItems.bind(this),
				maxCnt : this.#conf.col.size
			},
			'fixed-col-rotate' : {
				targetArr : Array.from(colSet),
				rotateFunc : this.#rotateSameColItems.bind(this),
				maxCnt : this.#conf.row.size
			}
		}
		const {targetArr, rotateFunc, maxCnt} = setting[in_action];
		const result = {target : -1, delta : -1};
		const rollback = this.#createRollback();
		const rotated = targetArr.some(in_target => {
			result.target = in_target;
			let rest = maxCnt;
			while (--rest > 0) {
				// rotate +1 (maxCnt - 1) times
				(rotateFunc)(in_target, 1);
				const cand = this.#searchCandidates(in_player);
				if (cand.length > 0) {
					result.delta = maxCnt - rest;
					return true;
				}
			}
			(rollback)();
			return false;
		});
		if (rotated) {
			return result;
		} else {
			return null;
		}
	}
	#count(in_player) {
		const items = this.#area.items.filter(in_el => in_el === in_player);
		return items.length;
	}
	#emptyCnt() {
		return this.#count(cReversi.#empty);
	}
	#searchCandidates(in_player) {
		const candidates = [];
		const asDryRun = true;
		this.#area.options.forEach(in_empty_ix => {
			if (this.#flip(in_player, in_empty_ix, asDryRun)) {
				candidates.push(in_empty_ix);
			}
		});
		return candidates;
	}
	#updateOptions(in_ix) {
		const aroundArr = this.#aroundIndexes(in_ix);
		aroundArr.forEach(in_aroundIx => {
			if (this.#getItemByIndex(in_aroundIx) === cReversi.#empty) {
				this.#area.options.add(in_aroundIx);
			}
		});
		// in_ix should be new occupied position
		this.#area.options.delete(in_ix);
	}
	#updateOptionsAll() {
		this.#area.options.clear();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const item = this.#getItemByIndex(ix);
			if ((item === cReversi.#empty) || (item === cReversi.#dmz)) {
				continue;
			}
			this.#updateOptions(ix);
		}
	}
	#getAreaScore(in_player, in_ix) {
		return this.#area.scores.players[in_player][in_ix];
	}
	#initScore() {
		this.#initScore_forDefault();
		this.#initScore_forPlayers();
	}
	#initScore_forDefault() {
		const attenuation = 5;
		this.#area.scores.default = new Array(this.#area.items.length).fill(0);
		let loopCnt = 3;
		while (loopCnt-- > 0) {
			const buff = [];
			for (let areaIx = 0; areaIx < this.#area.items.length; areaIx++) {
				const aroundArr = this.#aroundIndexes(areaIx);
				let score = this.#conf.dirStyle.pair.size * 2 - aroundArr.length;
				aroundArr.forEach(in_aroundIx => {
					if (this.#area.items[in_aroundIx] === cReversi.#dmz) {
						score++;
					} else {
						// a cell adjacent to a high-score cell should have its score reduced
						score -= Math.floor(this.#area.scores.default[in_aroundIx] / attenuation);
					}
				});
				buff[areaIx] = score;
			}
			for (let areaIx = 0; areaIx < this.#area.scores.default.length; areaIx++) {
				this.#area.scores.default[areaIx] += buff[areaIx];
			}
		}
	}
	#initScore_forPlayers() {
		// each player has own score based on owned area
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			this.#area.scores.players[player] = [...this.#area.scores.default];
		}
	}
	#updateScore() {
		this.#updateScore_forPlayersCorner();
		this.#updateScore_forPlayersEdge();
	}
	#updateScore_forPlayersCorner() {
		for (const cornerIx of this.#conf.tagIndexes.cornerSet) {
			const owner = this.#getItemByIndex(cornerIx);
			if ((owner === cReversi.#empty) || (owner === cReversi.#dmz)) {
				return;
			}
			const aroundArr = this.#aroundIndexes(cornerIx);
			const newScore = this.#area.scores.default[cornerIx];
			aroundArr.forEach(in_aroundIx => this.#area.scores.players[owner][in_aroundIx] = newScore);
		}
	}
	#updateScore_forPlayersEdge() {
		const tagIndexes = this.#conf.tagIndexes;
		tagIndexes.edgeSetArr.forEach(in_edgeSet => {
			for (const edgeIx of in_edgeSet) {
				const owner = this.#getItemByIndex(edgeIx);
				if ((owner === cReversi.#dmz) || (owner === cReversi.#empty)) {
					// edge is not owned
					return;
				}
				const aroundArr = this.#aroundIndexes(edgeIx);
				aroundArr.forEach(in_aroundIx => {
					// edgeSetArr should be removed
					if (in_edgeSet.has(in_aroundIx)) {
						return;
					}
					// xInsideSet should be removed
					if (tagIndexes.xInsideSet.has(in_aroundIx)) {
						return;
					}
					for (let player = 0; player < cReversi.#maxPlayers; player++) {
						let update = this.#area.scores.default[in_aroundIx];
						if (player === owner) {
							update = this.#area.scores.default[edgeIx];
						}
						this.#area.scores.players[player][in_aroundIx] = update;
					}
				});
			}
		});
	}
	#createRollback() {
		const backup = {
			items : [...this.#area.items],
			options : [...this.#area.options],
			players : this.#area.scores.players.map(in_arr => [...in_arr]) 
		};
		return () => {
			const area = this.#area;
			area.items = [...backup.items];
			area.options = new Set(backup.options);
			area.scores.players = backup.players.map(in_arr => [...in_arr]);
		};
	}
	static #evaluateStats = {};
	#evaluate(in_player, in_ix) {
		const registerStats = in_key => {
			if (cReversi.#evaluateStats[in_key]) {
				cReversi.#evaluateStats[in_key]++;
			} else {
				cReversi.#evaluateStats[in_key] = 1;
			}
		};
		registerStats('total');
		const loop = !this.#conf.row.edge || !this.#conf.col.edge;
		/*
			1. e (= edge) : check if area of edge is safe
			2. x (= xInside) : check if xInside positions will be not changed
		*/
		const check = {
			e : {
				indexes : [],
				currItems : [],
				nextItems : [],
				currParsed : {},
				nextParsed : {}
			},
			x : {
				indexes : [],
				currItems : [],
				nextItems : [],
				increased : false
			}
		};
		const tagIndexes = this.#conf.tagIndexes;
		if (tagIndexes.cornerSet.has(in_ix)) {
			registerStats('corner');
			return +999;
		}
		const ixInEdge = tagIndexes.edgeSetArr.some(in_edgeSet => {
			if (in_edgeSet.has(in_ix)) {
				check.e.indexes = [...in_edgeSet];
				return true;
			} else {
				return false;
			}
		});
		if (loop) {
			if (!ixInEdge) {
				registerStats('inside & loop = without xInside');
				return 0;
			}
		} else {
			const riskCornerSet = new Set();
			for (const cornerIx of tagIndexes.cornerSet) {
				if (this.#getItemByIndex(cornerIx) === cReversi.#empty) {
					riskCornerSet.add(cornerIx);
				}
			}
			for (const xInsideIx of tagIndexes.xInsideSet) {
				const aroundArr = this.#aroundIndexes(xInsideIx);
				if (aroundArr.some(in_aroundIx => riskCornerSet.has(in_aroundIx))) {
					check.x.indexes.push(xInsideIx);
				}
			}
		}
		if (check.e.indexes.length > 0) {
			check.e.currItems = this.#items(check.e.indexes);
		}
		if (check.x.indexes.length > 0) {
			check.x.currItems = this.#items(check.x.indexes);
		}
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		if (check.e.indexes.length > 0) {
			check.e.nextItems = this.#items(check.e.indexes);
			check.e.currParsed = cLineParser.parse(check.e.currItems, in_player, loop);
			check.e.nextParsed = cLineParser.parse(check.e.nextItems, in_player, loop);
		}
		if (check.x.indexes.length > 0) {
			check.x.nextItems = this.#items(check.x.indexes);
			check.x.increased = !check.x.nextItems.every((in_item, in_ix) => in_item === check.x.currItems[in_ix]);
		}
		(rollback)();
		const priorityArr = [
			{format : 'eCriticalToMe', positive : false},
			{format : 'ePreRiskToMe', positive : false},
			{format : 'xInside', positive : false},
			{format : 'ePressureByMe', positive : true},
			{format : 'ePressureToMe', positive : false},
			{format : 'ePrePressureToMe', positive : false},
			{format : 'bFulfilledWith', positive : true},
			{format : 'bPressureByMe', positive : true},
			{format : 'bPressureToMe', positive : false},
			{format : 'bPrePressureToMe', positive : false},
			{format : 'bInnerByMe', positive : true},
			{format : 'bPreOuterByMe', positive : false},
			{format : 'safetyScore', positive : true},
			{format : 'bOuterByMe', positive : true}
		];
		const scale = 10;
		for (let i = 0; i < priorityArr.length; i++) {
			const {format, positive} = priorityArr[i];
			let score = ((priorityArr.length - i - 1) * scale + 1) * (positive ? +1 : -1);
			if (format === 'xInside') {
				// 1. special case (xInside)
				if (check.x.increased) {
					registerStats(format);
					return score;
				} else {
					continue;
				}
			}
			if (check.e.currParsed[format] === check.e.nextParsed[format]) {
				// 2. special case (bOuterByMe)
				if ((format === 'bOuterByMe') && (check.e.nextParsed[format])) {
					registerStats(format);
					return score;
				} else {
					continue;
				}
			} else {
				// 3. generic cases
				if (typeof check.e.nextParsed[format] === 'number') {
					const delta = check.e.nextParsed[format] - check.e.currParsed[format];
					registerStats(format);
					return (delta > 0) ? score * +1 : score * -1;
				} else {
					let statsKey;
					if (check.e.nextParsed[format]) {
						statsKey = format + '-false-to-true';
						score *= +1;
					} else {
						statsKey = format + '-true-to-false';
						score *= -1;
					}
					registerStats(statsKey);
					return score;
				}
			}
		}
		registerStats('can not evaluate');
		return 0;
	}
	#countNextEnemyOption(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const player = (in_player + 1 + cReversi.#maxPlayers) % cReversi.#maxPlayers;
		const count = this.#searchCandidates(player).length;
		(rollback)();
		return count;
	}
	#countNextOption(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const count = this.#searchCandidates(in_player).length;
		(rollback)();
		return count;
	}
	#countNextOwnedSafeArea(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		let count = 0;
		const findNeighbor = in_arr => {
			for (let i = 0; i < in_arr.length; i++) {
				const neighbor = this.#getItemByIndex(in_arr[i]);
				if (neighbor !== in_player) {
					return neighbor;
				}
			}
			return null;
		}
		const pairs = Array.from(this.#conf.dirStyle.pair.values());
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) !== in_player) {
				continue;
			}
			const radiating = this.#conf.tagIndexes.radiating[in_ix];
			const isSafe = pairs.every(([in_pos, in_neg])  => {
				const P = findNeighbor(radiating[in_pos]);
				const N = findNeighbor(radiating[in_neg]);
				// player reachs all the way to the board edge, or to the DMZ
				if ((P === null) || (P === cReversi.#dmz)) {
					return true;
				}
				if ((N === null) || (N === cReversi.#dmz)) {
					return true;
				}
				// both sides are bordered by the same object
				if (P === N) {
					return true;
				}
				return false;
			});
			count += isSafe ? 1 : 0;
		}
		(rollback)();
		return count;
	}
	#countNextOwnedArea(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const count = this.#count(in_player);
		(rollback)();
		return count;
	}
	#calculateNextScore(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		let score = 0;
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) === in_player) {
				score += this.#getAreaScore(in_player, ix);
			}
		}
		(rollback)();
		return score;
	}
	static #randomizeCnt = 5;
	#npc_min_enemy_option(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextEnemyOption(in_player, in_ix) * -1;
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_option(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOption(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_owned_safe_area(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOwnedSafeArea(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_owned_area(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOwnedArea(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_score_smart(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#getAreaScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_score_total(in_player, in_candArr) {
		const evaluator = (in_player, in_ix) => {
			return this.#calculateNextScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_score_spot(in_player, in_candArr) {
		const evaluator = (in_player, in_ix) => {
			return this.#getAreaScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_random(in_player, in_candArr) {
		return in_candArr[arrRand]();
	}
	#npcSet = {
		safety : this.#npc_max_owned_safe_area,
		spiteful : this.#npc_min_enemy_option,
		balance : this.#npc_max_option,
		greedy : this.#npc_max_owned_area,
		learner : this.#npc_score_smart,
		classic : this.#npc_score_total,
		beginner : this.#npc_score_spot,
		monkey : this.#npc_random
	}
	_simulation(in_repeat = 13) {
		const truncateDecimal = (in_value, in_digit) => {
			const order = 10 ** in_digit;
			return Math.floor(in_value * order) / order;
		};
		const test = (in_argoArr) => {
			let cnt = 100;
			while (true) {
				const resultArr = [];
				for (let i = 0; i < in_argoArr.length; i++) {
					resultArr[i] = this.playAutomatically(i, in_argoArr[i]);
				}
				if (resultArr.some(in_result => in_result)) {
					if (cnt-- === 0) {
						break;
					}
				} else {
					break;
				}
				// this.dp();
			}
			let max = -Infinity;
			let winner = -1;
			const cond = this.getCurrentCondition();
			for (let i = 0; i < cond.players.length; i++) {
				if (cond.players[i].score > max) {
					max = cond.players[i].score;
					winner = i;
				}
			}
			return winner;
		};
		const rollback = this.#createRollback();
		// start simulation
		const table = [];
		table.push(['(vs)', ...Object.keys(this.#npcSet)]);
		Object.keys(this.#npcSet).forEach(p1 => {
			const row = [p1];
			Object.keys(this.#npcSet).forEach(p2 => {
				const players = [p1, p2];
				if (p1 === p2) {
					row.push('-');
					return;
				}
				let cnt = in_repeat;
				let win = 0;
				while (true) {
					if (cnt-- > 0) {
						if (test(players) === 0) {
							win++;
						}
						this.#initScore();
						this.#history.length = 0;
						(rollback)();
					} else {
						break;
					}
				}
				row.push(truncateDecimal(win / in_repeat, 2));
				this.#initScore();
				this.#history.length = 0;
				(rollback)();
			});
			table.push(row);
		});
		const elem = (in_table => {
			const ret = document.createElement('TABLE');
			in_table.forEach(in_row => {
				const row = document.createElement('TR');
				in_row.forEach(in_cell => {
					const cell = document.createElement('TD');
					cell.innerText = in_cell;
					let color = 'eeeeee';
					if (typeof in_cell === 'boolean') {
						if (in_cell) {
							color = 'ccccff';
						} else {
							color = 'ffcccc';
						}
					} else {
						if (typeof in_cell === 'number') {
							if (in_cell > 0.5) {
								color = 'ccccff';
							} else {
								color = 'ffcccc';
							}
						}
					}
					cell.style.backgroundColor = color;
					cell.style.textAlign = 'center';
					cell.style.border = '1px solid black';
					cell.style.padding = '3px';
					cell.style.width = '5em';
					row.appendChild(cell);
				});
				ret.appendChild(row);
			});
			ret.style.borderCollapse = 'collapse';
			return ret;
		})(table);
		const script = document.currentScript;
		script.parentNode.insertBefore(elem, script.nextSibling);
		let total = 1;
		Object.keys(cReversi.#evaluateStats).forEach(in_key => {
			if (in_key === 'total') {
				total = cReversi.#evaluateStats[in_key];
				return;
			}
			const taking = truncateDecimal(cReversi.#evaluateStats[in_key] / total, 4);
			console.log(in_key + ' : ' + taking);
		});
	}
	_snapshot() {
		const bg = new Map([
			[0, 'red'],
			[1, 'blue'],
			[2, 'green'],
			[3, 'yellow'],
			[cReversi.#empty, 'silver']
		]);
		const rightMargin = 10;
		const cellSize = 20;
		const cellMargin = 5;
		for (let row = 0; row < this.#conf.row.size; row++) {
			for (let col = 0; col < this.#conf.col.size; col++) {
				const color = bg.get(this.#getItemByPos(row, col));
				const id = '_' + row + 'x' + col;
				let cell = document.getElementById(id);
				if (cell) {
					cell.style.backgroundColor = color;
					continue;
				} else {
					cell = document.createElement('DIV');
				}
				let l = rightMargin + (cellSize + cellMargin) * col;
				let t = rightMargin + (cellSize + cellMargin) * row;
				const pair = this.#conf.dirStyle.pair;
				if (pair.has(90) && !pair.has(0)) {
					l += (row % 2 === this.#conf.offset ? (cellSize + cellMargin) / 2 : 0);
				}
				if (!pair.has(90) && pair.has(0)) {
					t += (col % 2 === this.#conf.offset ? (cellSize + cellMargin) / 2 : 0);
				}
				Object.assign(cell.style, {
					id : id,
					width : cellSize + 'px',
					height : cellSize + 'px',
					backgroundColor : color,
					border : 'solid gray 1px',
					position : 'absolute',
					left : l + 'px',
					top : t + 'px'
				});
				document.body.appendChild(cell);
			}
		}
	}
	_debug(in_stop = true) {
		const sources = {
			default : this.#area.scores.default,
			occupied : this.#area.items
		};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			sources['p-' + player] = this.#area.scores.players[player];
		}
		Object.keys(sources).forEach(in_key => {
			console.log('*** ' + in_key + ' ***');
			const data = sources[in_key];
			for (let row = 0; row < this.#conf.row.size; row++) {
				const items = [];
				for (let col = 0; col < this.#conf.col.size; col++) {
					const ix = this.#posToIndex(row, col);
					items.push(data[ix]);
				}
				console.log(items);
			}
		});
		if (in_stop) {
			throw new Error();
		}
	}
	playResetTable(in_player, in_action, in_table) {
		this.setTable(in_table);
		this.#history.push({
			who : in_player,
			action : in_action,
			row : -1,
			col : -1,
			delta : -1
		});
		this.#updateOptionsAll();
		this.#updateScore();
	}
	playSetPosition(in_player, in_row, in_col) {
		const ix = this.#posToIndex(in_row, in_col);
		if (this.#getItemByIndex(ix) !== cReversi.#empty) {
			return false;
		}
		const flipped = this.#flip(in_player, ix);
		if (flipped) {
			this.#history.push({
				who : in_player,
				action : 'choose-item',
				row : in_row,
				col : in_col,
				delta : -1
			});
		}
		return flipped;
	}
	playAutomatically(in_player, in_argo = null) {
		let npcAlive = false;
		let playerCnt = 0;
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			if (this.#area.items.indexOf(player) >= 0) {
				playerCnt++;
				if (player === in_player) {
					npcAlive = true;
				}
			}
		}
		if (npcAlive) {
			if (playerCnt === 1) {
				// only in_player
				return false;
			}
		} else {
			// in_player is died
			return false;
		}
		if (this.#area.items.indexOf(cReversi.#empty) === -1) {
			// fulfilled
			return false;
		}
		let npcArgo;
		if (in_argo) {
			npcArgo = in_argo;
		} else {
			npcArgo = this.#npcArgoPriority[in_player];
		}
		// console.log(in_player, npcAlive, playerCnt, npcArgo);
		const candidates = this.#searchCandidates(in_player);
		if (candidates.length > 0) {
			const ix = (this.#npcSet[npcArgo].bind(this))(in_player, candidates);
			this.#flip(in_player, ix);
			const pos = this.#indexToPos(ix);
			this.#history.push({
				who : in_player,
				action : 'choose-item',
				row : pos.row,
				col : pos.col,
				delta : -1
			});
			return true;
		} else {
			let action, result = null;
			if (!result && this.#conf.rotatable.fixedCol) {
				action = 'fixed-col-rotate';
				result = this.#tryRotation(in_player, action);
			}
			if (!result && this.#conf.rotatable.fixedRow) {
				action = 'fixed-row-rotate';
				result = this.#tryRotation(in_player, action);
			}
			if (result) {
				this.#history.push({
					who : in_player,
					action : action,
					row : (action === 'fixed-row-rotate' ? result.target : -1),
					col : (action === 'fixed-col-rotate' ? result.target : -1),
					delta : result.delta
				});
				this.#updateOptionsAll();
				this.#updateScore();
				return true;
			} else {
				// can not do anything
				return false;
			}
		}
	}
	rotatableFixedCol() {
		return this.#conf.rotatable.fixedCol;
	}
	rotatableFixedRol() {
		return this.#conf.rotatable.fixedRow;
	}
	getLast(in_conditions = {}) {
		// in_conditions : {who, action, row, col, delta}
		for (let i = this.#history.length - 1; i >= 0; i--) {
			const last = this.#history[i];
			if (Object.keys(in_conditions).some(in_key => in_conditions[in_key] !== last[in_key])) {
				continue;
			} else {
				return last;
			}
		}
		return null;
	}
	getTable() {
		const table = [];
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const pos = this.#indexToPos(ix);
			if (!table[pos.row]) {
				table[pos.row] = [];
			}
			table[pos.row][pos.col] = parseInt(this.#getItemByIndex(ix));
		}
		return table;
	}
	setTable(in_table) {
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const item = in_table[row][col];
				if (cReversi.#validData.indexOf(item) < 0) {
					throw new Error('invalid input');
				} else {
					this.#setItemByPos(row, col, item);
				}
			}
		}
	}
	getCurrentCondition() {
		const condition = {
			finished : false,
			players : []
		};
		const canRotate = this.#conf.rotatable.fixedCol || this.#conf.rotatable.fixedRow;
		const cnt = {
			activePlayer : 0,
			frozenPlayer : 0
		};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			let score, dead, frozen;
			score = this.#count(player);
			dead = (score === 0);
			if (dead) {
				frozen = true;
			} else {
				const candidates = (this.#searchCandidates(player)).length;
				if ((candidates > 0) || canRotate) {
					cnt.activePlayer++;
					frozen = false;
				} else {
					cnt.frozenPlayer++;
					frozen = true;
				}
			}
			condition.players[player] = {score : score, dead : dead, frozen : frozen};
		}
		condition.finished =
			// only 1 player is active
			(cnt.activePlayer + cnt.frozenPlayer === 1) ||
			// all players are frozen
			(cnt.activePlayer === 0) ||
			// there is no emply
			(this.#emptyCnt() === 0);
		return condition;
	}
}

const TABLE = [
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 0, 1, 9, 9, 9],
	[9, 9, 9, 1, 0, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9]
];

let SIMULATION = false;
SIMULATION = true;

if (SIMULATION) {
	const game = new cReversi(TABLE, true, true);
	console.time('_simulation');
	game._simulation();
	console.timeEnd('_simulation');
}

let ONEBYONE = false;
//ONEBYONE = true;

if (ONEBYONE) {
//	const game = new cReversi(TABLE, true, true);
//	const game = new cReversi(TABLE, true, true, 'hexFlatTopped', 0);
//	const game = new cReversi(TABLE, true, true, 'hexFlatTopped', 1);
	const game = new cReversi(TABLE, true, true, 'hexPointyTopped', 0);
//	const game = new cReversi(TABLE, true, true, 'hexPointyTopped', 1);

	let turnCnt = 40;
	const ms = 1000;
	turnProc = () => {
		const player = turnCnt % 2;
		game.playAutomatically(player);
		game._snapshot();
		if (turnCnt-- > 0) {
			setTimeout(turnProc, ms);
		} else {
			console.log(game.getCurrentCondition());
		}
	};
	(turnProc)();
}

</script>
</body>

