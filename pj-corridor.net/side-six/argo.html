<body>
<script>

const arrRand = Symbol();
Array.prototype[arrRand] = function() {
	return this[Math.floor(Math.random() * this.length)];
};

const arrTrim = Symbol();
Array.prototype[arrTrim] = function(in_value) {
	let start = 0;
	let end = this.length;
	for (let i = 0; i < this.length; i++) {
		if (this[i] === in_value) {
			start++;
		} else {
			break;
		}
	}
	for (let i = this.length - 1; i >= start; i--) {
		if (this[i] === in_value) {
			end--;
		} else {
			break;
		}
	}
	return this.slice(start, end);
};

class cLineParser {
	static #empty = 9;
	static #findHighRisk(in_playerNodes) {
		/*
			L : |9,0,0,0,1  ---> [9], [1,x,x]
			R :  1,0,0,0,9| ---> [x,x,1], [9]
		*/
		const playerL = in_playerNodes[0];
		const playerR = in_playerNodes[in_playerNodes.length - 1];
		if ((playerL.L.length === 1) &&
			(playerL.L[0] === cLineParser.#empty)) {
			if ((playerL.R.length > 0) &&
				(playerL.R[0] !== cLineParser.#empty)) {
				return true;
			}
		}
		if ((playerR.R.length === 1) &&
			(playerR.R[0] === cLineParser.#empty)) {
			if ((playerR.L.length > 0) &&
				(playerR.L[playerR.L.length - 1] !== cLineParser.#empty)) {
				return true;
			}
		}
		return false;
	};
	static #findPressureFormat(in_playerNodes) {
		/*
			L : |9,1,1,1,0,9,0  ---> [9,1,1,1], [9]
			R :  0,9,0,1,1,1,9| ---> [9], [1,1,1,9]
		*/
		const playerL = in_playerNodes[0];
		const playerR = in_playerNodes[in_playerNodes.length - 1];
		if ((playerL.R.length === 1) &&
			(playerL.R[0] === cLineParser.#empty)) {
			if ((playerL.L.length > 1) &&
				(playerL.L[0] === cLineParser.#empty)) {
				if (playerL.L.filter(in_item => in_item === cLineParser.#empty).length === 1) {
					// only playerL.L[0]
					return true;
				}
			}
		}
		if ((playerR.L.length === 1) &&
			(playerR.L[0] === cLineParser.#empty)) {
			if ((playerR.R.length > 1) &&
				(playerR.R[playerR.R.length - 1] === cLineParser.#empty)) {
				if (playerR.R.filter(in_item => in_item === cLineParser.#empty).length === 1) {
					// only playerR.R[playerR.R.length - 1]
					return true;
				}
			}
		}
		return false;
	}
	static parse(in_items, in_player, in_loop, in_debug = false) {
		const parsed = {
			fulfilledWithMe : true,
			highriskForMe : false,
			pressuredByMe : false,
			safetyScore : 0
		};
		/*
			(1) split array using in_player
		*/
		if (in_items.indexOf(in_player) === -1) {
			parsed.fulfilledWithMe = false;
			return parsed;
		}
		let playerCnt = 0;
		let playerZone = false;
		const subsets = [[]];
		for (let i = 0; i < in_items.length; i++) {
			if (in_items[i] === in_player) {
				if (playerZone) {
					continue;
				}
				playerZone = true;
				subsets[++playerCnt] = [];
			} else {
				if (in_items[i] === cLineParser.#empty) {
					parsed.fulfilledWithMe = false;
				}
				playerZone = false;
				subsets[playerCnt].push(in_items[i]);
			}
		}
		/*
			(2) relate left side / right side to in_player
		*/
		const playerNodes = [];
		for (let i = 0; i < playerCnt; i++) {
			let L = subsets[i];
			let R = subsets[i + 1];
			playerNodes[i] = {L : L, R : R};
		}
		/*
			(3) in case of loop / non-loop
		*/
		const playerL = playerNodes[0];
		const playerR = playerNodes[playerCnt - 1];
		if (in_loop) {
			if ((playerL.L.length > 0) || (playerR.R.length > 0)) {
				playerL.L = [...playerR.R, ...playerL.L];
				playerR.R = playerL.L;
			} else {
				playerL.L = playerR.L;
				playerNodes.pop();
			}
		} else {
			parsed.highriskForMe = cLineParser.#findHighRisk(playerNodes);
			parsed.pressuredByMe = cLineParser.#findPressureFormat(playerNodes);
		}
		/*
			(4) calculate score
		*/
		let safe = 0;
		let risk = 0;
		if (!parsed.fulfilledWithMe) {
			playerNodes.forEach(in_node => {
				const L = in_node.L.length > 0 ? in_node.L[in_node.L.length - 1] : -1;
				const R = in_node.R.length > 0 ? in_node.R[0] : -1;
				if ((L === R) || (L < 0) || (R < 0)) {
					safe++;
				} else {
					risk++;
				}
			});
		}
		parsed.safetyScore = safe - risk;
		if (in_debug) {
			console.log(playerNodes, parsed);
		}
		return parsed;
	}
	static test() {
		const suites = [
			{group : '*** 1. there is no pc ***'},

				{items : [9,9,9,9,9,9,9,9], loop : false, safetyScore : 0, dp : false},
				{items : [9,9,9,9,1,2,1,2], loop : false, safetyScore : 0, dp : false},
				{items : [1,2,1,2,1,2,1,2], loop : false, safetyScore : 0, dp : false},

				{items : [9,9,9,9,9,9,9,9], loop : true, safetyScore : 0, dp : false},
				{items : [9,9,9,9,1,2,1,2], loop : true, safetyScore : 0, dp : false},
				{items : [1,2,1,2,1,2,1,2], loop : true, safetyScore : 0, dp : false},

			{group : '*** 2. no empty ***'},

				{items : [0,0,0,0,0,0,0,0], loop : false, safetyScore : 0, dp : false},
				{items : [1,2,1,2,0,0,0,0], loop : false, safetyScore : 0, dp : false},

				{items : [0,0,0,0,0,0,0,0], loop : true, safetyScore : 0, dp : false},
				{items : [1,2,1,2,0,0,0,0], loop : true, safetyScore : 0, dp : false},

			{group : '*** 3. pc is on the left side ***'},

				{items : [0,9,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
				{items : [0,1,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
				{items : [0,9,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},
				{items : [0,1,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},

				{items : [0,9,9,9,9,9,9,9], loop : true, safetyScore : 1, dp : false},
				{items : [0,1,9,9,9,9,9,9], loop : true, safetyScore : -1, dp : false},
				{items : [0,9,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
				{items : [0,1,9,9,9,9,9,1], loop : true, safetyScore : 1, dp : false},
				{items : [0,1,9,9,9,9,9,2], loop : true, safetyScore : -1, dp : false},

			{group : '*** 4. pc is on the right side ***'},

				{items : [9,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
				{items : [9,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},
				{items : [1,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
				{items : [1,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},

				{items : [9,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
				{items : [9,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
				{items : [1,9,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
				{items : [1,0,9,9,9,9,1,0], loop : true, safetyScore : 0, dp : false},
				{items : [2,0,9,9,9,9,1,0], loop : true, safetyScore : -2, dp : false},

			{group : '*** 5. pc is on the both sides ***'},

				{items : [0,9,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
				{items : [0,1,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
				{items : [0,9,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},
				{items : [0,1,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},

				{items : [0,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
				{items : [0,1,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
				{items : [0,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
				{items : [0,1,9,9,9,9,1,0], loop : true, safetyScore : 1, dp : false},
				{items : [0,2,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},

			{group : '*** 6. npc is on the both sides ***'},

				{items : [1,9,9,9,9,9,9,1], loop : false, safetyScore : 0, dp : false},
				{items : [1,0,9,9,9,9,9,1], loop : false, safetyScore : -1, dp : false},
				{items : [1,9,9,9,9,9,0,1], loop : false, safetyScore : -1, dp : false},
				{items : [1,0,9,9,9,9,0,1], loop : false, safetyScore : -2, dp : false},

				{items : [1,9,9,9,9,9,9,1], loop : true, safetyScore : 0, dp : false},
				{items : [1,0,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
				{items : [1,9,9,9,9,9,0,1], loop : true, safetyScore : -1, dp : false},
				{items : [1,0,9,9,9,9,0,1], loop : true, safetyScore : -2, dp : false},

			{group : '*** 7. fulfilledWithMe ***'},

				{items : [1,1,1,1,1,1,1,1], loop : false, fulfilledWithMe : false, dp : false},
				{items : [1,1,1,9,0,1,1,1], loop : false, fulfilledWithMe : false, dp : false},
				{items : [1,1,1,0,0,1,1,1], loop : false, fulfilledWithMe : true, dp : false},
				{items : [0,0,0,0,0,0,0,0], loop : false, fulfilledWithMe : true, dp : false},
				{items : [0,0,0,9,0,0,0,0], loop : false, fulfilledWithMe : false, dp : false},

				{items : [1,1,1,1,1,1,1,1], loop : true, fulfilledWithMe : false, dp : false},
				{items : [1,1,1,9,0,1,1,1], loop : true, fulfilledWithMe : false, dp : false},
				{items : [1,1,1,0,0,1,1,1], loop : true, fulfilledWithMe : true, dp : false},
				{items : [0,0,0,0,0,0,0,0], loop : true, fulfilledWithMe : true, dp : false},
				{items : [0,0,0,9,0,0,0,0], loop : true, fulfilledWithMe : false, dp : false},

			{group : '*** 8. highriskForMe ***'},

				{items : [0,1,9,9,9,9,9,9], loop : false, highriskForMe : false, dp : false},
				{items : [9,0,1,9,9,9,9,9], loop : false, highriskForMe : true, dp : false},
				{items : [9,0,1,0,9,9,9,9], loop : false, highriskForMe : true, dp : false},
				{items : [9,0,1,2,9,9,9,9], loop : false, highriskForMe : true, dp : false},
				{items : [9,0,9,1,9,9,9,9], loop : false, highriskForMe : false, dp : false},

				{items : [9,9,9,9,9,9,1,0], loop : false, highriskForMe : false, dp : false},
				{items : [9,9,9,9,9,1,0,9], loop : false, highriskForMe : true, dp : false},
				{items : [9,9,9,9,0,1,0,9], loop : false, highriskForMe : true, dp : false},
				{items : [9,9,9,9,2,1,0,9], loop : false, highriskForMe : true, dp : false},
				{items : [9,9,9,9,1,9,0,9], loop : false, highriskForMe : false, dp : false},

			{group : '*** 9. pressuredByMe ***'},

				{items : [9,1,0,9,0,9,9,9], loop : false, pressuredByMe : true, dp : false},
				{items : [9,1,0,0,9,0,9,9], loop : false, pressuredByMe : true, dp : false},
				{items : [9,1,1,0,9,0,9,9], loop : false, pressuredByMe : true, dp : false},
				{items : [9,9,9,0,9,0,1,9], loop : false, pressuredByMe : true, dp : false},
				{items : [9,9,0,9,0,0,1,9], loop : false, pressuredByMe : true, dp : false},
				{items : [9,9,0,9,0,1,1,9], loop : false, pressuredByMe : true, dp : false}
		];
		suites.forEach(in_suite => {
			if (in_suite.group) {
				console.log(in_suite.group);
			} else {
				const parsed = cLineParser.parse(in_suite.items, 0, in_suite.loop, in_suite.dp);
				Object.keys(parsed).forEach(in_prop => {
					if (!in_suite.hasOwnProperty(in_prop)) {
						return;
					}
					if (in_suite[in_prop] !== parsed[in_prop]) {
						const loop = in_suite.loop ? ' (loop)' : '';
						console.log('failed : ' + in_suite.items.join() + loop + ' is ' + parsed[in_prop]);
					}
				});
			}
		});
	}
}

class cReversi {
	static #maximize(in_evaluator, in_player, in_candArr) {
		const evaluated = new Map();
		in_candArr.forEach(in_ix => evaluated.set(in_ix, (in_evaluator)(in_player, in_ix)));
		const max = {
			value : -Infinity,
			indexes : []
		};
		for (const [index, value] of evaluated.entries()) {
			if (value > max.value) {
				max.value = value;
				max.indexes = [index];
			} else {
				if (value === max.value) {
					max.indexes.push(index);
				}
			}
		}
		if (max.indexes.length === 0) {
			console.log(evaluated);
			throw new Error();
		}
		return max.indexes;
	}
	static #rotateArray(in_array, in_delta) {
		const len = in_array.length;
		const delta = ((in_delta % len) + len) % len;
		return in_array.slice(delta * -1).concat(in_array.slice(0, delta * -1));
	}
	static #dmz = 8;
	static #empty = 9;
	static #maxPlayers = 4;
	static #validData = (() => {
		const arr = [cReversi.#dmz, cReversi.#empty];
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			arr.push(player);
		}
		return arr;
	})();
	static #directions = [
		[-1, -1],
		[-1,  0],
		[-1, +1],
		[ 0, -1],
		[ 0, +1],
		[+1, -1],
		[+1,  0],
		[+1, +1]
	];
	static #priorityTop = +99;
	static #priorityLast = -99;
	static #ignore = Symbol();
	#area = {
		items : [],
		options : new Set(),
		scores : {
			default : [],
			players : []
		}
	};
	#npcArgoPriority = [];
	#history = [];
	#conf = null;
	#rotations = null;
	constructor(in_table, in_rowEdge, in_colEdge) {
		const sizeRow = in_table.length;
		const sizeCol = in_table.reduce((in_maxLen, in_row) => {
			return Math.max(in_maxLen, in_row.length);
		}, 0);
		this.#conf = {
			row : {
				size : sizeRow,
				edge : in_rowEdge
			},
			col : {
				size : sizeCol,
				edge : in_colEdge
			},
			corners : {
				angle000 : {
					pos : {
						row : 0,
						col : 0
					},
					dirRow : +1,
					dirCol : +1
				},
				angle090 : {
					pos : {
						row : 0,
						col : sizeCol - 1
					},
					dirRow : +1,
					dirCol : -1
				},
				angle180 : {
					pos : {
						row : sizeRow - 1,
						col : sizeCol - 1
					},
					dirRow : -1,
					dirCol : -1
				},
				angle270 : {
					pos : {
						row : sizeRow - 1,
						col : 0
					},
					dirRow : -1,
					dirCol : +1
				}
			},
			indexes : {
				corner : [],
				xSquare : [],
				sameRow : [],
				sameCol : [],
				radiating : []
			}
		};
		this.setTable(in_table);
		this.#initAreaScores();
		Object.keys(this.#conf.corners).forEach(in_angleKey => {
			const angle = this.#conf.corners[in_angleKey];
			this.#conf.indexes.corner.push(this.#posToIndex(
				angle.pos.row,
				angle.pos.col
			));
			// xSquare is neighbor to the corner on the diagonal
			this.#conf.indexes.xSquare.push(this.#posToIndex(
				angle.pos.row + angle.dirRow,
				angle.pos.col + angle.dirCol
			));
		});
		for (let row = 0; row < sizeRow; row++) {
			this.#conf.indexes.sameRow[row] = [];
			for (let col = 0; col < sizeCol; col++) {
				this.#conf.indexes.sameRow[row].push(this.#posToIndex(row, col));
			}
		}
		for (let col = 0; col < sizeCol; col++) {
			this.#conf.indexes.sameCol[col] = [];
			for (let row = 0; row < sizeRow; row++) {
				this.#conf.indexes.sameCol[col].push(this.#posToIndex(row, col));
			}
		}
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const {row : initRow, col : initCol} = this.#indexToPos(ix);
			const radiating = this.#conf.indexes.radiating[ix] = [];
			for (let dir = 0; dir < cReversi.#directions.length; dir++) {
				const [dr, dc] = cReversi.#directions[dir];
				const towards = [];
				let currRow = initRow;
				let currCol = initCol;
				while (true) {
					currRow += dr;
					if (in_rowEdge) {
						if ((currRow < 0) || (sizeRow - 1 < currRow)) {
							// out of range
							break;
						}
					} else {
						currRow = (currRow + sizeRow) % sizeRow;
						if ((currRow === initRow) && (dr !== 0)) {
							// cyclic
							break;
						}
					}
					currCol += dc;
					if (in_colEdge) {
						if ((currCol < 0) || (sizeCol - 1 < currCol)) {
							// out of range
							break;
						}
					} else {
						currCol = (currCol + sizeCol) % sizeCol;
						if ((currCol === initCol) && (dc !== 0)) {
							// cyclic
							break;
						}
					}
					towards.push(this.#posToIndex(currRow, currCol));
				}
				if (towards.length > 0) {
					radiating.push(towards);
				}
			}
		}
		const argoArr = ['balance', 'spiteful', 'greedy', 'learner', 'classic', 'beginner', 'monkey'];
		for (let i = 0; i < argoArr.length; i++) {
			this.#npcArgoPriority.push((argoArr.slice(0, i + 1))[arrRand]());
		}
		this.#updateOptionsAll();
	}
	#updateOptions(in_ix) {
		const radiating = this.#conf.indexes.radiating[in_ix];
		radiating.forEach(in_towards => {
			const aroundIx = in_towards[0];
			if (this.#getItemByIndex(aroundIx) === cReversi.#empty) {
				this.#area.options.add(aroundIx);
			}
		});
		// in_ix should be new occupied position
		this.#area.options.delete(in_ix);
	}
	#updateOptionsAll() {
		this.#area.options.clear();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) === cReversi.#empty) {
				continue;
			}
			this.#updateOptions(ix);
		}
	}
	#createRollback() {
		const backup = {
			items : [...this.#area.items],
			options : [...this.#area.options]
		};
		return () => {
			this.#area.items = [...backup.items];
			this.#area.options = new Set(backup.options);
		};
	}
	#indexToPos(in_ix) {
		return {
			row : Math.floor(in_ix / this.#conf.col.size),
			col : in_ix % this.#conf.col.size
		};
	}
	#posToIndex(in_row, in_col) {
		return in_row * this.#conf.col.size + in_col;
	}
	#setItemByIndex(in_ix, in_item) {
		this.#area.items[in_ix] = in_item;
	}
	#setItemByPos(in_row, in_col, in_item) {
		this.#setItemByIndex(this.#posToIndex(in_row, in_col), in_item);
	}
	#getItemByIndex(in_ix) {
		return this.#area.items[in_ix];
	}
	#getItemByPos(in_row, in_col) {
		return this.#getItemByIndex(this.#posToIndex(in_row, in_col));
	}
	#items(in_indexes) {
		const items = [];
		in_indexes.forEach(in_ix => {
			items.push(this.#getItemByIndex(in_ix));
		});
		return items;
	}
	#rotateItems(in_indexes, in_delta) {
		const shifted = cReversi.#rotateArray(in_indexes, in_delta);
		const copy = [...this.#area.items];
		for (let i = 0; i < in_indexes.length; i++) {
			/*
				for example ...
				src = 5, 6, 7, 8
				dst = 8, 5, 6, 7
			*/
			this.#setItemByIndex(in_indexes[i], copy[shifted[i]]);
		}
	}
	#rotateSameRowItems(in_targetRow, in_deltaCol) {
		const sameRowIndexes = this.#conf.indexes.sameRow[in_targetRow];
		this.#rotateItems(sameRowIndexes, in_deltaCol);
	}
	#rotateSameColItems(in_targetCol, in_deltaRow) {
		const sameColIndexes = this.#conf.indexes.sameCol[in_targetCol];
		this.#rotateItems(sameColIndexes, in_deltaRow);
	}
	#flip(in_player, in_ix, in_test = false) {
		const radiating = this.#conf.indexes.radiating[in_ix];
		let flipped = false;
		for (let i = 0; i < radiating.length; i++) {
			const towards = radiating[i];
			const ixArr = [];
			let enemyAppears = false;
			for (let j = 0; j < towards.length; j++) {
				const ix = towards[j];
				const item = this.#getItemByIndex(ix);
				if (item === in_player) {
					if (enemyAppears) {
						if (in_test) {
							return true;
						} else {
							flipped = true;
							ixArr.forEach(in_flipped_ix => this.#setItemByIndex(in_flipped_ix, in_player));
						}
					}
					break;
				} else {
					if ((item === cReversi.#dmz) || (item === cReversi.#empty)) {
						break;
					} else {
						ixArr.push(ix);
						enemyAppears = true;
					}
				}
			}
		}
		if (flipped) {
			this.#setItemByIndex(in_ix, in_player);
			this.#updateOptions(in_ix);
			return true;
		} else {
			return false;
		}
	}
	#flippable(in_player, in_ix) {
		const isTest = true;
		return this.#flip(in_player, in_ix, isTest);
	}
	#choose(in_player, in_ix) {
		// in_ix must be choosable
		this.#flip(in_player, in_ix);
		this.#updatePlayersAreaScores(in_player, in_ix);
		const pos = this.#indexToPos(in_ix);
		this.#history.push({
			who : in_player,
			action : 'choose-item',
			row : pos.row,
			col : pos.col,
			target : -1,
			delta : -1
		});
		// this._debug();
	}
	#npcTryRotate(in_player, in_dir) {
		const rowSet = new Set();
		const colSet = new Set();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) !== in_player) {
				continue;
			}
			const col = ix % this.#conf.col.size;
			const row = (ix - col) / this.#conf.col.size;
			rowSet.add(row);
			colSet.add(col);
		}
		const setting = {
			row : {
				action : 'npc-col-wise-rotate',
				targetArr : Array.from(rowSet),
				rotateFunc : this.#rotateSameRowItems.bind(this),
				maxCnt : this.#conf.col.size
			},
			col : {
				action : 'npc-row-wise-rotate',
				targetArr : Array.from(colSet),
				rotateFunc : this.#rotateSameColItems.bind(this),
				maxCnt : this.#conf.row.size
			}
		}
		// this algorithm can be improved
		const {action, targetArr, rotateFunc, maxCnt} = setting[in_dir];
		let target, delta;
		const rollback = this.#createRollback();
		let rotated = targetArr.some(in_target => {
			target = in_target;
			let rest = maxCnt;
			while (--rest > 0) {
				// rotate +1 (maxCnt - 1) times
				(rotateFunc)(in_target, 1);
				const cand = this.#searchCandidates(in_player);
				if (cand.length > 0) {
					delta = maxCnt - rest;
					return true;
				}
			}
			(rollback)();
			return false;
		});
		if (rotated) {
			this.#updateOptionsAll();
			this.#history.push({
				who : in_player,
				action : action,
				row : -1,
				col : -1,
				target : target,
				delta : delta
			});
		}
		return rotated;
	}
	#phase() {
		const total = this.#conf.row.size * this.#conf.col.size;
		const remaining = this.#area.items.filter(in_el => in_el === cReversi.#empty).length;
		// from 0.0x (!= 0) to 1
		return 1 - remaining / total;
	}
	#searchCandidates(in_player) {
		const candidates = [];
		this.#area.options.forEach(in_empty_ix => {
			if (this.#flippable(in_player, in_empty_ix)) {
				candidates.push(in_empty_ix);
			}
		});
		return candidates;
	}
	#getAreaScore(in_player, in_ix) {
		return this.#area.scores.players[in_player][in_ix];
	}
	#updateScoresByAngle(io_areaScores, in_format, in_angleKey) {
		const angle = this.#conf.corners[in_angleKey];
		for (let i = 0; i < in_format.length; i++) {
			for (let j = 0; j < in_format[i].length; j++) {
				if (in_format[i][j] === cReversi.#ignore) {
					continue;
				}
				const row = angle.pos.row + i * angle.dirRow;
				const col = angle.pos.col + j * angle.dirCol;
				io_areaScores[this.#posToIndex(row, col)] = in_format[i][j];
			}
		}
	}
	#initAreaScores() {
		// default
		this.#area.scores.default = new Array(this.#conf.row.size * this.#conf.col.size).fill(-1);
		this.#initDefaultAreaScores();
		// players
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			this.#area.scores.players[player] = [...this.#area.scores.default];
		}
	}
	#initDefaultAreaScores() {
		if (this.#conf.row.edge) {
			if (this.#conf.col.edge) {
				this.#initDefaultAreaScoresEx2();
			} else {
				this.#initDefaultAreaScoresEx1();
			}
		} else {
			if (this.#conf.col.edge) {
				this.#initDefaultAreaScoresEx1();
			} else {
				this.#initDefaultAreaScoresEx0();
			}
		}
	}
	#updatePlayersAreaScores(in_player, in_ix) {
		if (this.#conf.row.edge) {
			if (this.#conf.col.edge) {
				this.#updatePlayersAreaScoresEx2(in_player, in_ix);
			} else {
				this.#updatePlayersAreaScoresEx1(in_player, in_ix);
			}
		} else {
			if (this.#conf.col.edge) {
				this.#updatePlayersAreaScoresEx1(in_player, in_ix);
			} else {
				this.#updatePlayersAreaScoresEx0(in_player, in_ix);
			}
		}
	}
	#initDefaultAreaScoresEx2() {
		const newScore = [
			[+35,  -4, +2, +1],
			[ -4, -10, -2,  0],
			[ +2,  -2,  1, -1],
			[ +1,   0, -1, -1],
		];
		const size = Math.min(newScore.length, Math.floor(Math.min(this.#conf.row.size, this.#conf.col.size) / 2));
		const format = newScore.slice(0, size).map(in_row => in_row.slice(0, size));
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle000');
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle090');
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle180');
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle270');
	}
	#updatePlayersAreaScoresEx2(in_player, in_ix) {
		const newScore = +4;
		const pos = this.#indexToPos(in_ix);
		const angleKey = Object.keys(this.#conf.corners).find(in_angleKey => {
			const corner = this.#conf.corners[in_angleKey].pos;
			return ((corner.row === pos.row) && (corner.col === pos.col));
		});
		if (!angleKey) {
			// in_ix is not on the corner
			return;
		}
		const format = [];
		const size = Math.min(this.#conf.row.size, this.#conf.col.size);
		for (let row = 0; row < size; row++) {
			format[row] = new Array(size).fill(cReversi.#ignore);
			for (let col = 0; col < size; col++) {
				if ((row !== 0) && (col !== 0)) {
					continue;
				}
				const score = this.#area.scores.players[in_player][this.#posToIndex(row, col)];
				if (newScore > score) {
					format[row][col] = newScore;
				}
			}
		}
		format[1][1] = newScore;
		this.#updateScoresByAngle(this.#area.scores.players[in_player], format, angleKey);
	}
	#initDefaultAreaScoresEx1() {
		const newScore = [+4, -3, +2];
		let format = [];
		if (this.#conf.row.edge) {
			for (let row = 0; row < newScore.length; row++) {
				format[row] = new Array(this.#conf.col.size).fill(newScore[row]);
			}
		}
		if (this.#conf.col.edge) {
			for (let row = 0; row < this.#conf.row.size; row++) {
				format[row] = [...newScore];
			}
		}
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle000');
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle180');
	}
	#updatePlayersAreaScoresEx1(in_player, in_ix) {
		const newScore = +3;
		const pos = this.#indexToPos(in_ix);
		let edge, repl;
		const indexes = this.#conf.indexes;
		if (this.#conf.row.edge) {
			if (pos.row === 0) {
				edge = indexes.sameRow[pos.row];
				repl = indexes.sameRow[pos.row + 1];
			} else if (pos.row === this.#conf.row.size - 1) {
				edge = indexes.sameRow[pos.row];
				repl = indexes.sameRow[pos.row - 1];
			} else {
				// in_ix is not on the row-edge
				return;
			}
		}
		if (this.#conf.col.edge) {
			if (pos.col === 0) {
				edge = indexes.sameRow[pos.col];
				repl = indexes.sameRow[pos.col + 1];
			} else if (pos.col === this.#conf.col.size - 1) {
				edge = indexes.sameRow[pos.col];
				repl = indexes.sameRow[pos.col - 1];
			} else {
				// in_ix is not on the col-edge
				return;
			}
		}
		for (let i = 0; i < edge.length; i++) {
			const index = repl[i];
			const owner = this.#getItemByIndex(edge[i]);
			// 1. rollback to default
			for (let player = 0; player < cReversi.#maxPlayers; player++) {
				this.#area.scores.players[player][index] = this.#area.scores.default[index];
			}
			// 2. update for owner
			if (owner < cReversi.#maxPlayers) {
				this.#area.scores.players[owner][index] = newScore;
			}
		}
	}
	#initDefaultAreaScoresEx0() {
		return;
	}
	#updatePlayersAreaScoresEx0(in_player, in_ix) {
		return;
	}
	#evaluate(in_player, in_ix) {
		const pos = this.#indexToPos(in_ix);
		const corner_x4 = this.#conf.row.edge && this.#conf.col.edge;
		const ixIsEdge = in_dir => ((this.#conf[in_dir].edge) && ((pos[in_dir] === this.#conf[in_dir].size - 1) || (pos[in_dir] === 0)));
		const ixIsRowEdge = ixIsEdge('row');
		const ixIsColEdge = ixIsEdge('col');
		/*
			1. e (= edge) : check if area of edge is safe
			2. x (= xSquare) : check if xSquare positions will be not changed
		*/
		const would = {
			e : {
				indexes : null,
				currItems : [],
				nextItems : [],
				diff : {}
			},
			x : {
				indexes : null,
				currItems : [],
				nextItems : [],
				diff : false
			}
		};
		const indexes = this.#conf.indexes;
		if (ixIsRowEdge) {
			if (ixIsColEdge) {
				// on the corner
				return +1;
			} else {
				would.e.indexes = indexes.sameRow[pos.row];
			}
		} else {
			if (ixIsColEdge) {
				would.e.indexes = indexes.sameCol[pos.col];
			} else {
				// inside & without xSquare
				if (!corner_x4) {
					return 0;
				}
			}
		}
		if (corner_x4) {
			would.x.indexes = [];
			for (let i = 0; i < indexes.corner.length; i++) {
				if (indexes.corner[i] === in_player) {
					// does not need to check x
					continue;
				} else {
					would.x.indexes.push(indexes.xSquare[i]);
				}
			}
		}
		if (would.e.indexes) {
			would.e.currItems = this.#items(would.e.indexes);
		}
		if (would.x.indexes) {
			would.x.currItems = this.#items(would.x.indexes);
		}
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		if (would.e.indexes) {
			would.e.nextItems = this.#items(would.e.indexes);
			const curr = cLineParser.parse(would.e.currItems, in_player, !corner_x4);
			const next = cLineParser.parse(would.e.nextItems, in_player, !corner_x4);
			Object.keys(next).forEach(in_key => {
				if (curr[in_key] !== next[in_key]) {
					would.e.diff[in_key] = next[in_key];
				}
			});
		}
		if (would.x.indexes) {
			would.x.nextItems = this.#items(would.x.indexes);
			would.x.diff = !would.x.nextItems.every((in_item, in_ix) => in_item === would.x.currItems[in_ix]);
		}
		(rollback)();
		// 1. never take edge-highriskForMe
		if (would.e.diff.hasOwnProperty('highriskForMe') && would.e.diff['highriskForMe']) {
			return -1;
		}
		// 2. never take unsafe xSquare
		if (would.x.diff) {
			return -1;
		}
		// 3. take edge-fulfilledWithMe
		if (would.e.diff.hasOwnProperty('fulfilledWithMe') && would.e.diff['fulfilledWithMe']) {
			return +1;
		}
		// 4. take edge-pressuredByMe
		if (would.e.diff.hasOwnProperty('pressuredByMe')) {
			return would.e.diff['pressuredByMe'] ? +1 : -1;
		}
		// 5. maximize safetyScore
		if (would.e.diff.hasOwnProperty('safetyScore')) {
			return (would.e.diff['safetyScore'] > 0) ? +1 : -1;
		}
		return 0;
	}
	#countNextEnemyOption(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const player = (in_player + 1 + cReversi.#maxPlayers) % cReversi.#maxPlayers;
		const count = this.#searchCandidates(player).length;
		(rollback)();
		return count;
	}
	#countNextOwnedArea(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const count = this.#area.items.filter(in_item => in_item === in_player).length;
		(rollback)();
		return count;
	}
	#calculateNextScore(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		let score = 0;
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) === in_player) {
				score += this.#getAreaScore(in_player, ix);
			}
		}
		(rollback)();
		return score;
	}
	#npc_phased_tactics(in_player, in_candArr) {
		if (this.#phase() < 0.6) {
			this.#npc_min_enemy_option(in_player, in_candArr);
		} else {
			this.#npc_max_owned_area(in_player, in_candArr);
		}
	}
	#npc_min_enemy_option(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			const score = this.#getAreaScore(in_player, in_ix);
			switch (this.#evaluate(in_player, in_ix)) {
			case +1 :
				return score + cReversi.#priorityTop;
			case -1 :
				return score + cReversi.#priorityLast;
			case 0 :
			default :
				return score + this.#countNextEnemyOption(in_player, in_ix) * -1;
			}
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		if (candArr_2nd.length > 1) {
			const eval2nd = (in_player, in_ix) => {
				return this.#calculateNextScore(in_player, in_ix);
			};
			const candArr_3rd = cReversi.#maximize(eval2nd, in_player, candArr_2nd);
			this.#choose(in_player, candArr_3rd[arrRand]());
		} else {
			this.#choose(in_player, candArr_2nd[0]);
		}
	}
	#npc_max_owned_area(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			const score = this.#getAreaScore(in_player, in_ix);
			switch (this.#evaluate(in_player, in_ix)) {
			case +1 :
				return score + cReversi.#priorityTop;
			case -1 :
				return score + cReversi.#priorityLast;
			case 0 :
			default :
				return score + this.#countNextOwnedArea(in_player, in_ix);
			}
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		if (candArr_2nd.length > 1) {
			const eval2nd = (in_player, in_ix) => {
				return this.#calculateNextScore(in_player, in_ix);
			};
			const candArr_3rd = cReversi.#maximize(eval2nd, in_player, candArr_2nd);
			this.#choose(in_player, candArr_3rd[arrRand]());
		} else {
			this.#choose(in_player, candArr_2nd[0]);
		}
	}
	#npc_score_spot_smart(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			const score = this.#getAreaScore(in_player, in_ix);
			switch (this.#evaluate(in_player, in_ix)) {
			case +1 :
				return score + cReversi.#priorityTop;
			case -1 :
				return score + cReversi.#priorityLast;
			case 0 :
			default :
				return score;
			}
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		this.#choose(in_player, candArr_2nd[arrRand]());
	}
	#npc_score_total(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			return this.#calculateNextScore(in_player, in_ix);
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		this.#choose(in_player, candArr_2nd[arrRand]());
	}
	#npc_score_spot(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			return this.#getAreaScore(in_player, in_ix);
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		this.#choose(in_player, candArr_2nd[arrRand]());
	}
	#npc_random(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			return 0;
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		this.#choose(in_player, candArr_2nd[arrRand]());
	}
	#npcSet = {
		balance : this.#npc_phased_tactics,
		spiteful : this.#npc_min_enemy_option,
		greedy : this.#npc_max_owned_area,
		learner : this.#npc_score_spot_smart,
		classic : this.#npc_score_total,
		beginner : this.#npc_score_spot,
		monkey : this.#npc_random
	}
	_simulation(in_repeat = 100) {
		const test = (in_argoArr) => {
			let cnt = 100;
			while (true) {
				const resultArr = [];
				for (let i = 0; i < in_argoArr.length; i++) {
					resultArr[i] = this.npc(i, in_argoArr[i]);
				}
				if (resultArr.some(in_result => in_result)) {
					if (cnt-- === 0) {
						break;
					}
				} else {
					break;
				}
				// this.dp();
			}
			let max = -Infinity;
			let winner = -1;
			const cond = this.getCurrentCondition();
			for (let i = 0; i < cond.players.length; i++) {
				if (cond.players[i].score > max) {
					max = cond.players[i].score;
					winner = i;
				}
			}
			return winner;
		};
		const rollback = this.#createRollback();
		// start simulation
		const table = [];
		table.push(['(vs)', ...Object.keys(this.#npcSet)]);
		Object.keys(this.#npcSet).forEach(p1 => {
			const row = [p1];
			Object.keys(this.#npcSet).forEach(p2 => {
				const players = [p1, p2];
				if (p1 === p2) {
					row.push('-');
					return;
				}
				let cnt = in_repeat;
				let win = 0;
				while (true) {
					if (cnt-- > 0) {
						if (test(players) === 0) {
							win++;
						}
						this.#initAreaScores();
						(rollback)();
					} else {
						break;
					}
				}
				const digit = 2;
				const order = 10 ** digit;
				row.push(Math.floor(win / in_repeat * order) / order);
				this.#initAreaScores();
				(rollback)();
			});
			table.push(row);
		});
		const elem = (in_table => {
			const ret = document.createElement('TABLE');
			in_table.forEach(in_row => {
				const row = document.createElement('TR');
				in_row.forEach(in_cell => {
					const cell = document.createElement('TD');
					cell.innerText = in_cell;
					let color = 'eeeeee';
					if (typeof in_cell === 'boolean') {
						if (in_cell) {
							color = 'ccccff';
						} else {
							color = 'ffcccc';
						}
					} else {
						if (typeof in_cell === 'number') {
							if (in_cell > 0.5) {
								color = 'ccccff';
							} else {
								color = 'ffcccc';
							}
						}
					}
					cell.style.backgroundColor = color;
					cell.style.textAlign = 'center';
					cell.style.border = '1px solid black';
					cell.style.padding = '3px';
					cell.style.width = '5em';
					row.appendChild(cell);
				});
				ret.appendChild(row);
			});
			ret.style.borderCollapse = 'collapse';
			return ret;
		})(table);
		const script = document.currentScript;
		script.parentNode.insertBefore(elem, script.nextSibling);
	}
	_debug() {
		const sources = {area : this.#area.items};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			sources['p-' + player] = this.#area.scores.players[player];
		}
		Object.keys(sources).forEach(in_key => {
			console.log('*** ' + in_key + ' ***');
			const data = sources[in_key];
			for (let row = 0; row < this.#conf.row.size; row++) {
				const items = [];
				for (let col = 0; col < this.#conf.col.size; col++) {
					const ix = this.#posToIndex(row, col);
					items.push(data[ix]);
				}
				console.log(items);
			}
		});
	}
	pc(in_player, in_row, in_col) {
		const index = this.#posToIndex(in_row, in_col);
		if (this.#getItemByIndex(index) !== cReversi.#empty) {
			return false;
		}
		if (this.#flippable(in_player, index)) {
			this.#choose(in_player, index);
			return true;
		} else {
			return false;
		}
	}
	npc(in_player, in_argo = null) {
		let npcAlive = false;
		let playerCnt = 0;
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			if (this.#area.items.indexOf(player) >= 0) {
				playerCnt++;
				if (player === in_player) {
					npcAlive = true;
				}
			}
		}
		if (npcAlive) {
			if (playerCnt === 1) {
				// only in_player
				return false;
			}
		} else {
			// in_player is died
			return false;
		}
		if (this.#area.items.indexOf(cReversi.#empty) === -1) {
			// fulfilled
			return false;
		}
		let npcArgo;
		if (in_argo) {
			npcArgo = in_argo;
		} else {
			npcArgo = this.#npcArgoPriority[in_player];
		}
		// console.log(in_player, npcAlive, playerCnt, npcArgo);
		const candidates = this.#searchCandidates(in_player);
		if (candidates.length > 0) {
			(this.#npcSet[npcArgo].bind(this))(in_player, candidates);
			return true;
		} else {
			if (this.#conf.row.edge) {
				if (this.#conf.col.edge) {
					// can not do anything
					return false;
				} else {
					// try col-wise rotation
					return this.#npcTryRotate(in_player, 'row');
				}
			} else {
				// try row-wise rotation
				return this.#npcTryRotate(in_player, 'col');
			}
		}
	}
	canRowWiseLoop() {
		return !this.#conf.row.edge;
	}
	canColWiseLoop() {
		return !this.#conf.col.edge;
	}
	getLast(in_conditions = {}) {
		// in_conditions : {who, action, row, col, target, delta}
		for (let i = this.#history.length - 1; i >= 0; i--) {
			const last = this.#history[i];
			if (Object.keys(in_conditions).some(in_key => in_conditions[in_key] !== last[in_key])) {
				continue;
			} else {
				return last;
			}
		}
		return null;
	}
	getTable() {
		const table = [];
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const pos = this.#indexToPos(ix);
			if (!table[pos.row]) {
				table[pos.row] = [];
			}
			table[pos.row][pos.col] = parseInt(this.#getItemByIndex(ix));
		}
		return table;
	}
	setTable(in_table) {
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const item = in_table[row][col];
				if (cReversi.#validData.indexOf(item) < 0) {
					throw new Error('invalid input');
				} else {
					this.#setItemByPos(row, col, item);
				}
			}
		}
	}
	setActionResult(in_player, in_action, in_table) {
		this.setTable(in_table);
		this.#history.push({
			who : in_player,
			action : in_action,
			row : -1,
			col : -1,
			target : -1,
			delta : -1
		});
	}
	getCurrentCondition() {
		const condition = {
			finished : false,
			players : []
		};
		const canRotate = !(this.#conf.row.edge && this.#conf.col.edge);
		const cnt = {
			activePlayer : 0,
			frozenPlayer : 0
		};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			let score, dead, frozen;
			score = (this.#area.items.filter(in_el => in_el === player)).length;
			dead = (score === 0);
			if (dead) {
				frozen = true;
			} else {
				const candidates = (this.#searchCandidates(player)).length;
				if ((candidates > 0) || canRotate) {
					cnt.activePlayer++;
					frozen = false;
				} else {
					cnt.frozenPlayer++;
					frozen = true;
				}
			}
			condition.players[player] = {score : score, dead : dead, frozen : frozen};
		}
		condition.finished =
			// only 1 player is active
			(cnt.activePlayer + cnt.frozenPlayer === 1) ||
			// all players are frozen
			(cnt.activePlayer === 0) ||
			// there is no emply
			(this.#phase() === 1);
		return condition;
	}
}

const table1 = [
	[9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 0, 1, 1, 9, 9, 9, 9],
	[9, 9, 9, 0, 8, 0, 9, 9, 9, 9],
	[9, 9, 9, 1, 1, 0, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9, 9, 9]
];

const table2 = [
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 0, 1, 9, 9, 9],
	[9, 9, 9, 1, 0, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9]
];

const table3 = [
	[9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9],
	[9, 9, 1, 0, 0, 9, 9],
	[9, 9, 1, 8, 1, 9, 9],
	[9, 9, 0, 0, 1, 9, 9],
	[9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9]
];

const game = new cReversi(table2, true, true);
console.time('_simulation');
game._simulation();
console.timeEnd('_simulation');

/*

const table = [
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 0, 1, 9, 9, 9],
	[9, 9, 9, 1, 0, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9],
	[9, 9, 9, 9, 9, 9, 9, 9]
];

const game = new cReversi(table, true, true);
game._debug();

*/

//const game = new cReversi(table, true, true);
//game.ut(0, 48);
//game.npc(0);
//game.npc(1);
//game.npc(0);
//game.npc(1);
//console.log(game.getTable());
//console.log(game.getCurrentCondition());

</script>
</body>

