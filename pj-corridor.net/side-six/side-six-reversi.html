<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports" : {
		"three" : "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.min.js",
		"utils" : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/utils/BufferGeometryUtils.js",
		"basic" : "./basic-functions.js",
		"side6" : "./side-six.js",
		"s6res" : "./side-six-reversi-res.js",
		"sound" : "./sound-effect.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';
import {
	getResource,
	postResource,
	getParam,
	DEBUG,
	randomString,
	snapToNotch,
	snapToPI,
	snapTo05PI,
	createPeriodicSin,
	createPeriodicCos,
	pseudoMessageDigest1,
	pseudoMessageDigest2,
	beep,
	isEmulated,
	throttling,
	thresholding,
	debouncing,
	nonReentrantAsync,
	autoTransition,
	startDialog,
	factoryBuilder,
	arrRand,
	arrTrim,
	cEase,
	cApproximateMap,
	cApproximateSet,
	cCyclicMap,
	cCyclicValues,
	forEachCombination,
	clipArea,
	clipClearArea,
	fillRoundRect,
	XYZ,
	VEC3,
	DIRECTION,
	ndcFromEvent,
	ndcToAbs,
	getWorldVec3,
	getWorldUp,
	instanceInAncestor,
	lookAtWithoutRotation,
	safeMergeGeometry,
	makeTrapezoidGeometryParts,
	trapezoidGeometryUtil,
	roundBoxGeometry,
	roundRegularBoxGeometry,
	roundTrapezoidGeometry,
	capsuleConfigure,
	customCapsuleGeometry,
	cSphericalWorld
} from 'basic';
import {
	cColony
} from 'side6';
import {
	RES
} from 's6res';
import * as SOUND from 'sound';

/*
	the cReversi class is designed to implement NPC algorithms for the game of reversi.
*/

class cLineParser {
	static #border = -1;
	static #empty = 9;
	static #cntEmpty(in_arr) {
		return in_arr.filter(in_el => in_el === cLineParser.#empty).length;
	}
	static #findOneInnerEmpty(in_arr) {
		let emptyAppear = false;
		for (let i = 1; i < in_arr.length - 1; i++) {
			if (emptyAppear) {
				if (in_arr[i] === cLineParser.#empty) {
					return false;
				} else {
					return true;
				}
			}
			if (in_arr[i] === cLineParser.#empty) {
				emptyAppear = true;
			}
		}
		return false;
	}
	/*
		fmt_eXXXXX is for edge
	*/
	static #fmt_eCriticalToMe(in_l, in_r) {
		// B90011 ---> [B9][11]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty)) {
			if (in_r[0] !== cLineParser.#empty) {
				return true;
			}
		}
		return false;
	}
	static #fmt_ePreRiskToMe(in_l, in_r) {
		// B90090 ---> [B9][9]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty)) {
			if ((in_r.length === 1) &&
				(in_r[0] === cLineParser.#empty)) {
				return true;
			}
		}
		return false;
	}
	static #fmt_ePressureToMe(in_l, in_r) {
		// B900191 ---> [B9][191]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border)) {
			return cLineParser.#fmt_bPressureToMe(in_l, in_r);
		}
		return false;
	}
	static #fmt_ePrePressureToMe(in_l, in_r) {
		// B909191 ---> [B9][9191]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border)) {
			return cLineParser.#fmt_bPrePressureToMe(in_l, in_r);
		}
		return false;
	}
	static #fmt_ePressureByMe(in_l, in_r) {
		// B911090 ---> [B911][9]
		if ((in_l.length >= 3) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty) &&
			(cLineParser.#cntEmpty(in_l) === 1)) {
			return cLineParser.#fmt_bPressureByMe(in_l, in_r);
		}
		return false;
	}
	/*
		fmt_bXXXXX is for both edge and inner
	*/
	static #fmt_bPressureToMe(in_l, in_r) {
		// 9900191 ---> [99][191]
		if (in_l[in_l.length - 1] === cLineParser.#empty) {
			if ((in_r.length >= 3) &&
				(in_r[0] !== cLineParser.#empty)) {
				return cLineParser.#findOneInnerEmpty(in_r);
			}
		}
		return false;
	}
	static #fmt_bPrePressureToMe(in_l, in_r) {
		// 9909191 ---> [99][9191]
		if (in_l[in_l.length - 1] === cLineParser.#empty) {
			if ((in_r.length >= 3) &&
				(in_r[0] === cLineParser.#empty)) {
				return cLineParser.#findOneInnerEmpty(in_r);
			}
		}
		return false;
	}
	static #fmt_bPressureByMe(in_l, in_r) {
		// 9911090 ---> [9911][9]
		if ((in_l[in_l.length - 1] !== cLineParser.#empty) &&
			(cLineParser.#cntEmpty(in_l) >= 1)) {
			if ((in_r.length === 1) &&
				(in_r[0] === cLineParser.#empty)) {
				return true;
			}
		}
		return false;
	}
	static #fmt_bInnerByMe(in_l, in_r) {
		// 110199 --> [11][199]
		if ((in_l[in_l.length - 1] === in_r[0]) &&
			(in_r[0] !== cLineParser.#empty)) {
			return true;
		}
		return false;
	}
	static parse(in_items, in_player, in_loop, in_debug = false) {
		const parsed = {
			eCriticalToMe : false,
			ePreRiskToMe : false,
			ePressureToMe : false,
			ePrePressureToMe : false,
			ePressureByMe : false,
			bFulfilledWith : false,
			bPressureToMe : false,
			bPrePressureToMe : false,
			bPressureByMe : false,
			bPreOuterByMe : false,
			bOuterByMe : false,
			bInnerByMe : false,
			safetyScore : 0
		};
		let items;
		if (in_loop) {
			items = [...in_items];
		} else {
			items = [cLineParser.#border, ...in_items, cLineParser.#border];
		}
		if (items.indexOf(in_player) === -1) {
			return parsed;
		}
		/*
			(1) as in_player should be exist from here, split array using in_player

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : [12],[34]
				ex2 (loop) : [12],[34],[]
				ex3 (loop) : [],[12],[34],[]

				ex1 (non-loop) : [B12],[45B]
				ex2 (non-loop) : [B12],[34],[B]
				ex3 (non-loop) : [B],[12],[34],[B]
		*/
		let meMaxIx = 0;
		let meStart = false;
		// the 1st item may be empty
		const subsets = [[]];
		parsed.bFulfilledWith = true;
		for (let i = 0; i < items.length; i++) {
			if (items[i] === in_player) {
				if (meStart) {
					continue;
				} else {
					meStart = true;
					// the last item may be empty
					subsets[++meMaxIx] = [];
				}
			} else {
				meStart = false;
				if (items[i] === cLineParser.#empty) {
					parsed.bFulfilledWith = false;
				}
				subsets[meMaxIx].push(items[i]);
			}
		}
		if (parsed.bFulfilledWith) {
			return parsed;
		}
		/*
			(2) relate left side / right side to in_player

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : L[12]+R[34]
				ex2 (loop) : L[12]+R[34], L[34]+R[]
				ex3 (loop) : L[]+R[12],L[12]+R[34],L[34]+R[]

				ex1 (non-loop) : L[B12]+R[45B]
				ex2 (non-loop) : L[B12]+R[34],L[34]+R[B]
				ex3 (non-loop) : L[B]+R[12],L[12]+R[34],L[34]+R[B]
		*/
		const meNodes = [];
		for (let i = 0; i < meMaxIx; i++) {
			meNodes[i] = {
				L : subsets[i],
				R : subsets[i + 1]
			};
		}
		/*
			(3) normalize

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : L[3412]+R[3412]
				ex2 (loop) : L[12]+R[34],L[34]+R[12]
				ex3 (loop) : L[34]+R[12],L[12]+R[34]

				ex1 (non-loop) : L[B12]+R[45B]
				ex2 (non-loop) : L[B12]+R[34],L[34]+R[B]
				ex3 (non-loop) : L[B]+R[12],L[12]+R[34],L[34]+R[B]
		*/
		const meFirst = meNodes[0];
		const meLast = meNodes[meNodes.length - 1];
		if (in_loop) {
			if ((meFirst.L.length === 0) && (meLast.R.length === 0)) {
				meFirst.L = [...meLast.L];
				meNodes.pop();
			} else {
				meFirst.L = [...meLast.R, ...meFirst.L];
				meLast.R = meFirst.L;
			}
		}
		/*
			(4) bPreOuterByMe, bOuterByMe
		*/
		if (in_loop) {
			for (let i = 0; i < meNodes.length; i++) {
				const cnt = cLineParser.#cntEmpty(meNodes[i].L);
				parsed['bPreOuterByMe'] ||= (cnt === 1);
				parsed['bOuterByMe'] ||= (cnt === 0);
			}
		} else {
			// except for both edges
			for (let i = 1; i < subsets.length - 1; i++) {
				const cnt = cLineParser.#cntEmpty(subsets[i]);
				parsed['bPreOuterByMe'] ||= (cnt === 1);
				parsed['bOuterByMe'] ||= (cnt === 0);
			}
		}
		/*
			(5) calculate score + check format
		*/
		const formatArr = [
			['eCriticalToMe', cLineParser.#fmt_eCriticalToMe],
			['ePreRiskToMe', cLineParser.#fmt_ePreRiskToMe],
			['ePressureToMe', cLineParser.#fmt_ePressureToMe],
			['ePrePressureToMe', cLineParser.#fmt_ePrePressureToMe],
			['ePressureByMe', cLineParser.#fmt_ePressureByMe],
			['bPressureToMe', cLineParser.#fmt_bPressureToMe],
			['bPrePressureToMe', cLineParser.#fmt_bPrePressureToMe],
			['bPressureByMe', cLineParser.#fmt_bPressureByMe],
			['bInnerByMe', cLineParser.#fmt_bInnerByMe]
		];
		for (let i = 0; i < meNodes.length; i++) {
			const curr = meNodes[i];
			const neighborL = curr.L[curr.L.length - 1];
			const neighborR = curr.R[0];
			if ((neighborL === neighborR) ||
				(neighborL === cLineParser.#border) ||
				(neighborR === cLineParser.#border)) {
				parsed.safetyScore += 1;
			} else {
				parsed.safetyScore -= 1;
			}
			const reversedR = curr.R.toReversed();
			const reversedL = curr.L.toReversed()
			formatArr.forEach(([in_format, in_checker]) => {
				if (parsed[in_format]) {
					return;
				}
				const toL = (in_checker)(curr.L, curr.R);
				const toR = (in_checker)(reversedR, reversedL);
				parsed[in_format] = toL || toR;
			});
		}
		return parsed;
	}
}

(in_test => {

if (!in_test) {
	return;
}

const suites = [

	{group : '*** 1. there is no pc ***'},

		{items : [9,9,9,9,9,9,9,9], loop : false, safetyScore : 0, dp : false},
		{items : [9,9,9,9,1,2,1,2], loop : false, safetyScore : 0, dp : false},
		{items : [1,2,1,2,1,2,1,2], loop : false, safetyScore : 0, dp : false},

		{items : [9,9,9,9,9,9,9,9], loop : true, safetyScore : 0, dp : false},
		{items : [9,9,9,9,1,2,1,2], loop : true, safetyScore : 0, dp : false},
		{items : [1,2,1,2,1,2,1,2], loop : true, safetyScore : 0, dp : false},

	{group : '*** 2. no empty ***'},

		{items : [0,0,0,0,0,0,0,0], loop : false, safetyScore : 0, dp : false},
		{items : [1,2,1,2,0,0,0,0], loop : false, safetyScore : 0, dp : false},

		{items : [0,0,0,0,0,0,0,0], loop : true, safetyScore : 0, dp : false},
		{items : [1,2,1,2,0,0,0,0], loop : true, safetyScore : 0, dp : false},

	{group : '*** 3. pc is on the left side ***'},

		{items : [0,9,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
		{items : [0,9,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},

		{items : [0,9,9,9,9,9,9,9], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,9], loop : true, safetyScore : -1, dp : false},
		{items : [0,9,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
		{items : [0,1,9,9,9,9,9,1], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,2], loop : true, safetyScore : -1, dp : false},

	{group : '*** 4. pc is on the right side ***'},

		{items : [9,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
		{items : [9,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},
		{items : [1,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
		{items : [1,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},

		{items : [9,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
		{items : [9,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,1,0], loop : true, safetyScore : 0, dp : false},
		{items : [2,0,9,9,9,9,1,0], loop : true, safetyScore : -2, dp : false},

	{group : '*** 5. pc is on the both sides ***'},

		{items : [0,9,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,1,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,9,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},

		{items : [0,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
		{items : [0,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : true, safetyScore : 1, dp : false},
		{items : [0,2,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},

	{group : '*** 6. npc is on the both sides ***'},

		{items : [1,9,9,9,9,9,9,1], loop : false, safetyScore : 0, dp : false},
		{items : [1,0,9,9,9,9,9,1], loop : false, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,0,1], loop : false, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,0,1], loop : false, safetyScore : -2, dp : false},

		{items : [1,9,9,9,9,9,9,1], loop : true, safetyScore : 0, dp : false},
		{items : [1,0,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,0,1], loop : true, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,0,1], loop : true, safetyScore : -2, dp : false},

	{group : '*** 7. bFulfilledWith ***'},

		{items : [1,1,1,1,1,1,1,1], loop : false, bFulfilledWith : false, dp : false},
		{items : [1,1,1,9,0,1,1,1], loop : false, bFulfilledWith : false, dp : false},
		{items : [1,1,1,0,0,1,1,1], loop : false, bFulfilledWith : true, dp : false},
		{items : [0,0,0,0,0,0,0,0], loop : false, bFulfilledWith : true, dp : false},
		{items : [0,0,0,9,0,0,0,0], loop : false, bFulfilledWith : false, dp : false},

		{items : [1,1,1,1,1,1,1,1], loop : true, bFulfilledWith : false, dp : false},
		{items : [1,1,1,9,0,1,1,1], loop : true, bFulfilledWith : false, dp : false},
		{items : [1,1,1,0,0,1,1,1], loop : true, bFulfilledWith : true, dp : false},
		{items : [0,0,0,0,0,0,0,0], loop : true, bFulfilledWith : true, dp : false},
		{items : [0,0,0,9,0,0,0,0], loop : true, bFulfilledWith : false, dp : false},

	{group : '*** 8. bOuterByMe ***'},

		{items : [0,1,0,9,9,9,9,9], loop : false, bOuterByMe : true, dp : false},
		{items : [1,0,9,9,9,9,9,0], loop : false, bOuterByMe : false, dp : false},
		{items : [0,9,9,9,9,9,0,1], loop : false, bOuterByMe : false, dp : false},
		{items : [9,9,9,9,9,0,1,0], loop : false, bOuterByMe : true, dp : false},
		{items : [9,9,0,1,2,0,9,9], loop : false, bOuterByMe : true, dp : false},
		{items : [2,0,9,9,9,9,0,1], loop : false, bOuterByMe : false, dp : false},

		{items : [0,1,0,9,9,9,9,9], loop : true, bOuterByMe : true, dp : false},
		{items : [1,0,9,9,9,9,9,0], loop : true, bOuterByMe : true, dp : false},
		{items : [0,9,9,9,9,9,0,1], loop : true, bOuterByMe : true, dp : false},
		{items : [9,9,9,9,9,0,1,0], loop : true, bOuterByMe : true, dp : false},
		{items : [9,9,0,1,2,0,9,9], loop : true, bOuterByMe : true, dp : false},
		{items : [2,0,9,9,9,9,0,1], loop : true, bOuterByMe : true, dp : false},

	{group : '*** 9. bPreOuterByMe ***'},

		{items : [9,0,9,9,9,9,9,0], loop : false, bPreOuterByMe : false, dp : false},
		{items : [0,9,0,9,9,9,9,9], loop : false, bPreOuterByMe : true, dp : false},
		{items : [9,0,9,0,9,9,9,9], loop : false, bPreOuterByMe : true, dp : false},
		{items : [9,0,1,0,9,9,9,9], loop : false, bPreOuterByMe : false, dp : false},
		{items : [9,0,9,9,0,9,9,9], loop : false, bPreOuterByMe : false, dp : false},

		{items : [9,0,9,9,9,9,9,0], loop : true, bPreOuterByMe : true, dp : false},

	{group : '*** 10. eCriticalToMe ***'},

		{items : [0,1,9,9,9,9,9,9], loop : false, eCriticalToMe : false, dp : false},
		{items : [9,0,1,9,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,1,0,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,1,2,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,9,1,9,9,9,9], loop : false, eCriticalToMe : false, dp : false},

		{items : [9,9,9,9,9,9,1,0], loop : false, eCriticalToMe : false, dp : false},
		{items : [9,9,9,9,9,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,0,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,2,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,1,9,0,9], loop : false, eCriticalToMe : false, dp : false},

	{group : '*** 11. ePreRiskToMe ***'},

		{items : [9,0,9,0,9,9,9,9], loop : false, ePreRiskToMe : true, dp : false},
		{items : [9,0,9,9,0,9,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,0,9,0,9,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,0,0,9,0,0,9,9], loop : false, ePreRiskToMe : true, dp : false},

		{items : [9,9,9,9,0,9,0,9], loop : false, ePreRiskToMe : true, dp : false},
		{items : [9,9,9,0,9,9,0,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,9,0,9,0,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,0,0,9,0,0,9], loop : false, ePreRiskToMe : true, dp : false},

	{group : '*** 12. ePressureToMe ***'},

		{items : [9,0,1,9,1,9,9,9], loop : false, ePressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : false, ePressureToMe : false, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : false, ePressureToMe : true, dp : false},
		{items : [9,0,1,9,1,9,9,9], loop : true, ePressureToMe : false, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : true, ePressureToMe : false, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : true, ePressureToMe : false, dp : false},

		{items : [9,9,1,9,1,0,9,9], loop : false, ePressureToMe : false, dp : false},
		{items : [9,1,9,1,1,0,0,9], loop : false, ePressureToMe : true, dp : false},

	{group : '*** 13. bPressureToMe ***'},

		{items : [9,0,1,9,1,9,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,0,1,9,1,9,9,9], loop : true, bPressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : true, bPressureToMe : true, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : true, bPressureToMe : true, dp : false},

		{items : [9,9,1,9,1,0,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,1,9,1,1,0,0,9], loop : false, bPressureToMe : true, dp : false},

	{group : '*** 14. ePrePressureToMe ***'},

		{items : [9,0,9,9,1,9,9,9], loop : false, ePrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : false, ePrePressureToMe : false, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : false, ePrePressureToMe : true, dp : false},
		{items : [9,0,9,9,1,9,9,9], loop : true, ePrePressureToMe : false, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : true, ePrePressureToMe : false, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : true, ePrePressureToMe : false, dp : false},

		{items : [9,9,1,9,9,0,9,9], loop : false, ePrePressureToMe : false, dp : false},
		{items : [9,1,9,1,9,0,0,9], loop : false, ePrePressureToMe : true, dp : false},

	{group : '*** 15. bPrePressureToMe ***'},

		{items : [9,0,9,9,1,9,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,0,9,9,1,9,9,9], loop : true, bPrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : true, bPrePressureToMe : true, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : true, bPrePressureToMe : true, dp : false},

		{items : [9,9,1,9,9,0,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,1,9,1,9,0,0,9], loop : false, bPrePressureToMe : true, dp : false},

	{group : '*** 16. ePressureByMe ***'},

		{items : [1,1,0,9,0,9,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,1,0,9,0,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,1,0,9,0,9,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,0,0,9,0,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : true, ePressureByMe : false, dp : false},

		{items : [9,9,9,0,9,0,1,1], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,0,9,0,1,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,9,0,9,0,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,0,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : true, ePressureByMe : false, dp : false},

	{group : '*** 17. bPressureByMe ***'},

		{items : [1,1,0,9,0,9,9,9], loop : false, bPressureByMe : false, dp : false},
		{items : [9,9,1,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,0,9,0,9,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,0,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : true, bPressureByMe : true, dp : false},

		{items : [9,9,9,0,9,0,1,1], loop : false, bPressureByMe : false, dp : false},
		{items : [9,9,0,9,0,1,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,9,0,9,0,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,0,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : true, bPressureByMe : true, dp : false},

	{group : '*** 18. bInnerByMe ***'},

		{items : [9,9,9,9,9,9,9,9], loop : false, bInnerByMe : false, dp : false},

		{items : [1,0,1,9,9,9,9,9], loop : false, bInnerByMe : true, dp : false},
		{items : [1,0,0,1,9,9,9,9], loop : false, bInnerByMe : true, dp : false},
		{items : [2,0,0,1,9,9,9,9], loop : false, bInnerByMe : false, dp : false},
		{items : [1,9,0,1,9,9,9,9], loop : false, bInnerByMe : false, dp : false},

		{items : [0,1,9,9,9,9,9,1], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,2,0], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,9], loop : false, bInnerByMe : false, dp : false},

		{items : [0,1,9,9,9,9,9,1], loop : true, bInnerByMe : true, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : true, bInnerByMe : true, dp : false},
		{items : [0,1,9,9,9,9,2,0], loop : true, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,9], loop : true, bInnerByMe : false, dp : false}
];
suites.forEach(in_suite => {
	if (in_suite.group) {
		console.log(in_suite.group);
	} else {
		const parsed = cLineParser.parse(in_suite.items, 0, in_suite.loop, in_suite.dp);
		Object.keys(parsed).forEach(in_prop => {
			if (!in_suite.hasOwnProperty(in_prop)) {
				return;
			}
			if (in_suite[in_prop] !== parsed[in_prop]) {
				const loop = in_suite.loop ? ' (loop)' : '';
				console.log('failed : ' + in_suite.items.join() + loop + ' is ' + parsed[in_prop]);
			}
		});
	}
});

})(false);

class cReversi {
	static #maximize(in_evaluator, in_player, in_candArr) {
		const evaluated = new Map();
		in_candArr.forEach(in_ix => evaluated.set(in_ix, (in_evaluator)(in_player, in_ix)));
		const max = {
			value : -Infinity,
			indexes : []
		};
		for (const [index, value] of evaluated.entries()) {
			if (value > max.value) {
				max.value = value;
				max.indexes = [index];
			} else {
				if (value === max.value) {
					max.indexes.push(index);
				}
			}
		}
		if (max.indexes.length === 0) {
			console.log(evaluated);
			throw new Error();
		}
		return max.indexes;
	}
	static #rotateArray(in_array, in_delta) {
		const len = in_array.length;
		const delta = ((in_delta % len) + len) % len;
		return in_array.slice(delta * -1).concat(in_array.slice(0, delta * -1));
	}
	static #dmz = 8;
	static #empty = 9;
	static #maxPlayers = 4;
	static #validData = (() => {
		const arr = [cReversi.#dmz, cReversi.#empty];
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			arr.push(player);
		}
		return arr;
	})();
	static #dirSet = {
		square : {
			onehand : {
				regular : [
					[-1, -1],
					[-1,  0],
					[-1, +1],
					[ 0, -1],
					[ 0, +1],
					[+1, -1],
					[+1,  0],
					[+1, +1]
				],
				offset : [
					[-1, -1],
					[-1,  0],
					[-1, +1],
					[ 0, -1],
					[ 0, +1],
					[+1, -1],
					[+1,  0],
					[+1, +1]
				]
			},
			pair : new Map([
				[  0, [1, 6]],
				[ 45, [2, 5]],
				[ 90, [3, 4]],
				[135, [0, 7]]
			])
		},
		hexPointyTopped : {
			onehand : {
				/*
					@@
					@+@
					@@
				*/
				regular : [
					[-1, -1],
					[-1,  0],
					[ 0, +1],
					[+1,  0],
					[+1, -1],
					[ 0, -1]
				],
				/*
					 @@
					@+@
					 @@
				*/
				offset : [
					[-1,  0],
					[-1, +1],
					[ 0, +1],
					[+1, +1],
					[+1,  0],
					[ 0, -1]
				]
			},
			pair : new Map([
				[ 30, [1, 4]],
				[ 90, [2, 5]],
				[150, [0, 3]]
			])
		},
		hexFlatTopped : {
			onehand : {
				/*
					@@@
					@+@
					 @
				*/
				regular : [
					[-1, -1],
					[-1,  0],
					[-1, +1],
					[ 0, +1],
					[+1,  0],
					[ 0, -1]
				],
				/*
					 @
					@+@
					@@@
				*/
				offset : [
					[ 0, -1],
					[-1,  0],
					[ 0, +1],
					[+1, +1],
					[+1,  0],
					[+1, -1]
				]
			},
			pair : new Map([
				[  0, [1, 4]],
				[ 60, [2, 5]],
				[120, [0, 3]]
			])
		}
	};
	static #ignore = Symbol();
	#area = {
		items : [],
		options : new Set(),
		scores : {
			default : [],
			players : []
		}
	};
	#npcArgoPriority = [];
	#history = [];
	#conf = null;
	#rotations = null;
	#getDirSet(in_row, in_col) {
		const dirSet = this.#conf.dirSet;
		let useOffset = false;
		if (dirSet.pair.get(0)) {
			// square or hexFlatTopped
			useOffset = (in_col % 2 === this.#conf.offset);
		} else {
			// hexPointyTopped
			useOffset = (in_row % 2 === this.#conf.offset);
		}
		if (useOffset) {
			return dirSet.onehand.offset;
		} else {
			return dirSet.onehand.regular;
		}
	}
	#getDir(in_row, in_col, in_dirIx) {
		return this.#getDirSet(in_row, in_col)[in_dirIx];
	}
	#neighborIndexes(in_ix) {
		const pos = this.#indexToPos(in_ix);
		return this.#neighborPositions(pos.row, pos.col).map(([in_row, in_col]) => this.#posToIndex(in_row, in_col));
	}
	#neighborPositions(in_row, in_col) {
		const directions = this.#getDirSet(in_row, in_col);
		const neighbor = [];
		const sizeRow = this.#conf.row.size;
		const sizeCol = this.#conf.col.size;
		directions.forEach(([in_dr, in_dc]) => {
			let row = in_row + in_dr;
			let col = in_col + in_dc;
			if ((row < 0) || (sizeRow -1 < row)) {
				if (this.#conf.row.edge) {
					return;
				} else {
					row = (sizeRow + row) % sizeRow;
				}
			}
			if ((col < 0) || (sizeCol -1 < col)) {
				if (this.#conf.col.edge) {
					return;
				} else {
					col = (sizeCol + col) % sizeCol;
				}
			}
			neighbor.push([row, col]);
		});
		return neighbor;
	}
	#sameAngleIndexes(in_ix, in_angle) {
		const angle = (in_angle + 180) % 180;
		const pair = this.#conf.dirSet.pair.get(angle);
		if (!pair) {
			throw new Error('invalid in_angle');
		}
		const radiating = this.#conf.tagIxSet.radiating[in_ix];
		return [...radiating[pair[0]], ...radiating[pair[1]]];
	}
	#sameAnglePositions(in_row, in_col, in_angle) {
		const ix = this.#posToIndex(in_row, in_col);
		return this.#sameAngleIndexes(ix, in_angle).map(in_ix => {
			const pos = this.#indexToPos(in_ix);
			return [pos.row, pos.col];
		});
	}
	constructor(in_table, in_rowEdge, in_colEdge, in_format = 'square', in_offset = 1) {
		const sizeRow = in_table.length;
		const sizeCol = in_table.reduce((in_maxLen, in_row) => {
			return Math.max(in_maxLen, in_row.length);
		}, 0);
		if (cReversi.#dirSet.hasOwnProperty(in_format)) {
			if (!in_rowEdge && (sizeRow % 2 === 1) && (in_format === 'hexPointyTopped')) {
				throw new Error('invalid rows (' + sizeRow + ') for row-loop of ' + in_format);
			}
			if (!in_colEdge && (sizeCol % 2 === 1) && (in_format === 'hexFlatTopped')) {
				throw new Error('invalid cols (' + sizeRow + ') for col-loop of ' + in_format);
			}
		} else {
			throw new Error('invalid input');
		}
		this.#conf = {
			row : {
				size : sizeRow,
				edge : in_rowEdge
			},
			col : {
				size : sizeCol,
				edge : in_colEdge
			},
			dirSet : cReversi.#dirSet[in_format],
			// square can accommodate any offset
			offset : (in_offset % 2),
			rotatable : {},
			tagIxSet : {
				radiating : [],
				corner : [],
				xInside : []
			}
		};
		this.#conf.rotatable.fixedCol = !in_rowEdge && this.#conf.dirSet.pair.has(0);
		this.#conf.rotatable.fixedRow = !in_colEdge && this.#conf.dirSet.pair.has(90);
		this.setTable(in_table);
		// (1) tagIxSet.radiating
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const {row : initRow, col : initCol} = this.#indexToPos(ix);
			const radiating = this.#conf.tagIxSet.radiating[ix] = [];
			const dirSet = this.#getDirSet(initRow, initCol);
			for (let dirIx = 0; dirIx < dirSet.length; dirIx++) {
				const towards = [];
				let currRow = initRow;
				let currCol = initCol;
				while (true) {
					const [dr, dc] = this.#getDir(currRow, currCol, dirIx);
					currRow += dr;
					if (in_rowEdge) {
						if ((currRow < 0) || (sizeRow - 1 < currRow)) {
							// out of range
							break;
						}
					} else {
						currRow = (currRow + sizeRow) % sizeRow;
						if ((currRow === initRow) && (dr !== 0)) {
							// cyclic
							break;
						}
					}
					currCol += dc;
					if (in_colEdge) {
						if ((currCol < 0) || (sizeCol - 1 < currCol)) {
							// out of range
							break;
						}
					} else {
						currCol = (currCol + sizeCol) % sizeCol;
						if ((currCol === initCol) && (dc !== 0)) {
							// cyclic
							break;
						}
					}
					towards.push(this.#posToIndex(currRow, currCol));
				}
				radiating.push(towards);
			}
		}
		// (2) tagIxSet.corner, tagIxSet.xInside
		const pairs = Array.from(this.#conf.dirSet.pair.values());
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const radiating = this.#conf.tagIxSet.radiating[ix];
			// (2-1) corner
			const isCorner = pairs.every(([in_pos, in_neg]) => {
				const P = radiating[in_pos];
				const N = radiating[in_neg];
				if ((P.length === 0) || (this.#getItemByIndex(P[0]) === cReversi.#dmz)) {
					return true;
				}
				if ((N.length === 0) || (this.#getItemByIndex(N[0]) === cReversi.#dmz)) {
					return true;
				}
				// both sides are available
				return false;
			});
			if (!isCorner) {
				continue;
			} else {
				this.#conf.tagIxSet.corner.push(ix);
			}
			// (2-2) xInside
			const aroundCorner = this.#neighborIndexes(ix);
			aroundCorner.forEach(in_around_ix => {
				const candidates = this.#neighborIndexes(in_around_ix);
				if (candidates.length < pairs.length * 2) {
					return;
				}
				if (candidates.every(in_cand_ix => this.#getItemByIndex(in_cand_ix) === cReversi.#empty)) {
					if (!this.#conf.tagIxSet.xInside.includes(in_around_ix)) {
						this.#conf.tagIxSet.xInside.push(in_around_ix);
					}
				}
			});
		}
		this.#initAreaScores();
		const argoArr = ['spiteful', 'balance', 'safety', 'greedy', 'learner', 'classic', 'beginner', 'monkey'];
		for (let i = 0; i < argoArr.length; i++) {
			this.#npcArgoPriority.push((argoArr.slice(0, i + 1))[arrRand]());
		}
		this.#updateOptionsAll();
	}
	#updateOptions(in_ix) {
		const radiating = this.#conf.tagIxSet.radiating[in_ix];
		radiating.forEach(in_towards => {
			if (in_towards.length > 0) {
				const aroundIx = in_towards[0];
				if (this.#getItemByIndex(aroundIx) === cReversi.#empty) {
					this.#area.options.add(aroundIx);
				}
			}
		});
		// in_ix should be new occupied position
		this.#area.options.delete(in_ix);
	}
	#updateOptionsAll() {
		this.#area.options.clear();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) === cReversi.#empty) {
				continue;
			}
			this.#updateOptions(ix);
		}
	}
	#createRollback() {
		const backup = {
			items : [...this.#area.items],
			options : [...this.#area.options]
		};
		return () => {
			this.#area.items = [...backup.items];
			this.#area.options = new Set(backup.options);
		};
	}
	#indexToPos(in_ix) {
		return {
			row : Math.floor(in_ix / this.#conf.col.size),
			col : in_ix % this.#conf.col.size
		};
	}
	#posToIndex(in_row, in_col) {
		return in_row * this.#conf.col.size + in_col;
	}
	#setItemByIndex(in_ix, in_item) {
		this.#area.items[in_ix] = in_item;
	}
	#setItemByPos(in_row, in_col, in_item) {
		this.#setItemByIndex(this.#posToIndex(in_row, in_col), in_item);
	}
	#getItemByIndex(in_ix) {
		return this.#area.items[in_ix];
	}
	#getItemByPos(in_row, in_col) {
		return this.#getItemByIndex(this.#posToIndex(in_row, in_col));
	}
	#items(in_indexes) {
		const items = [];
		in_indexes.forEach(in_ix => {
			items.push(this.#getItemByIndex(in_ix));
		});
		return items;
	}
	#lineIndexes(in_ix, in_angle, in_edge = true) {
		const radiating = this.#conf.tagIxSet.radiating[in_ix];
		const pair = this.#conf.dirSet.pair.get(in_angle);
		if (!pair) {
			return [];
		}
		if (in_edge) {
			return [...radiating[pair[0]], in_ix, ...radiating[pair[1]]];
		} else {
			return [...radiating[pair[0]], in_ix];
		}
	}
	#fixedRowIndexes(in_row) {
		const angleForFixedRow = 90;
		if (this.#conf.dirSet.pair.has(angleForFixedRow)) {
			return this.#lineIndexes(this.#posToIndex(in_row, 0), angleForFixedRow, this.#conf.col.edge);
		} else {
			return [];
		}
	}
	#fixedColIndexes(in_col) {
		const angleForFixedCol = 0;
		if (this.#conf.dirSet.pair.has(angleForFixedCol)) {
			return this.#lineIndexes(this.#posToIndex(0, in_col), angleForFixedCol, this.#conf.row.edge);
		} else {
			return [];
		}
	}
	#rotateItems(in_indexes, in_delta) {
		const shifted = cReversi.#rotateArray(in_indexes, in_delta);
		const copy = [...this.#area.items];
		for (let i = 0; i < in_indexes.length; i++) {
			/*
				for example ...
				src = 5, 6, 7, 8
				dst = 8, 5, 6, 7
			*/
			this.#setItemByIndex(in_indexes[i], copy[shifted[i]]);
		}
	}
	#rotateSameRowItems(in_targetRow, in_deltaCol) {
		const ix = this.#posToIndex(in_targetRow, 0);
		const radiating = this.#conf.tagIxSet.radiating[ix];
		// in case of loop, forward and backward include the same indexes
		const [forward, backward] = this.#conf.dirSet.pair.get(90);
		this.#rotateItems([ix, ...radiating[forward]], in_deltaCol);
	}
	#rotateSameColItems(in_targetCol, in_deltaRow) {
		const ix = this.#posToIndex(0, in_targetCol);
		const radiating = this.#conf.tagIxSet.radiating[ix];
		// in case of loop, forward and backward include the same indexes
		const [forward, backward] = this.#conf.dirSet.pair.get(0);
		this.#rotateItems([ix, ...radiating[forward]], in_deltaRow);
	}
	#flip(in_player, in_ix, in_test = false) {
		const radiating = this.#conf.tagIxSet.radiating[in_ix];
		let flipped = false;
		for (let i = 0; i < radiating.length; i++) {
			const towards = radiating[i];
			const ixArr = [];
			let enemyAppears = false;
			for (let j = 0; j < towards.length; j++) {
				const ix = towards[j];
				const item = this.#getItemByIndex(ix);
				if (item === in_player) {
					if (enemyAppears) {
						if (in_test) {
							return true;
						} else {
							flipped = true;
							ixArr.forEach(in_flipped_ix => this.#setItemByIndex(in_flipped_ix, in_player));
						}
					}
					break;
				} else {
					if ((item === cReversi.#dmz) || (item === cReversi.#empty)) {
						break;
					} else {
						ixArr.push(ix);
						enemyAppears = true;
					}
				}
			}
		}
		if (flipped) {
			this.#setItemByIndex(in_ix, in_player);
			this.#updateOptions(in_ix);
			return true;
		} else {
			return false;
		}
	}
	#flippable(in_player, in_ix) {
		const isTest = true;
		return this.#flip(in_player, in_ix, isTest);
	}
	#choose(in_player, in_ix) {
		// in_ix must be choosable
		this.#flip(in_player, in_ix);
		this.#updatePlayersAreaScores(in_player, in_ix);
		const pos = this.#indexToPos(in_ix);
		this.#history.push({
			who : in_player,
			action : 'choose-item',
			row : pos.row,
			col : pos.col,
			target : -1,
			delta : -1
		});
		// this._debug();
	}
	#npcTryRotate(in_player, in_dir) {
		// step1 : find rows/cols where in_player owns at least one cell
		const rowSet = new Set();
		const colSet = new Set();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) !== in_player) {
				continue;
			}
			const col = ix % this.#conf.col.size;
			const row = (ix - col) / this.#conf.col.size;
			rowSet.add(row);
			colSet.add(col);
		}
		// step2 : test to rotate for in_dir. this algorithm can be improved
		const setting = {
			row : {
				action : 'npc-col-fixed-rotate',
				targetArr : Array.from(rowSet),
				rotateFunc : this.#rotateSameRowItems.bind(this),
				maxCnt : this.#conf.col.size
			},
			col : {
				action : 'npc-row-fixed-rotate',
				targetArr : Array.from(colSet),
				rotateFunc : this.#rotateSameColItems.bind(this),
				maxCnt : this.#conf.row.size
			}
		}
		const {action, targetArr, rotateFunc, maxCnt} = setting[in_dir];
		let target, delta;
		const rollback = this.#createRollback();
		let rotated = targetArr.some(in_target => {
			target = in_target;
			let rest = maxCnt;
			while (--rest > 0) {
				// rotate +1 (maxCnt - 1) times
				(rotateFunc)(in_target, 1);
				const cand = this.#searchCandidates(in_player);
				if (cand.length > 0) {
					delta = maxCnt - rest;
					return true;
				}
			}
			(rollback)();
			return false;
		});
		if (rotated) {
			this.#updateOptionsAll();
			this.#history.push({
				who : in_player,
				action : action,
				row : -1,
				col : -1,
				target : target,
				delta : delta
			});
		}
		return rotated;
	}
	#count(in_player) {
		const items = this.#area.items.filter(in_el => in_el === in_player);
		return items.length;
	}
	#emptyCnt() {
		return this.#count(cReversi.#empty);
	}
	#searchCandidates(in_player) {
		const candidates = [];
		this.#area.options.forEach(in_empty_ix => {
			if (this.#flippable(in_player, in_empty_ix)) {
				candidates.push(in_empty_ix);
			}
		});
		return candidates;
	}
	#getAreaScore(in_player, in_ix) {
		return this.#area.scores.players[in_player][in_ix];
	}
	#initAreaScores() {
		const attenuation = 5;
		this.#area.scores.default = new Array(this.#area.items.length).fill(0);
		let loopCnt = 3;
		while (loopCnt-- > 0) {
			const buff = [];
			for (let ix = 0; ix < this.#area.items.length; ix++) {
				const radiating = this.#conf.tagIxSet.radiating[ix];
				let score = 0;
				radiating.forEach(in_towards => {
					if (in_towards.length === 0) {
						score++;
					} else {
						const neighbor = in_towards[0];
						if (this.#area.items[neighbor] === cReversi.#dmz) {
							score++;
						} else {
							// a cell adjacent to a high-score cell should have its score reduced
							score -= Math.floor(this.#area.scores.default[neighbor] / attenuation);
						}
					}
				});
				buff[ix] = score;
			}
			for (let ix = 0; ix < this.#area.scores.default.length; ix++) {
				this.#area.scores.default[ix] += buff[ix];
			}
		}
		// each player has own score based on owned area
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			this.#area.scores.players[player] = [...this.#area.scores.default];
		}
	}
	#updatePlayersAreaScores(in_player, in_ix) {
		const tagIxSet = this.#conf.tagIxSet;
		if (this.#conf.row.edge && this.#conf.col.edge) {
			if (tagIxSet.corner.some(in_corner_ix => in_corner_ix === in_ix)) {
				const radiating = tagIxSet.radiating[in_ix];
				radiating.forEach(in_towards => {
					if (in_towards.length === 0) {
						return;
					}
					const neighbor = in_towards[0];
					this.#area.scores.players[in_player][neighbor] = this.#area.scores.default[in_ix];
				});
			}
		} else {
			const pos = this.#indexToPos(in_ix);
			let edge, repl;
 			if (this.#conf.row.edge) {
				if (pos.row === 0) {
					edge = this.#fixedRowIndexes(pos.row);
					repl = this.#fixedRowIndexes(pos.row + 1);
				} else if (pos.row === this.#conf.row.size - 1) {
					edge = this.#fixedRowIndexes(pos.row);
					repl = this.#fixedRowIndexes(pos.row - 1);
				} else {
					// in_ix is not on the row-edge
					return;
				}
			}
			if (this.#conf.col.edge) {
				if (pos.col === 0) {
					edge = this.#fixedColIndexes(pos.col);
					repl = this.#fixedColIndexes(pos.col + 1);
				} else if (pos.col === this.#conf.col.size - 1) {
					edge = this.#fixedColIndexes(pos.col);
					repl = this.#fixedColIndexes(pos.col - 1);
				} else {
					// in_ix is not on the col-edge
					return;
				}
			}
			if (!edge) {
				return;
			}
			for (let i = 0; i < edge.length; i++) {
				const score1 = this.#area.scores.default[edge[i]];
				const score2 = this.#area.scores.default[repl[i]];
				const owner = this.#getItemByIndex(edge[i]);
				for (let player = 0; player < cReversi.#maxPlayers; player++) {
					if (player === owner) {
						this.#area.scores.players[player][repl[i]] = score1;
					} else {
						this.#area.scores.players[player][repl[i]] = score2;
					}
				}
			}
		}
	}
	static #evaluateStats = {};
	#evaluate(in_player, in_ix) {
		const registerStats = in_key => {
			if (cReversi.#evaluateStats[in_key]) {
				cReversi.#evaluateStats[in_key]++;
			} else {
				cReversi.#evaluateStats[in_key] = 1;
			}
		};
		registerStats('total');
		const pos = this.#indexToPos(in_ix);
		const noLoop = this.#conf.row.edge && this.#conf.col.edge;
		const ixIsEdge = in_dir => ((this.#conf[in_dir].edge) && ((pos[in_dir] === this.#conf[in_dir].size - 1) || (pos[in_dir] === 0)));
		const ixIsRowEdge = ixIsEdge('row');
		const ixIsColEdge = ixIsEdge('col');
		/*
			1. e (= edge) : check if area of edge is safe
			2. x (= xInside) : check if xInside positions will be not changed
		*/
		const check = {
			e : {
				indexes : [],
				currItems : [],
				nextItems : [],
				currParsed : {},
				nextParsed : {}
			},
			x : {
				indexes : [],
				currItems : [],
				nextItems : [],
				increased : false
			}
		};
		const tagIxSet = this.#conf.tagIxSet;
		if (ixIsRowEdge) {
			if (ixIsColEdge) {
				registerStats('corner');
				return +999;
			} else {
				check.e.indexes = this.#fixedRowIndexes(pos.row);
			}
		} else {
			if (ixIsColEdge) {
				check.e.indexes = this.#fixedColIndexes(pos.col);
			} else {
				if (!noLoop) {
					registerStats('inside & loop = without xInside');
					return 0;
				}
			}
		}
		if (noLoop) {
			check.x.indexes = [];
			for (let i = 0; i < tagIxSet.corner.length; i++) {
				if (tagIxSet.corner[i] === in_player) {
					// does not need to check x
					continue;
				} else {
					check.x.indexes.push(tagIxSet.xInside[i]);
				}
			}
		}
		if (check.e.indexes.length > 0) {
			check.e.currItems = this.#items(check.e.indexes);
		}
		if (check.x.indexes.length > 0) {
			check.x.currItems = this.#items(check.x.indexes);
		}
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		if (check.e.indexes.length > 0) {
			check.e.nextItems = this.#items(check.e.indexes);
			check.e.currParsed = cLineParser.parse(check.e.currItems, in_player, !noLoop);
			check.e.nextParsed = cLineParser.parse(check.e.nextItems, in_player, !noLoop);
		}
		if (check.x.indexes.length > 0) {
			check.x.nextItems = this.#items(check.x.indexes);
			check.x.increased = !check.x.nextItems.every((in_item, in_ix) => in_item === check.x.currItems[in_ix]);
		}
		(rollback)();
		const priorityArr = [
			{format : 'eCriticalToMe', positive : false},
			{format : 'ePreRiskToMe', positive : false},
			{format : 'xInside', positive : false},
			{format : 'ePressureByMe', positive : true},
			{format : 'ePressureToMe', positive : false},
			{format : 'ePrePressureToMe', positive : false},
			{format : 'bFulfilledWith', positive : true},
			{format : 'bPressureByMe', positive : true},
			{format : 'bPressureToMe', positive : false},
			{format : 'bPrePressureToMe', positive : false},
			{format : 'bInnerByMe', positive : true},
			{format : 'bPreOuterByMe', positive : false},
			{format : 'safetyScore', positive : true},
			{format : 'bOuterByMe', positive : true}
		];
		const scale = 10;
		for (let i = 0; i < priorityArr.length; i++) {
			const {format, positive} = priorityArr[i];
			let score = ((priorityArr.length - i - 1) * scale + 1) * (positive ? +1 : -1);
			if (format === 'xInside') {
				// 1. special case (xInside)
				if (check.x.increased) {
					registerStats(format);
					return score;
				} else {
					continue;
				}
			}
			if (check.e.currParsed[format] === check.e.nextParsed[format]) {
				// 2. special case (bOuterByMe)
				if ((format === 'bOuterByMe') && (check.e.nextParsed[format])) {
					registerStats(format);
					return score;
				} else {
					continue;
				}
			} else {
				// 3. generic cases
				if (typeof check.e.nextParsed[format] === 'number') {
					const delta = check.e.nextParsed[format] - check.e.currParsed[format];
					registerStats(format);
					return (delta > 0) ? score * +1 : score * -1;
				} else {
					let statsKey;
					if (check.e.nextParsed[format]) {
						statsKey = format + '-false-to-true';
						score *= +1;
					} else {
						statsKey = format + '-true-to-false';
						score *= -1;
					}
					registerStats(statsKey);
					return score;
				}
			}
		}
		registerStats('can not evaluate');
		return 0;
	}
	#countNextEnemyOption(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const player = (in_player + 1 + cReversi.#maxPlayers) % cReversi.#maxPlayers;
		const count = this.#searchCandidates(player).length;
		(rollback)();
		return count;
	}
	#countNextOption(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const count = this.#searchCandidates(in_player).length;
		(rollback)();
		return count;
	}
	#countNextOwnedSafeArea(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		let count = 0;
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) === in_player) {
				const firstNeighbor = in_arr => {
					for (let i = 0; i < in_arr.length; i++) {
						const neighbor = this.#getItemByIndex(in_arr[i]);
						if (neighbor !== in_player) {
							return neighbor;
						}
					}
					return null;
				}
				const radiating = this.#conf.tagIxSet.radiating[in_ix];
				const pairs = Array.from(this.#conf.dirSet.pair.values());
				const isSafe = pairs.every(in_pair => {
					const P = firstNeighbor(radiating[in_pair[0]]);
					const N = firstNeighbor(radiating[in_pair[1]]);
					// player reachs all the way to the board edge, or to the DMZ
					if ((P === null) || (P === cReversi.#dmz)) {
						return true;
					}
					if ((N === null) || (N === cReversi.#dmz)) {
						return true;
					}
					// both sides are bordered by the same object
					if (P === N) {
						return true;
					}
					return false;
				});
				count += isSafe ? 1 : 0;
			}
		}
		(rollback)();
		return count;
	}
	#countNextOwnedArea(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const count = this.#count(in_player);
		(rollback)();
		return count;
	}
	#calculateNextScore(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		let score = 0;
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) === in_player) {
				score += this.#getAreaScore(in_player, ix);
			}
		}
		(rollback)();
		return score;
	}
	static #randomizeCnt = 5;
	#npc_min_enemy_option(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextEnemyOption(in_player, in_ix) * -1;
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_option(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOption(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_owned_safe_area(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOwnedSafeArea(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_owned_area(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOwnedArea(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_score_smart(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#getAreaScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_score_total(in_player, in_candArr) {
		const evaluator = (in_player, in_ix) => {
			return this.#calculateNextScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_score_spot(in_player, in_candArr) {
		const evaluator = (in_player, in_ix) => {
			return this.#getAreaScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_random(in_player, in_candArr) {
		return in_candArr[arrRand]();
	}
	#npcSet = {
		spiteful : this.#npc_min_enemy_option,
		balance : this.#npc_max_option,
		safety : this.#npc_max_owned_safe_area,
		greedy : this.#npc_max_owned_area,
		learner : this.#npc_score_smart,
		classic : this.#npc_score_total,
		beginner : this.#npc_score_spot,
		monkey : this.#npc_random
	}
	_simulation(in_repeat = 13) {
		const truncateDecimal = (in_value, in_digit) => {
			const order = 10 ** in_digit;
			return Math.floor(in_value * order) / order;
		};
		const test = (in_argoArr) => {
			let cnt = 100;
			while (true) {
				const resultArr = [];
				for (let i = 0; i < in_argoArr.length; i++) {
					resultArr[i] = this.npc(i, in_argoArr[i]);
				}
				if (resultArr.some(in_result => in_result)) {
					if (cnt-- === 0) {
						break;
					}
				} else {
					break;
				}
				// this.dp();
			}
			let max = -Infinity;
			let winner = -1;
			const cond = this.getCurrentCondition();
			for (let i = 0; i < cond.players.length; i++) {
				if (cond.players[i].score > max) {
					max = cond.players[i].score;
					winner = i;
				}
			}
			return winner;
		};
		const rollback = this.#createRollback();
		// start simulation
		const table = [];
		table.push(['(vs)', ...Object.keys(this.#npcSet)]);
		Object.keys(this.#npcSet).forEach(p1 => {
			const row = [p1];
			Object.keys(this.#npcSet).forEach(p2 => {
				const players = [p1, p2];
				if (p1 === p2) {
					row.push('-');
					return;
				}
				let cnt = in_repeat;
				let win = 0;
				while (true) {
					if (cnt-- > 0) {
						if (test(players) === 0) {
							win++;
						}
						this.#initAreaScores();
						this.#history.length = 0;
						(rollback)();
					} else {
						break;
					}
				}
				row.push(truncateDecimal(win / in_repeat, 2));
				this.#initAreaScores();
				this.#history.length = 0;
				(rollback)();
			});
			table.push(row);
		});
		const elem = (in_table => {
			const ret = document.createElement('TABLE');
			in_table.forEach(in_row => {
				const row = document.createElement('TR');
				in_row.forEach(in_cell => {
					const cell = document.createElement('TD');
					cell.innerText = in_cell;
					let color = 'eeeeee';
					if (typeof in_cell === 'boolean') {
						if (in_cell) {
							color = 'ccccff';
						} else {
							color = 'ffcccc';
						}
					} else {
						if (typeof in_cell === 'number') {
							if (in_cell > 0.5) {
								color = 'ccccff';
							} else {
								color = 'ffcccc';
							}
						}
					}
					cell.style.backgroundColor = color;
					cell.style.textAlign = 'center';
					cell.style.border = '1px solid black';
					cell.style.padding = '3px';
					cell.style.width = '5em';
					row.appendChild(cell);
				});
				ret.appendChild(row);
			});
			ret.style.borderCollapse = 'collapse';
			return ret;
		})(table);
		const script = document.currentScript;
		script.parentNode.insertBefore(elem, script.nextSibling);
		let total = 1;
		Object.keys(cReversi.#evaluateStats).forEach(in_key => {
			if (in_key === 'total') {
				total = cReversi.#evaluateStats[in_key];
				return;
			}
			const taking = truncateDecimal(cReversi.#evaluateStats[in_key] / total, 4);
			console.log(in_key + ' : ' + taking);
		});
	}
	_snapshot() {
		const bg = new Map([
			[0, 'red'],
			[1, 'blue'],
			[2, 'green'],
			[3, 'yellow'],
			[cReversi.#empty, 'silver']
		]);
		const rightMargin = 10;
		const cellSize = 20;
		const cellMargin = 5;
		for (let row = 0; row < this.#conf.row.size; row++) {
			for (let col = 0; col < this.#conf.col.size; col++) {
				const color = bg.get(this.#getItemByPos(row, col));
				const id = '_' + row + 'x' + col;
				let cell = document.getElementById(id);
				if (cell) {
					cell.style.backgroundColor = color;
					continue;
				} else {
					cell = document.createElement('DIV');
				}
				let l = rightMargin + (cellSize + cellMargin) * col;
				let t = rightMargin + (cellSize + cellMargin) * row;
				const pair = this.#conf.dirSet.pair;
				if (pair.has(90) && !pair.has(0)) {
					l += (row % 2 === this.#conf.offset ? (cellSize + cellMargin) / 2 : 0);
				}
				if (!pair.has(90) && pair.has(0)) {
					t += (col % 2 === this.#conf.offset ? (cellSize + cellMargin) / 2 : 0);
				}
				Object.assign(cell.style, {
					id : id,
					width : cellSize + 'px',
					height : cellSize + 'px',
					backgroundColor : color,
					border : 'solid gray 1px',
					position : 'absolute',
					left : l + 'px',
					top : t + 'px'
				});
				document.body.appendChild(cell);
			}
		}
	}
	_debug(in_stop = true) {
		const sources = {
			default : this.#area.scores.default,
			occupied : this.#area.items
		};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			sources['p-' + player] = this.#area.scores.players[player];
		}
		Object.keys(sources).forEach(in_key => {
			console.log('*** ' + in_key + ' ***');
			const data = sources[in_key];
			for (let row = 0; row < this.#conf.row.size; row++) {
				const items = [];
				for (let col = 0; col < this.#conf.col.size; col++) {
					const ix = this.#posToIndex(row, col);
					items.push(data[ix]);
				}
				console.log(items);
			}
		});
		if (in_stop) {
			throw new Error();
		}
	}
	pc(in_player, in_row, in_col) {
		const ix = this.#posToIndex(in_row, in_col);
		if (this.#getItemByIndex(ix) !== cReversi.#empty) {
			return false;
		}
		if (this.#flippable(in_player, ix)) {
			this.#choose(in_player, ix);
			return true;
		} else {
			return false;
		}
	}
	npc(in_player, in_argo = null) {
		let npcAlive = false;
		let playerCnt = 0;
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			if (this.#area.items.indexOf(player) >= 0) {
				playerCnt++;
				if (player === in_player) {
					npcAlive = true;
				}
			}
		}
		if (npcAlive) {
			if (playerCnt === 1) {
				// only in_player
				return false;
			}
		} else {
			// in_player is died
			return false;
		}
		if (this.#area.items.indexOf(cReversi.#empty) === -1) {
			// fulfilled
			return false;
		}
		let npcArgo;
		if (in_argo) {
			npcArgo = in_argo;
		} else {
			npcArgo = this.#npcArgoPriority[in_player];
		}
		// console.log(in_player, npcAlive, playerCnt, npcArgo);
		const candidates = this.#searchCandidates(in_player);
		if (candidates.length > 0) {
			const index = (this.#npcSet[npcArgo].bind(this))(in_player, candidates);
			this.#choose(in_player, index);
			return true;
		} else {
			if (this.#conf.rotatable.fixedCol) {
				return this.#npcTryRotate(in_player, 'row');
			}
			if (this.#conf.rotatable.fixedRow) {
				return this.#npcTryRotate(in_player, 'col');
			}
			// can not do anything
			return false;
		}
	}
	canRowWiseLoop() {
		return !this.#conf.row.edge;
	}
	canColWiseLoop() {
		return !this.#conf.col.edge;
	}
	getLast(in_conditions = {}) {
		// in_conditions : {who, action, row, col, target, delta}
		for (let i = this.#history.length - 1; i >= 0; i--) {
			const last = this.#history[i];
			if (Object.keys(in_conditions).some(in_key => in_conditions[in_key] !== last[in_key])) {
				continue;
			} else {
				return last;
			}
		}
		return null;
	}
	getTable() {
		const table = [];
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const pos = this.#indexToPos(ix);
			if (!table[pos.row]) {
				table[pos.row] = [];
			}
			table[pos.row][pos.col] = parseInt(this.#getItemByIndex(ix));
		}
		return table;
	}
	setTable(in_table) {
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const item = in_table[row][col];
				if (cReversi.#validData.indexOf(item) < 0) {
					throw new Error('invalid input');
				} else {
					this.#setItemByPos(row, col, item);
				}
			}
		}
	}
	setActionResult(in_player, in_action, in_table) {
		this.setTable(in_table);
		this.#history.push({
			who : in_player,
			action : in_action,
			row : -1,
			col : -1,
			target : -1,
			delta : -1
		});
	}
	getCurrentCondition() {
		const condition = {
			finished : false,
			players : []
		};
		const canRotate = !(this.#conf.row.edge && this.#conf.col.edge);
		const cnt = {
			activePlayer : 0,
			frozenPlayer : 0
		};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			let score, dead, frozen;
			score = this.#count(player);
			dead = (score === 0);
			if (dead) {
				frozen = true;
			} else {
				const candidates = (this.#searchCandidates(player)).length;
				if ((candidates > 0) || canRotate) {
					cnt.activePlayer++;
					frozen = false;
				} else {
					cnt.frozenPlayer++;
					frozen = true;
				}
			}
			condition.players[player] = {score : score, dead : dead, frozen : frozen};
		}
		condition.finished =
			// only 1 player is active
			(cnt.activePlayer + cnt.frozenPlayer === 1) ||
			// all players are frozen
			(cnt.activePlayer === 0) ||
			// there is no emply
			(this.#emptyCnt() === 0);
		return condition;
	}
}

/*
	the cTurnController class is designed to manage turns in turn-based games like reversi.
*/

class cTurnController {
	#players = new cCyclicValues();
	#active = false;
	#turns = 0;
	registerPlayer(in_turnHook, in_playerId = randomString()) {
		this.#players.push({
			turnHook : in_turnHook,
			playerId : in_playerId
		});
		return in_playerId;
	}
	#turnStart(in_player) {
		this.#turns++;
		in_player.turnHook(in_player.playerId);
	}
	turnEnd() {
		if (!this.#active) {
			return;
		}
		this.#turnStart(this.#players.incrementedValue());
	}
	gameStart() {
		this.#active = true;
		this.#turnStart(this.#players.currValue());
	}
	gameEnd() {
		this.#active = false;
	}
}

/*
	the cColony class related functions provide the ability to create cylinder-shaped threejs objects.
*/

const textureFactory = factoryBuilder((in_w, in_h, in_dmz = false) => {
	const gradationCnt = 4
	// gradationCnt (from black to white)
	const maxDepth = 255;
	const rgbArr = [];
	for (let i = 0; i < gradationCnt; i++) {
		const depth = Math.ceil(maxDepth / gradationCnt * (i + 1));
		rgbArr[i] = 'rgb(' + depth + ',' + depth + ',' + depth + ')';
	}
	// draw and convert using toDataUR
	const canvas = document.createElement('CANVAS');
	canvas.width = in_w;
	canvas.height = in_h;
	const ctx = canvas.getContext('2d');
	for (let i = 0; i < gradationCnt; i++) {
		if (in_dmz) {
			ctx.strokeStyle = rgbArr[gradationCnt - i - 1];
			ctx.fillStyle = rgbArr[gradationCnt - i - 1];
			if (i > 0) {
				ctx.lineWidth = (gradationCnt - i) * 2 - 1;
				ctx.beginPath();
				ctx.moveTo(0, 0);
				ctx.lineTo(in_w, in_h);
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo(in_w, 0);
				ctx.lineTo(0, in_h);
				ctx.stroke();
			} else {
				ctx.fillRect(0, 0, in_w, in_h);
			}
		} else {
			/*
				Rect           RoundRect      RoundRect

				##########     ##########     ##########
				##########     ##******##     ##******##
				##########     #********#     #**++++**#
				##########     #********#     #*++++++*#
				########## --> #********# --> #*++++++*# --> ...
				##########     #********#     #*++++++*#
				##########     #********#     #**++++**#
				##########     ##******##     ##******##
				##########     ##########     ##########
			*/
			const radius = gradationCnt + 2;
			ctx.fillStyle = rgbArr[i];
			if (i > 0) {
				ctx[fillRoundRect](i, i, in_w - i * 2, in_h - i * 2, radius - i);
			} else {
				ctx.fillRect(i, i, in_w - i * 2, in_h - i * 2);
			}
		}
	}
	return (new THREE.TextureLoader()).load(canvas.toDataURL());
});

const surfaceFactory = factoryBuilder((in_color, in_size, in_type) => {
	const material = new THREE.MeshLambertMaterial();
	material.color = new THREE.Color(in_color);
	switch (in_type) {
	case 'normal-texture' :
		material.map = textureFactory.create(in_size, in_size, false);
		break;
	case 'dmz-texture' :
		material.map = textureFactory.create(in_size, in_size, true);
		break;
	case 'no-texture' :
	default :
		break;
	}
	return material;
});

const SHELL_COLOR_INDEX = 2;

function shellMaterials(in_size, in_color_main, in_color_back, in_dmz) {
	const materials = [];
	for (let i = 0; i < Object.keys(DIRECTION).length; i++) {
		if (i === SHELL_COLOR_INDEX) {
			const texture = in_dmz ? 'dmz-texture' : 'normal-texture';
			materials.push(surfaceFactory.create(in_color_main, in_size, texture));
		} else {
			materials.push(surfaceFactory.create(in_color_back, in_size, 'no-texture'));
		}
	}
	return materials;
}

function getShellColor(in_object) {
	return in_object.material[SHELL_COLOR_INDEX].color.getHex();
}

function setShellColor(in_object, in_color) {
	const setting = in_object.geometry.parameters;
	return in_object.material[SHELL_COLOR_INDEX] = surfaceFactory.create(in_color, setting.size);
}

const shellGeometryFactory = factoryBuilder((in_size, in_innerRatio, in_thickness) => {
	const radian = 6;
	const outerLen = in_size - radian * 2;
	const innerLen = outerLen * in_innerRatio;
	const thickness = in_thickness - radian * 2;
	const geometry = trapezoidGeometryUtil(outerLen, outerLen, outerLen, innerLen, thickness, radian);
	geometry.parameters = {
		size : in_size,
		innerRatio : in_innerRatio,
		thickness : in_thickness
	};
	return geometry;
});

const GRAY1 = 0x222222;
const GRAY2 = 0x444444;
const GRAY3 = 0x666666;

const BGCOLOR = GRAY1;
const DMZCOLOR = GRAY2;
const EMPTYCOLOR = GRAY3;

const ORANGE = 0xFFAA00;
const RED = 0xFF0000;
const WHITE = 0xFFFFFF;
const YELLOW = 0xFFFF00;
const BLUE = 0x3333FF;
const GREEN = 0x118811;
const LIGHTBLUE = 0x5588FF;
const LIGHTGREEN = 0x55CC55;

const edgeMaterial = new THREE.MeshLambertMaterial({color : BGCOLOR});

const COLONY_SIZE = 400;

const gMeshLevelMap = ((in_diameter) => {
	const map = new cCyclicMap();
	const B = BLUE;
	const R = RED;
	const Y = YELLOW;
	const G = GREEN;
	const D = DMZCOLOR;
	const E = EMPTYCOLOR;
	let shellInfo;
	switch (getParam('type')) {
	case 'hex' :
		shellInfo = [
			{
				name : '14x7x4',
				loop : true,
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E],
					[E,E,E,B,E,E,E],
					[E,E,R,D,B,E,E],
					[E,E,R,R,B,E,E],
					[E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E],
					[E,E,E,G,E,E,E],
					[E,E,Y,D,G,E,E],
					[E,E,Y,Y,G,E,E],
					[E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E]
				]
			},
			{
				name : '15x7x3',
				loop : true,
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[E,E,E,E,E,E,E],
					[E,E,E,Y,E,E,E],
					[E,E,R,Y,B,E,E],
					[E,E,R,Y,B,E,E],
					[E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E],
					[E,E,E,R,E,E,E],
					[E,E,B,R,Y,E,E],
					[E,E,B,R,Y,E,E],
					[E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E],
					[E,E,E,B,E,E,E],
					[E,E,Y,B,R,E,E],
					[E,E,Y,B,R,E,E],
					[E,E,E,E,E,E,E]
				]
			},
			{
				name : '16x8x4',
				loop : true,
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,Y,G,E,E,E],
					[E,E,E,G,Y,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,G,Y,E,E,E],
					[E,E,E,Y,G,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				name : '16x9x4',
				loop : true,
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[E,E,E,E,E,E,E,E,E],
					[E,E,E,Y,B,G,E,E,E],
					[E,E,E,E,R,E,E,E,E],
					[E,E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E,E],
					[E,E,E,R,G,Y,E,E,E],
					[E,E,E,E,B,E,E,E,E],
					[E,E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E,E],
					[E,E,E,B,Y,R,E,E,E],
					[E,E,E,E,G,E,E,E,E],
					[E,E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E,E],
					[E,E,E,G,R,B,E,E,E],
					[E,E,E,E,Y,E,E,E,E],
					[E,E,E,E,E,E,E,E,E]
				]
			}
		];
		break;
	case '4-loop' :
		shellInfo = [
			{
				name : '12x6x4',
				loop : true,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,G,Y,E,E],
					[E,E,Y,G,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '18x6x4',
				loop : true,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,Y,E,E],
					[E,G,R,B,E,E],
					[E,E,Y,G,R,E],

					[E,E,B,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,G,E,E],

					[E,B,Y,R,E,E],
					[E,E,G,B,Y,E],
					[E,E,R,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '16x8x4',
				loop : true,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,G,Y,E,E,E],
					[E,E,E,Y,G,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				name : '20x10x4',
				loop : true,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,E,Y,G,E,E,E,E],
					[E,E,E,Y,E,E,G,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,E,Y,G,E,E,E,E],
					[E,E,E,Y,E,E,G,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E]
				]
			}
		];
		break;
	case '2-loop' :
		shellInfo = [
			{
				name : '12x6x2',
				loop : true,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,R,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '18x6x2',
				loop : true,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,D,E,E],
					[E,E,R,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,B,E,E],
					[E,E,D,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '16x8x2',
				loop : true,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				name : '20x10x2',
				loop : true,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,E,B,R,E,E,E,E],
					[E,E,E,B,E,E,R,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,B,E,E,R,E,E,E],
					[E,E,E,E,B,R,E,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E]
				]
			}
		];
		break;
	case '4-non-loop' :
		shellInfo = [
			{
				name : '6x6x4',
				loop : false,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E],
					[E,E,E,Y,E,E],
					[E,G,R,B,E,E],
					[E,E,Y,G,R,E],
					[E,E,B,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '12x6x4',
				loop : false,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,Y,G,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,Y,G,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '8x8x4',
				loop : false,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,B,E,Y,G,E,E],
					[E,E,G,R,B,E,E,E],
					[E,E,E,Y,G,R,E,E],
					[E,E,R,B,E,Y,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				name : '10x10x4',
				loop : false,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,Y,E,E,E,E],
					[E,E,E,G,R,B,E,E,E,E],
					[E,E,E,E,Y,G,R,E,E,E],
					[E,E,E,E,B,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D]
				]
			}
		];
		break;
	case '2-non-loop' :
	default :
		shellInfo = [
			{
				name : '6x6x2',
				loop : false,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '12x6x2',
				loop : false,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,R,B,E,E],

					[E,E,B,R,E,E],
					[E,E,R,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '8x8x2',
				loop : false,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				name : '10x10x2',
				loop : false,
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,R,E,D,B,E,E,E],
					[E,E,E,D,R,B,E,E,E,E],
					[E,E,E,E,B,R,D,E,E,E],
					[E,E,E,B,D,E,R,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D]
				]
			}
		];
		break;
	}
	shellInfo.forEach(in_shell => {
		const radius = in_diameter / 2;
		const circumf = in_diameter * Math.PI;
		const rows = in_shell.table.length;
		const cols = Math.max(...in_shell.table.map(row => row.length));
		const unitSize = circumf / rows;
		const unitThick = unitSize * 0.3;
		const unitAngle = Math.PI * 2 / rows;
		const geometry = shellGeometryFactory.create(unitSize, ((radius - unitThick) / radius), unitThick);
		const pieces = [];
		/*
			create a cylinder oriented around the x-axis
				row : a position along the circumference of the cylinder
				col : a position along the height of the cylinder
		*/
		for (let row = 0; row < rows; row++) {
			for (let col = 0; col < cols; col++) {
				let x = unitSize * col - unitSize * (cols - 1) / 2;
				let y = (in_diameter / 2 - unitThick) * 1.2;
				const color = in_shell.table[row][col] ?? E;
				const materials = shellMaterials(unitSize, color, BGCOLOR, (color === D));
				materials.push(edgeMaterial);
				const piece = new THREE.Mesh(geometry, materials);
				const pivot = new THREE.Object3D();
				pivot.add(piece);
				piece.position.copy(VEC3(x, y, 0));
				if ((in_shell.format === 'hexFlatTopped') && (col % 2 === in_shell.offsetCol)) {
					pivot.rotateX(unitAngle * (row + 0.5));
				} else {
					pivot.rotateX(unitAngle * row);
				}
				/*
					*** NOTE ***
					you can use matrix,
					to apply rotated position before adding to scene
				*/
				pivot.updateMatrixWorld();
				piece.applyMatrix4(pivot.matrix);
				pivot.remove(piece);
				pieces.push(piece);
			}
		}
		const level_key = {
			name : in_shell.name,
			loop : in_shell.loop,
			format : in_shell.format,
			offset : in_shell.offsetCol
		};
		map.set(level_key, pieces);
	});
	return map;
})(COLONY_SIZE);

/*
	the cBoard is designed to represent a reversi board.
*/

class cColonyBoard extends cColony {
	#makeRotationX(in_rad) {
		return this.settingVal.origin.clone().applyMatrix4((new THREE.Matrix4()).makeRotationX(in_rad));
	}
	setupAllPieces(in_pieces, in_offsetCol = -1) {
		super.setupAllPieces(in_pieces);
		this.settingVal.offset = in_offsetCol;
		if (this.settingVal.offset >= 0) {
			this.settingVal.offset %= 2;
		}
	}
	indexToPiece(in_row, in_col) {
		let row = in_row;
		if ((this.settingVal.offset >= 0) && (in_col % 2 === this.settingVal.offset)) {
			row += 0.5;
		}
		const vec3 = this.#makeRotationX(this.settingVal.unitAngle * row);
		vec3.x += this.settingVal.unitDelta * in_col;
		const piece = this.children.find(in_child => XYZ.every(in_xyz => Math.abs(in_child.position[in_xyz] - vec3[in_xyz]) < cColony.error));
		if (!piece) {
			console.log('indexToPiece failed : ', in_row, in_col);
			throw new Error('');
		}
		return piece;
	}
	pieceToIndex(in_piece) {
		const pos = in_piece.position;
		const col = Math.round((pos.x - this.settingVal.origin.x) / this.settingVal.unitDelta);
		let offset = 0;
		if ((this.settingVal.offset >= 0) && (col % 2 === this.settingVal.offset)) {
			offset = 0.5;
		}
		for (let row = 0; row < this.settingVal.rowsForCircle; row++) {
			const vec3 = this.#makeRotationX(this.settingVal.unitAngle * (row + offset));
			if ((Math.abs(pos.y - vec3.y) < cColony.error) && (Math.abs(pos.z - vec3.z) < cColony.error)) {
				return {row : row, col : col};
			}
		}
		throw new Error('pieceToIndex failed');
	}
	getColorTable() {
		const table = [];
		for (let row = 0; row < this.settingVal.rowsForCircle; row++) {
			table[row] = [];
			for (let col = 0; col < this.settingVal.colsForLength; col++) {
				const piece = this.indexToPiece(row, col);
				table[row].push(getShellColor(piece));
			}
		}
		return table;
	}
	changedPieces(in_table) {
		const changedArr = [];
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const piece = this.indexToPiece(row, col);
				const currColor = getShellColor(piece);
				const nextColor = in_table[row][col];
				if (currColor !== nextColor) {
					changedArr.push({
						piece : piece,
						curr : currColor,
						next : nextColor
					});
				}
			}
		}
		return changedArr;
	}
	makeRotateProgress(in_col, in_delta, in_ending_callback) {
		this.uiDisable();
		const last = this.settingVal.unitAngle * in_delta;
		const x = this.settingVal.origin.x + this.settingVal.unitDelta * in_col;
		const pieces = this.children.filter(in_child => Math.abs(in_child.position.x - x) < cColony.error);
		const group = this.setupGroup(pieces);
		return this.makeAnimationProgress(group, cColony.axes.x, 0, last, in_ratio => {
			if (in_ratio < 1) {
				return;
			}
			this.uiEnable();
			(in_ending_callback)();
		});
	}
}

/*
	gWorld (cSphericalWorld)
		|
		+-- gColony (cColonyBoard)
			|
			+-- gColony.children <--- gMeshLevelMap

	gController (cGameController) : knows the internal structure of the following instances
		|
		+-- gReversi (cReversi) : used for npc algorithm
		|
		+-- gColony : used for user interface
		|
		+-- gWorld : used for animation
*/

const gColony = new cColonyBoard();

const WORLD_RADIUS = COLONY_SIZE * 10;
const WORLD_INIT_ZOOM = WORLD_RADIUS / 2;

const gWorld = new cSphericalWorld(WORLD_RADIUS);
gWorld.add(gColony);
gWorld.moveView(0.5, 0.5);
gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);

let gController = null;
let gReversi = null;

class cGameController {
	static #UNUSED = -1;
	static PC = BLUE;
	static #NPC = [
		RED,
		YELLOW,
		GREEN,
		ORANGE,
		LIGHTBLUE,
		LIGHTGREEN
	];
	#mapping = new Array(10).fill(cGameController.#UNUSED);
	#turnHook = () => {};
	#curIndex = 0;
	#tableSize;
	enableHandler = false;
	// cGameController knows the internal structure of cColonyBoard, cReversi and cSphericalWorld
	constructor(in_playerCnt, in_pc = 0) {
		const colors = Array.from(cGameController.#NPC);
		for (let i = 0; i < in_playerCnt; i++) {
			let color;
			if (i === in_pc) {
				color = cGameController.PC;
			} else {
				color = colors.shift();
			}
			this.#mapping[i] = color;
		}
		// 8, 9 are declared as follows in cReversi
		this.#mapping[8] = DMZCOLOR;
		this.#mapping[9] = EMPTYCOLOR;
		this.setTableSize(-1, -1);
	}
	setTableSize(in_rows, in_cols) {
		// as cColonyBoard and cReversi may not have the same rows and cols, in_rows and in_cols are needed.
		this.#tableSize = {
			rows : in_rows,
			cols : in_cols
		};
	}
	setTurnHook(in_hook) {
		this.#turnHook = in_hook;
	}
	#execTurnHook() {
		const color = this.#mapping[this.#curIndex];
		this.enableHandler = (color === cGameController.PC);
		(this.#turnHook)(this.#curIndex, color, this.enableHandler);
	}
	#incrementIndex() {
		this.#curIndex++;
		if (this.#mapping[this.#curIndex] === cGameController.#UNUSED) {
			this.#curIndex = 0;
		}
	}
	endTurn(in_reversi = null) {
		this.#incrementIndex();
		const cond = in_reversi.getCurrentCondition();
		if (cond.finished) {
			// all players can not do anything
			const winner = cond.players.reduce((in_accum, in_curVal, in_curIndex, in_arr) => {
				return in_curVal.score > in_arr[in_accum].score ? in_curIndex : in_accum;
			}, 0);
			return this.#mapping[winner];
		} else {
			while (true) {
				const {dead, frozen, score} = cond.players[this.#curIndex];
				if (dead || (frozen && !in_reversi.canRowWiseLoop())) {
					// curIndex can not do anything
					this.#incrementIndex();
				} else {
					break;
				}
			}
			// to prevent stack overflow
			setTimeout(() => this.#execTurnHook(), 0);
			// in this context, no winner
			return -1;
		}
	}
	start() {
		this.#execTurnHook();
	}
	end() {
		this.setTurnHook(() => {});
		this.#mapping.fill(cGameController.#UNUSED);
	}
	static #update(in_changedArr) {
		in_changedArr.forEach(in_changed => {
			setShellColor(in_changed.piece, in_changed.next);
		});
	}
	static #updateDynamic(in_changedArr, in_world) {
		// in_changedArr : see cColonyBoard.changedPieces()
		in_changedArr.forEach(in_changed => {
			// backup initial value
			in_changed.initRotationX = in_changed.piece.rotation.x;
		});
		const ease = new cEase(0, Math.PI * 2, 500);
		return new Promise(in_resolved => {
			let updated = false;
			const hook = () => {
				const angle = ease.currentEasingOut();
				if (angle === Math.PI * 2) {
					in_world.removeAnimationHook(hook);
					in_changedArr.forEach(in_changed => {
						// restore initial value
						in_changed.piece.rotation.x = in_changed.initRotationX;
					});
					/*
						execute the process that follows the await (or callback defined in then),
						which corresponds to the then block of a promise
					*/
					(in_resolved)();
					return;
				}
				if ((angle > Math.PI) && (!updated)) {
					SE_MOVED.play();
					cGameController.#update(in_changedArr);
					updated = true;
				}
				in_changedArr.forEach(in_changed => {
					in_changed.piece.rotation.x = in_changed.initRotationX + angle;
				});
			};
			in_world.addAnimationHook(hook);
		});
	}
	#makeChangedArr(in_reversi, in_colony) {
		const indexTable = in_reversi.getTable();
		const colorTable = indexTable.map(in_row => in_row.map(in_cell => this.#mapping[in_cell]));
		// this can handle smaller table than colony
		return in_colony.changedPieces(colorTable);
	}
	reversiToColony(in_reversi, in_colony) {
		const changedArr = this.#makeChangedArr(in_reversi, in_colony);
		cGameController.#update(changedArr);
	}
	async reversiToColonyDynamic(in_reversi, in_colony, in_world) {
		const changedArr = this.#makeChangedArr(in_reversi, in_colony);
		await cGameController.#updateDynamic(changedArr, in_world);
	}
	convertColonyTable(in_colony) {
		const reverse = {};
		this.#mapping.forEach((in_value, in_ix) => {
			reverse[in_value] = in_ix;
		});
		let table = in_colony.getColorTable();
		if ((this.#tableSize.rows > 0) && (this.#tableSize.cols > 0)) {
			// resize to #tableSize
			table = table.slice(0, this.#tableSize.rows).map(in_row => in_row.slice(0, this.#tableSize.cols));
		}
		return table.map(in_row => in_row.map(in_cell => reverse[in_cell]));
	}
	async moveViewTo(in_piece, in_world) {
		const cameraPos = in_world.getCameraPos();
		const angleX = Math.atan2(cameraPos.y, cameraPos.z) - Math.atan2(in_piece.position.y, in_piece.position.z);
		const vec3 = cameraPos.applyMatrix4((new THREE.Matrix4()).makeRotationX(angleX));
		await in_world.motionViewFrom(vec3, 500);
	}
	async #playLastAction(in_reversi, in_colony, in_world) {
		const last = in_reversi.getLast();
		switch (last.action) {
		case 'choose-item' :
			const piece = in_colony.indexToPiece(last.row, last.col);
			await this.moveViewTo(piece, in_world);
			// choose
			setShellColor(piece, this.#mapping[last.who]);
			await this.reversiToColonyDynamic(in_reversi, in_colony, in_world);
			break;
		case 'npc-row-wise-rotate' :
			console.log('rotating', last);
			await (async ()=> {
				return new Promise(in_resolve => {
					const hook = in_colony.makeRotateProgress(last.target, last.delta, () => {
						in_world.removeAnimationHook(hook);
						(in_resolve)();
					});
					in_world.addAnimationHook(hook);
				});
			})();
			break;
		default :
			break;
		}
	}
	async npc(in_reversi, in_colony, in_world) {
		if (in_reversi.npc(this.#curIndex)) {
			await this.#playLastAction(in_reversi, in_colony, in_world);
			return true;
		} else {
			// can't do anything
			return false;
		}
	}
	async pc(in_piece, in_reversi, in_colony, in_world) {
		const resume = this.enableHandler;
		this.enableHandler = false;
		const pos = in_colony.pieceToIndex(in_piece);
		const result = in_reversi.pc(this.#curIndex, pos.row, pos.col);
		if (result) {
			SE_BEEP.play();
			await this.#playLastAction(in_reversi, in_colony, in_world);
		}
		this.enableHandler = resume;
		return result;
	}
	pcRotate(in_reversi, in_colony) {
		const table = this.convertColonyTable(in_colony);
		in_reversi.setActionResult(this.#curIndex, 'pc-row-wise-rotate', table);
	}
}

class cWarpLine {
	static #speed = 10;
	static #gradation = 10;
	constructor(in_canvas) {
		const w = in_canvas.width;
		const h = in_canvas.height;
		this.ctx = in_canvas.getContext('2d');
		this.box = new THREE.Box2(
			new THREE.Vector2(0, 0),
			new THREE.Vector2(w, h)
		);
		this.from = new THREE.Vector2(w / 2, h / 2);
		this.#reset();
	}
	#reset() {
		const angle = Math.random() * Math.PI * 2;
		this.direction = new THREE.Vector2(Math.cos(angle), Math.sin(angle));
		this.speed = Math.random() * cWarpLine.#speed + 5;
		this.length = 0;
	}
	#curVec(in_scalar) {
		return this.from.clone().add(this.direction.clone().multiplyScalar(in_scalar));
	}
	#drawGrayLine(in_from, in_to, in_grayScale) {
		const gray = (in_grayScale << 16) | (in_grayScale << 8) | in_grayScale;
		this.ctx.strokeStyle = '#' + gray.toString(16).padStart(6, '0');
		this.ctx.beginPath();
		this.ctx.moveTo(in_from.x, in_from.y);
		this.ctx.lineTo(in_to.x, in_to.y);
		this.ctx.stroke();
	}
	update() {
		this.length += this.speed;
		const to = this.#curVec(this.length);
		if (this.box.containsPoint(to)) {
			const notch = this.length / cWarpLine.#gradation;
			for (let i = 0; i < cWarpLine.#gradation; i++) {
				this.#drawGrayLine(
					this.#curVec(notch * i),
					this.#curVec(notch * (i + 1)),
					255 / cWarpLine.#gradation * (i + 1)
				);
			}
		} else {
			/*
				*** NOTE ***
				even if overwritung using black,
				this.#drawGrayLine(this.from, to, 0x00);
				smudge of white line will remain.
			*/
			this.#reset();
		}
	}
}

function warpViewProgress(in_canvas, in_lineCount) {
	const warpLines = [];
	for (let i = 0; i < in_lineCount; i++) {
		warpLines.push(new cWarpLine(in_canvas));
	}
	return () => {
		warpLines.forEach(in_line => {
			in_line.update();
		});
	}
}

function complete(in_player) {
	gController.end();
	gOrderChar.style.visibility = 'hidden';
	const progress = warpViewProgress(gBackgroundCanvas, 50);
	gWorld.addAnimationHook(progress);
	const duration = 2000;
	gWorld.motionZoom2(WORLD_RADIUS * 1.5, duration * 0.9);
	setTimeout(() => {
		gWorld.removeAnimationHook(progress);
		const dialog = document.createElement('div');
		Object.assign(dialog.style, {
			width : 'auto',
			height : 'auto',
			color : 'white',
			background : 'black',
			borderRadius : '1em',
			padding : '1.5em'
		});
		([
			'<div>Winner is ...</div>',
			'<div style="text-align:center"><img src="' + RES.get(in_player) + '" /></div>',
			'<div>Thanks to your wisdom, peace in the universe has been preserved.</div>',
			'<div>Click to go next stage.</div>',
		]).forEach(in_fragment => {
			dialog.innerHTML += in_fragment;
		});
		startDialog(dialog, async () => {
			drawCosmicView(gBackgroundCanvas, 400, 50);
			await nextLevel(false);
			gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);
		});
	}, duration);
}

const gOrderChar = (() => {
	const elem = document.createElement('IMG');
	const maxInt = 2 ** 31 - 1;
	Object.assign(elem.style, {
		position : 'absolute',
		bottom : '20px',
		right : '20px',
		width : '100px',
		height : 'auto',
		zIndex : maxInt
	});
	document.body.appendChild(elem);
	return elem;
})();

function initializeByLevel() {
	const curr = gMeshLevelMap.currItemByOrder();
	const [rows, cols, players] = curr.k.name.split('x');
	const edge = {
		row : !(curr.k.loop),
		col : true
	};
	const pc = 0;
	gController = new cGameController(players, pc);
	/*
		setTableSize() enables separation between the reversi logic (with edge/DMZ)
		and the visual structure defined in gMeshLevelMap
	*/
	gController.setTableSize(rows, cols);
	const table = gController.convertColonyTable(gColony);
	if (curr.k.offset >= 0) {
		gReversi = new cReversi(table, edge.row, edge.col, curr.k.format, curr.k.offset);
	} else {
		gReversi = new cReversi(table, edge.row, edge.col, curr.k.format);
	}
	gController.setTurnHook(async (in_player, in_color, in_pc) => {
		gOrderChar.style.visibility = 'visible';
		gOrderChar.src = RES.get(in_color);
		if (in_pc) {
			const last = gReversi.getLast({who : pc, action : 'choose-item'});
			if (last) {
				const piece = gColony.indexToPiece(last.row, last.col);
				await gController.moveViewTo(piece, gWorld);
			}
			return;
		}
		const acted = await gController.npc(gReversi, gColony, gWorld);
		const winner = gController.endTurn(gReversi);
		if (winner < 0) {
			return;
		}
		complete(winner);
	});
	gController.reversiToColony(gReversi, gColony);
	gController.start();
}

(in_level => {
	if (in_level === false) {
		gMeshLevelMap.setOrder(2);
	} else {
		gMeshLevelMap.setOrder(in_level);
	}
})(getParam('level'));

const ID_PREV_LEVEL = randomString();
const ID_NEXT_LEVEL = randomString();

async function updateLevel() {
	const color = 0x000000;
	await gWorld.motionFog(color, 0, 100);
	gColony.removePieces();
	const curr = gMeshLevelMap.currItemByOrder();
	if (curr.k.offset >= 0) {
		gColony.setupAllPieces(curr.v, curr.k.offset);
	} else {
		gColony.setupAllPieces(curr.v);
	}
	await gWorld.motionFog(color, 100, 0);
	const prev = gMeshLevelMap.prevItemByOrder();
	const next = gMeshLevelMap.nextItemByOrder();
	document.getElementById(ID_PREV_LEVEL).innerText = prev.k.name;
	document.getElementById(ID_NEXT_LEVEL).innerText = next.k.name;
	resetFocus();
	initializeByLevel();
}

updateLevel();

/*
	*** NOTE ***
	in Safari, using await to get audio will cause the process to fail.
	I'm not sure of the reason, but top-level await might be the cause.
	this time use then() to avoid the issue.
*/

let SE_BEEP = beep(2000);
let SE_DUMMY = beep(10);
let SE_MOVED = SE_BEEP;
let SE_ERROR = SE_BEEP;

SOUND.MOVED.then(in_decompress => {
	SE_MOVED = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

SOUND.ERROR.then(in_decompress => {
	SE_ERROR = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

function uiHelp() {
	const url = {
		ver : './version.txt',
		img : './side-six-reversi-help.gif',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div><img src="' + url.img + '" /></div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getResource(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.error(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		color : 'white',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Rights</dt>',
		'<dd>This software is based on MIT License.</dd>',
		'<dd>The code can be freely modified and reused.</dd>',
		'<dd>For full license details, please refer to :</dd>',
		'<dd>https://opensource.org/licenses/MIT</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	startDialog(dialog);
}

async function prevLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	gMeshLevelMap.shiftOrder(-1);
	await updateLevel();
}

async function nextLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	gMeshLevelMap.shiftOrder(+1);
	await updateLevel();
}

(in_settings => {
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	in_settings.forEach(in_setting => {
		let button = document.createElement('button');
		if (in_setting.id) {
			button.id = in_setting.id;
		}
		if (in_setting.text) {
			button.innerText = in_setting.text;
		}
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})([
	{
		id : ID_PREV_LEVEL,
		text : '(Prev)',
		func : prevLevel
	},
	{
		id : ID_NEXT_LEVEL,
		text : '(Next)',
		func : nextLevel
	},
	{
		text : 'help',
		func : uiHelp
	},
	{
		text : 'rights',
		func : uiRights
	}
]);

function hex2rgb(in_hex) {
	const mask = 0xFF;
	const r = (in_hex >> 16) & mask;
	const g = (in_hex >> 8) & mask;
	const b = in_hex & mask;
	return [r, g, b];
}

function drawCosmicView(in_canvas, in_stars, in_nebulae_patterns, in_color = 0x000064) {
	const ctx = in_canvas.getContext('2d');
	const w = in_canvas.width;
	const h = in_canvas.height;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	for (let i = 0; i < in_nebulae_patterns; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 100 + 50;
		const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
		const rgb = hex2rgb(in_color);
		gradient.addColorStop(0, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0.5)');
		gradient.addColorStop(1, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0)');
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = gradient;
		ctx.fill();
	}
	for (let i = 0; i < in_stars; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 1;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = 'white';
		ctx.fill();
	}
}

/*
	event handlers
*/

function drawBackground(in_canvas) {
	Object.assign(in_canvas.style, {
		position : 'absolute',
		left : 0,
		top : 0,
		zIndex : -1
	});
	drawCosmicView(in_canvas, 400, 50);
}

const gBackgroundCanvas = document.createElement('CANVAS');

function setupBody(in_document) {
	if (!in_document.body) {
		in_document.documentElement.appendChild(in_document.createElement('BODY'));
	}
	Object.assign(in_document.body.style, {
		margin : '0',
		overflow : 'hidden'
	});
}

function createChildWindow(in_document) {
	return new Promise(in_callback => {
		setupBody(in_document);
		const iframe = in_document.createElement('iframe');
		in_document.body.appendChild(iframe);
		Object.assign(iframe.style, {
			width: '100%',
			height: '100%',
			border: 'none'
		});
		/*
			*** NOTE ***
			although Chrome can use iframe.contentDocument right after createElement,
			Firefox can not use it ant needs to use asynchronous process.
			by the way, if you use not timer but load event,
			your code will not work for Chrome.
		*/
		setTimeout(() => {
			setupBody(iframe.contentDocument);
			(in_callback)(iframe.contentWindow);
		}, 0);
	});
}

document.addEventListener('DOMContentLoaded', (async () => {
	/*
		*** NOTE ***
		without iframe (outer window),
		geometry in event will be wrong because of google ads
	*/
	const outer = await createChildWindow(document);
	let resizeWorld = in_ev => {
		gWorld.resize(outer.innerWidth, outer.innerHeight);
		gBackgroundCanvas.width = outer.innerWidth;
		gBackgroundCanvas.height = outer.innerHeight;
		drawBackground(gBackgroundCanvas);
	};
	outer.addEventListener('resize', debouncing(resizeWorld, 300));
	outer.dispatchEvent(new Event('resize'));
	outer.document.body.appendChild(gWorld.canvas);
	outer.document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

const knock = nonReentrantAsync(async () => {
	SE_ERROR.play();
	await gWorld.motionKnock();
});

const notifyDelta = (() => {
	const RC = cColony.uiSetDeltaPositionRC;
	return in_ndc => {
		const intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			return;
		}
		const result = gColony.uiNotifyDeltaPosition(intersects[0].object, intersects[0].point, ndcToAbs(in_ndc));
		if (result === RC.UNMOVABLE) {
			knock();
		}
	}
})();

const focusHere = (() => {
	let focusedEmpty = null;
	const HIGHLIGHT = (new THREE.Color(EMPTYCOLOR)).lerp(new THREE.Color(0xFFFFFF), 0.3).getHex();
	return in_ndc => {
		let current, color;
		let intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length > 0) {
			current = intersects[0].object;
			color = getShellColor(current);
		} else {
			current = null;
			color = -1;
		}
		if ((color === EMPTYCOLOR) || (color === HIGHLIGHT)) {
			if (current === focusedEmpty) {
				return;
			}
			setShellColor(current, HIGHLIGHT);
			if (focusedEmpty) {
				setShellColor(focusedEmpty, EMPTYCOLOR);
			}
			focusedEmpty = current;
		} else {
			if (focusedEmpty) {
				setShellColor(focusedEmpty, EMPTYCOLOR);
			}
			focusedEmpty = null;
		}
	}
})();

function resetFocus() {
	const outOfRange = new THREE.Vector2(Infinity, Infinity);
	focusHere(outOfRange);
}

function rotateDone() {
	resetFocus();
	gController.pcRotate(gReversi, gColony);
	gController.endTurn(gReversi);
}

async function chooseHere(in_ev) {
	const ndc = ndcFromEvent(in_ev);
	let intersects = gWorld.intersectPositive(ndc);
	if (intersects.length === 0) {
		return;
	}
	resetFocus();
	const curr = intersects[0].object;
	if (getShellColor(curr) !== EMPTYCOLOR) {
		knock();
	} else {
		if (await gController.pc(curr, gReversi, gColony, gWorld)) {
			const winner = gController.endTurn(gReversi);
			if (winner < 0) {
				return;
			}
			complete(winner);
		} else {
			knock();
		}
	}
}

(() => {
	const closure = {
		x : -1,
		y : -1,
		once : false
	};
	const start = in_ev => {
		if (!closure.once) {
			/*
				*** NOTE ***
				Safari may restrict sound without user interaction.
				because of this, the sound does not work without this code.
			*/
			SE_DUMMY.play();
			closure.once = true;
		}
		const ndc = ndcFromEvent(in_ev);
		const intersects = gWorld.intersectPositive(ndc);
		if (intersects.length === 0) {
			return;
		}
		resetFocus();
		closure.x = in_ev.clientX;
		closure.y = in_ev.clientY;
		// can drag only cGameController.PC
		const drag = intersects[0].object
		if (gReversi.canRowWiseLoop() && (getShellColor(drag) === cGameController.PC)) {
			gColony.uiSetInitPosition(intersects[0].point, ndcToAbs(ndc));
		}
	};
	const move = thresholding(in_ev => {
		closure.x = -1;
		closure.y = -1;
		const ndc = ndcFromEvent(in_ev);
		if (gColony.uiIsMoving()) {
			if (gColony.uiUpdatePosition(ndcToAbs(ndc))) {
				SE_MOVED.play();
			}
		} else {
			if (gColony.uiIsDragging()) {
				notifyDelta(ndc);
			} else {
				if (!in_ev[isEmulated]) {
					focusHere(ndc);
				}
			}
		}
	});
	const stop = in_ev => {
		const releaseProgress = gColony.uiRelease(in_changed => {
			gWorld.removeAnimationHook(releaseProgress);
			if (in_changed) {
				rotateDone();
			}
		});
		if (releaseProgress) {
			gWorld.addAnimationHook(releaseProgress);
		} else {
			if ((closure.x !== in_ev.clientX) || (closure.y !== in_ev.clientY)) {
				return;
			}
			chooseHere(in_ev);
		}
	};
	let handlers = {
		'mousedown' : start,
		'mousemove' : move,
		'mouseleave' : stop,
		'mouseout' : stop,
		'mouseup' : stop
	};
	for (let [name, func] of Object.entries(handlers)) {
		gWorld.canvas.addEventListener(name, in_ev => {
			if (gController && gController.enableHandler) {
				(func.bind(this))(in_ev);
			}
		});
	}
})();

</script>
</body>
</html>
