<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports" : {
		"three" : "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.min.js",
		"utils" : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/utils/BufferGeometryUtils.js",
		"basic" : "./basic-functions.js",
		"side6" : "./side-six.js",
		"s6res" : "./side-six-reversi-res.js",
		"sound" : "./sound-effect.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';
import {
	getResource,
	postResource,
	getParam,
	DEBUG,
	randomString,
	snapToNotch,
	snapToPI,
	snapTo05PI,
	createPeriodicSin,
	createPeriodicCos,
	pseudoMessageDigest1,
	pseudoMessageDigest2,
	beep,
	isEmulated,
	throttling,
	thresholding,
	debouncing,
	nonReentrantAsync,
	autoTransition,
	startDialog,
	factoryBuilder,
	arrRand,
	arrTrim,
	cEase,
	cApproximateMap,
	cApproximateSet,
	cCyclicMap,
	cCyclicValues,
	forEachCombination,
	clipArea,
	clipClearArea,
	fillRoundRect,
	XYZ,
	VEC3,
	DIRECTION,
	ndcFromEvent,
	ndcToAbs,
	getWorldVec3,
	getWorldUp,
	instanceInAncestor,
	lookAtWithoutRotation,
	safeMergeGeometry,
	makeTrapezoidGeometryParts,
	trapezoidGeometryUtil,
	roundBoxGeometry,
	roundRegularBoxGeometry,
	roundTrapezoidGeometry,
	capsuleConfigure,
	customCapsuleGeometry,
	cSphericalWorld
} from 'basic';
import {
	cColony
} from 'side6';
import {
	RES
} from 's6res';
import * as SOUND from 'sound';

/*
	the cReversi class is designed to implement NPC algorithms for the game of reversi.
*/

class cLineParser {
	static #border = -1;
	static #empty = 9;
	static #cntEmpty(in_arr) {
		return in_arr.filter(in_el => in_el === cLineParser.#empty).length;
	}
	static #findOneInnerEmpty(in_arr) {
		let emptyAppear = false;
		for (let i = 1; i < in_arr.length - 1; i++) {
			if (emptyAppear) {
				if (in_arr[i] === cLineParser.#empty) {
					return false;
				} else {
					return true;
				}
			}
			if (in_arr[i] === cLineParser.#empty) {
				emptyAppear = true;
			}
		}
		return false;
	}
	/*
		fmt_eXXXXX is for edge
	*/
	static #fmt_eCriticalToMe(in_l, in_r) {
		// B90011 ---> [B9][11]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty)) {
			if (in_r[0] !== cLineParser.#empty) {
				return true;
			}
		}
		return false;
	}
	static #fmt_ePreRiskToMe(in_l, in_r) {
		// B90090 ---> [B9][9]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty)) {
			if ((in_r.length === 1) &&
				(in_r[0] === cLineParser.#empty)) {
				return true;
			}
		}
		return false;
	}
	static #fmt_ePressureToMe(in_l, in_r) {
		// B900191 ---> [B9][191]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border)) {
			return cLineParser.#fmt_bPressureToMe(in_l, in_r);
		}
		return false;
	}
	static #fmt_ePrePressureToMe(in_l, in_r) {
		// B909191 ---> [B9][9191]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border)) {
			return cLineParser.#fmt_bPrePressureToMe(in_l, in_r);
		}
		return false;
	}
	static #fmt_ePressureByMe(in_l, in_r) {
		// B911090 ---> [B911][9]
		if ((in_l.length >= 3) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty) &&
			(cLineParser.#cntEmpty(in_l) === 1)) {
			return cLineParser.#fmt_bPressureByMe(in_l, in_r);
		}
		return false;
	}
	/*
		fmt_bXXXXX is for both edge and inner
	*/
	static #fmt_bPressureToMe(in_l, in_r) {
		// 9900191 ---> [99][191]
		if (in_l[in_l.length - 1] === cLineParser.#empty) {
			if ((in_r.length >= 3) &&
				(in_r[0] !== cLineParser.#empty)) {
				return cLineParser.#findOneInnerEmpty(in_r);
			}
		}
		return false;
	}
	static #fmt_bPrePressureToMe(in_l, in_r) {
		// 9909191 ---> [99][9191]
		if (in_l[in_l.length - 1] === cLineParser.#empty) {
			if ((in_r.length >= 3) &&
				(in_r[0] === cLineParser.#empty)) {
				return cLineParser.#findOneInnerEmpty(in_r);
			}
		}
		return false;
	}
	static #fmt_bPressureByMe(in_l, in_r) {
		// 9911090 ---> [9911][9]
		if ((in_l[in_l.length - 1] !== cLineParser.#empty) &&
			(cLineParser.#cntEmpty(in_l) >= 1)) {
			if ((in_r.length === 1) &&
				(in_r[0] === cLineParser.#empty)) {
				return true;
			}
		}
		return false;
	}
	static #fmt_bInnerByMe(in_l, in_r) {
		// 110199 --> [11][199]
		if ((in_l[in_l.length - 1] === in_r[0]) &&
			(in_r[0] !== cLineParser.#empty)) {
			return true;
		}
		return false;
	}
	static parse(in_items, in_player, in_loop, in_debug = false) {
		const parsed = {
			eCriticalToMe : false,
			ePreRiskToMe : false,
			ePressureToMe : false,
			ePrePressureToMe : false,
			ePressureByMe : false,
			bFulfilledWith : false,
			bPressureToMe : false,
			bPrePressureToMe : false,
			bPressureByMe : false,
			bPreOuterByMe : false,
			bOuterByMe : false,
			bInnerByMe : false,
			safetyScore : 0
		};
		let items;
		if (in_loop) {
			items = [...in_items];
		} else {
			items = [cLineParser.#border, ...in_items, cLineParser.#border];
		}
		if (items.indexOf(in_player) === -1) {
			return parsed;
		}
		/*
			(1) as in_player should be exist from here, split array using in_player

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : [12],[34]
				ex2 (loop) : [12],[34],[]
				ex3 (loop) : [],[12],[34],[]

				ex1 (non-loop) : [B12],[45B]
				ex2 (non-loop) : [B12],[34],[B]
				ex3 (non-loop) : [B],[12],[34],[B]
		*/
		let meMaxIx = 0;
		let meStart = false;
		// the 1st item may be empty
		const subsets = [[]];
		parsed.bFulfilledWith = true;
		for (let i = 0; i < items.length; i++) {
			if (items[i] === in_player) {
				if (meStart) {
					continue;
				} else {
					meStart = true;
					// the last item may be empty
					subsets[++meMaxIx] = [];
				}
			} else {
				meStart = false;
				if (items[i] === cLineParser.#empty) {
					parsed.bFulfilledWith = false;
				}
				subsets[meMaxIx].push(items[i]);
			}
		}
		if (parsed.bFulfilledWith) {
			return parsed;
		}
		/*
			(2) relate left side / right side to in_player

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : L[12]+R[34]
				ex2 (loop) : L[12]+R[34], L[34]+R[]
				ex3 (loop) : L[]+R[12],L[12]+R[34],L[34]+R[]

				ex1 (non-loop) : L[B12]+R[45B]
				ex2 (non-loop) : L[B12]+R[34],L[34]+R[B]
				ex3 (non-loop) : L[B]+R[12],L[12]+R[34],L[34]+R[B]
		*/
		const meNodes = [];
		for (let i = 0; i < meMaxIx; i++) {
			meNodes[i] = {
				L : subsets[i],
				R : subsets[i + 1]
			};
		}
		/*
			(3) normalize

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : L[3412]+R[3412]
				ex2 (loop) : L[12]+R[34],L[34]+R[12]
				ex3 (loop) : L[34]+R[12],L[12]+R[34]

				ex1 (non-loop) : L[B12]+R[45B]
				ex2 (non-loop) : L[B12]+R[34],L[34]+R[B]
				ex3 (non-loop) : L[B]+R[12],L[12]+R[34],L[34]+R[B]
		*/
		const meFirst = meNodes[0];
		const meLast = meNodes[meNodes.length - 1];
		if (in_loop) {
			if ((meFirst.L.length === 0) && (meLast.R.length === 0)) {
				meFirst.L = [...meLast.L];
				meNodes.pop();
			} else {
				meFirst.L = [...meLast.R, ...meFirst.L];
				meLast.R = meFirst.L;
			}
		}
		/*
			(4) bPreOuterByMe, bOuterByMe
		*/
		if (in_loop) {
			for (let i = 0; i < meNodes.length; i++) {
				const cnt = cLineParser.#cntEmpty(meNodes[i].L);
				parsed['bPreOuterByMe'] ||= (cnt === 1);
				parsed['bOuterByMe'] ||= (cnt === 0);
			}
		} else {
			// except for both edges
			for (let i = 1; i < subsets.length - 1; i++) {
				const cnt = cLineParser.#cntEmpty(subsets[i]);
				parsed['bPreOuterByMe'] ||= (cnt === 1);
				parsed['bOuterByMe'] ||= (cnt === 0);
			}
		}
		/*
			(5) calculate score + check format
		*/
		const formatArr = [
			['eCriticalToMe', cLineParser.#fmt_eCriticalToMe],
			['ePreRiskToMe', cLineParser.#fmt_ePreRiskToMe],
			['ePressureToMe', cLineParser.#fmt_ePressureToMe],
			['ePrePressureToMe', cLineParser.#fmt_ePrePressureToMe],
			['ePressureByMe', cLineParser.#fmt_ePressureByMe],
			['bPressureToMe', cLineParser.#fmt_bPressureToMe],
			['bPrePressureToMe', cLineParser.#fmt_bPrePressureToMe],
			['bPressureByMe', cLineParser.#fmt_bPressureByMe],
			['bInnerByMe', cLineParser.#fmt_bInnerByMe]
		];
		for (let i = 0; i < meNodes.length; i++) {
			const curr = meNodes[i];
			const neighborL = curr.L[curr.L.length - 1];
			const neighborR = curr.R[0];
			if ((neighborL === neighborR) ||
				(neighborL === cLineParser.#border) ||
				(neighborR === cLineParser.#border)) {
				parsed.safetyScore += 1;
			} else {
				parsed.safetyScore -= 1;
			}
			const reversedR = curr.R.toReversed();
			const reversedL = curr.L.toReversed()
			formatArr.forEach(([in_format, in_checker]) => {
				if (parsed[in_format]) {
					return;
				}
				const toL = (in_checker)(curr.L, curr.R);
				const toR = (in_checker)(reversedR, reversedL);
				parsed[in_format] = toL || toR;
			});
		}
		return parsed;
	}
}

(in_test => {

if (!in_test) {
	return;
}

const suites = [

	{group : '*** 1. there is no pc ***'},

		{items : [9,9,9,9,9,9,9,9], loop : false, safetyScore : 0, dp : false},
		{items : [9,9,9,9,1,2,1,2], loop : false, safetyScore : 0, dp : false},
		{items : [1,2,1,2,1,2,1,2], loop : false, safetyScore : 0, dp : false},

		{items : [9,9,9,9,9,9,9,9], loop : true, safetyScore : 0, dp : false},
		{items : [9,9,9,9,1,2,1,2], loop : true, safetyScore : 0, dp : false},
		{items : [1,2,1,2,1,2,1,2], loop : true, safetyScore : 0, dp : false},

	{group : '*** 2. no empty ***'},

		{items : [0,0,0,0,0,0,0,0], loop : false, safetyScore : 0, dp : false},
		{items : [1,2,1,2,0,0,0,0], loop : false, safetyScore : 0, dp : false},

		{items : [0,0,0,0,0,0,0,0], loop : true, safetyScore : 0, dp : false},
		{items : [1,2,1,2,0,0,0,0], loop : true, safetyScore : 0, dp : false},

	{group : '*** 3. pc is on the left side ***'},

		{items : [0,9,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
		{items : [0,9,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},

		{items : [0,9,9,9,9,9,9,9], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,9], loop : true, safetyScore : -1, dp : false},
		{items : [0,9,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
		{items : [0,1,9,9,9,9,9,1], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,2], loop : true, safetyScore : -1, dp : false},

	{group : '*** 4. pc is on the right side ***'},

		{items : [9,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
		{items : [9,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},
		{items : [1,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
		{items : [1,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},

		{items : [9,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
		{items : [9,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,1,0], loop : true, safetyScore : 0, dp : false},
		{items : [2,0,9,9,9,9,1,0], loop : true, safetyScore : -2, dp : false},

	{group : '*** 5. pc is on the both sides ***'},

		{items : [0,9,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,1,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,9,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},

		{items : [0,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
		{items : [0,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : true, safetyScore : 1, dp : false},
		{items : [0,2,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},

	{group : '*** 6. npc is on the both sides ***'},

		{items : [1,9,9,9,9,9,9,1], loop : false, safetyScore : 0, dp : false},
		{items : [1,0,9,9,9,9,9,1], loop : false, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,0,1], loop : false, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,0,1], loop : false, safetyScore : -2, dp : false},

		{items : [1,9,9,9,9,9,9,1], loop : true, safetyScore : 0, dp : false},
		{items : [1,0,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,0,1], loop : true, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,0,1], loop : true, safetyScore : -2, dp : false},

	{group : '*** 7. bFulfilledWith ***'},

		{items : [1,1,1,1,1,1,1,1], loop : false, bFulfilledWith : false, dp : false},
		{items : [1,1,1,9,0,1,1,1], loop : false, bFulfilledWith : false, dp : false},
		{items : [1,1,1,0,0,1,1,1], loop : false, bFulfilledWith : true, dp : false},
		{items : [0,0,0,0,0,0,0,0], loop : false, bFulfilledWith : true, dp : false},
		{items : [0,0,0,9,0,0,0,0], loop : false, bFulfilledWith : false, dp : false},

		{items : [1,1,1,1,1,1,1,1], loop : true, bFulfilledWith : false, dp : false},
		{items : [1,1,1,9,0,1,1,1], loop : true, bFulfilledWith : false, dp : false},
		{items : [1,1,1,0,0,1,1,1], loop : true, bFulfilledWith : true, dp : false},
		{items : [0,0,0,0,0,0,0,0], loop : true, bFulfilledWith : true, dp : false},
		{items : [0,0,0,9,0,0,0,0], loop : true, bFulfilledWith : false, dp : false},

	{group : '*** 8. bOuterByMe ***'},

		{items : [0,1,0,9,9,9,9,9], loop : false, bOuterByMe : true, dp : false},
		{items : [1,0,9,9,9,9,9,0], loop : false, bOuterByMe : false, dp : false},
		{items : [0,9,9,9,9,9,0,1], loop : false, bOuterByMe : false, dp : false},
		{items : [9,9,9,9,9,0,1,0], loop : false, bOuterByMe : true, dp : false},
		{items : [9,9,0,1,2,0,9,9], loop : false, bOuterByMe : true, dp : false},
		{items : [2,0,9,9,9,9,0,1], loop : false, bOuterByMe : false, dp : false},

		{items : [0,1,0,9,9,9,9,9], loop : true, bOuterByMe : true, dp : false},
		{items : [1,0,9,9,9,9,9,0], loop : true, bOuterByMe : true, dp : false},
		{items : [0,9,9,9,9,9,0,1], loop : true, bOuterByMe : true, dp : false},
		{items : [9,9,9,9,9,0,1,0], loop : true, bOuterByMe : true, dp : false},
		{items : [9,9,0,1,2,0,9,9], loop : true, bOuterByMe : true, dp : false},
		{items : [2,0,9,9,9,9,0,1], loop : true, bOuterByMe : true, dp : false},

	{group : '*** 9. bPreOuterByMe ***'},

		{items : [9,0,9,9,9,9,9,0], loop : false, bPreOuterByMe : false, dp : false},
		{items : [0,9,0,9,9,9,9,9], loop : false, bPreOuterByMe : true, dp : false},
		{items : [9,0,9,0,9,9,9,9], loop : false, bPreOuterByMe : true, dp : false},
		{items : [9,0,1,0,9,9,9,9], loop : false, bPreOuterByMe : false, dp : false},
		{items : [9,0,9,9,0,9,9,9], loop : false, bPreOuterByMe : false, dp : false},

		{items : [9,0,9,9,9,9,9,0], loop : true, bPreOuterByMe : true, dp : false},

	{group : '*** 10. eCriticalToMe ***'},

		{items : [0,1,9,9,9,9,9,9], loop : false, eCriticalToMe : false, dp : false},
		{items : [9,0,1,9,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,1,0,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,1,2,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,9,1,9,9,9,9], loop : false, eCriticalToMe : false, dp : false},

		{items : [9,9,9,9,9,9,1,0], loop : false, eCriticalToMe : false, dp : false},
		{items : [9,9,9,9,9,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,0,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,2,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,1,9,0,9], loop : false, eCriticalToMe : false, dp : false},

	{group : '*** 11. ePreRiskToMe ***'},

		{items : [9,0,9,0,9,9,9,9], loop : false, ePreRiskToMe : true, dp : false},
		{items : [9,0,9,9,0,9,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,0,9,0,9,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,0,0,9,0,0,9,9], loop : false, ePreRiskToMe : true, dp : false},

		{items : [9,9,9,9,0,9,0,9], loop : false, ePreRiskToMe : true, dp : false},
		{items : [9,9,9,0,9,9,0,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,9,0,9,0,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,0,0,9,0,0,9], loop : false, ePreRiskToMe : true, dp : false},

	{group : '*** 12. ePressureToMe ***'},

		{items : [9,0,1,9,1,9,9,9], loop : false, ePressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : false, ePressureToMe : false, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : false, ePressureToMe : true, dp : false},
		{items : [9,0,1,9,1,9,9,9], loop : true, ePressureToMe : false, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : true, ePressureToMe : false, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : true, ePressureToMe : false, dp : false},

		{items : [9,9,1,9,1,0,9,9], loop : false, ePressureToMe : false, dp : false},
		{items : [9,1,9,1,1,0,0,9], loop : false, ePressureToMe : true, dp : false},

	{group : '*** 13. bPressureToMe ***'},

		{items : [9,0,1,9,1,9,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,0,1,9,1,9,9,9], loop : true, bPressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : true, bPressureToMe : true, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : true, bPressureToMe : true, dp : false},

		{items : [9,9,1,9,1,0,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,1,9,1,1,0,0,9], loop : false, bPressureToMe : true, dp : false},

	{group : '*** 14. ePrePressureToMe ***'},

		{items : [9,0,9,9,1,9,9,9], loop : false, ePrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : false, ePrePressureToMe : false, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : false, ePrePressureToMe : true, dp : false},
		{items : [9,0,9,9,1,9,9,9], loop : true, ePrePressureToMe : false, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : true, ePrePressureToMe : false, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : true, ePrePressureToMe : false, dp : false},

		{items : [9,9,1,9,9,0,9,9], loop : false, ePrePressureToMe : false, dp : false},
		{items : [9,1,9,1,9,0,0,9], loop : false, ePrePressureToMe : true, dp : false},

	{group : '*** 15. bPrePressureToMe ***'},

		{items : [9,0,9,9,1,9,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,0,9,9,1,9,9,9], loop : true, bPrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : true, bPrePressureToMe : true, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : true, bPrePressureToMe : true, dp : false},

		{items : [9,9,1,9,9,0,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,1,9,1,9,0,0,9], loop : false, bPrePressureToMe : true, dp : false},

	{group : '*** 16. ePressureByMe ***'},

		{items : [1,1,0,9,0,9,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,1,0,9,0,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,1,0,9,0,9,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,0,0,9,0,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : true, ePressureByMe : false, dp : false},

		{items : [9,9,9,0,9,0,1,1], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,0,9,0,1,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,9,0,9,0,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,0,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : true, ePressureByMe : false, dp : false},

	{group : '*** 17. bPressureByMe ***'},

		{items : [1,1,0,9,0,9,9,9], loop : false, bPressureByMe : false, dp : false},
		{items : [9,9,1,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,0,9,0,9,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,0,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : true, bPressureByMe : true, dp : false},

		{items : [9,9,9,0,9,0,1,1], loop : false, bPressureByMe : false, dp : false},
		{items : [9,9,0,9,0,1,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,9,0,9,0,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,0,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : true, bPressureByMe : true, dp : false},

	{group : '*** 18. bInnerByMe ***'},

		{items : [9,9,9,9,9,9,9,9], loop : false, bInnerByMe : false, dp : false},

		{items : [1,0,1,9,9,9,9,9], loop : false, bInnerByMe : true, dp : false},
		{items : [1,0,0,1,9,9,9,9], loop : false, bInnerByMe : true, dp : false},
		{items : [2,0,0,1,9,9,9,9], loop : false, bInnerByMe : false, dp : false},
		{items : [1,9,0,1,9,9,9,9], loop : false, bInnerByMe : false, dp : false},

		{items : [0,1,9,9,9,9,9,1], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,2,0], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,9], loop : false, bInnerByMe : false, dp : false},

		{items : [0,1,9,9,9,9,9,1], loop : true, bInnerByMe : true, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : true, bInnerByMe : true, dp : false},
		{items : [0,1,9,9,9,9,2,0], loop : true, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,9], loop : true, bInnerByMe : false, dp : false}
];
suites.forEach(in_suite => {
	if (in_suite.group) {
		console.log(in_suite.group);
	} else {
		const parsed = cLineParser.parse(in_suite.items, 0, in_suite.loop, in_suite.dp);
		Object.keys(parsed).forEach(in_prop => {
			if (!in_suite.hasOwnProperty(in_prop)) {
				return;
			}
			if (in_suite[in_prop] !== parsed[in_prop]) {
				const loop = in_suite.loop ? ' (loop)' : '';
				console.log('failed : ' + in_suite.items.join() + loop + ' is ' + parsed[in_prop]);
			}
		});
	}
});

})(false);

class cReversi {
	static #maximize(in_evaluator, in_player, in_candArr) {
		const evaluated = new Map();
		in_candArr.forEach(in_ix => evaluated.set(in_ix, (in_evaluator)(in_player, in_ix)));
		const max = {
			value : -Infinity,
			indexes : []
		};
		for (const [index, value] of evaluated.entries()) {
			if (value > max.value) {
				max.value = value;
				max.indexes = [index];
			} else {
				if (value === max.value) {
					max.indexes.push(index);
				}
			}
		}
		if (max.indexes.length === 0) {
			console.log(evaluated);
			throw new Error();
		}
		return max.indexes;
	}
	static #rotateArray(in_array, in_delta) {
		const len = in_array.length;
		const delta = ((in_delta % len) + len) % len;
		return in_array.slice(delta * -1).concat(in_array.slice(0, delta * -1));
	}
	static #dmz = 8;
	static #empty = 9;
	static #maxPlayers = 4;
	static #validData = (() => {
		const arr = [cReversi.#dmz, cReversi.#empty];
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			arr.push(player);
		}
		return arr;
	})();
	static #directions = [
		[-1, -1],
		[-1,  0],
		[-1, +1],
		[ 0, -1],
		[ 0, +1],
		[+1, -1],
		[+1,  0],
		[+1, +1]
	];
	static #ignore = Symbol();
	#area = {
		items : [],
		options : new Set(),
		scores : {
			default : [],
			players : []
		}
	};
	#npcArgoPriority = [];
	#history = [];
	#conf = null;
	#rotations = null;
	constructor(in_table, in_rowEdge, in_colEdge) {
		const sizeRow = in_table.length;
		const sizeCol = in_table.reduce((in_maxLen, in_row) => {
			return Math.max(in_maxLen, in_row.length);
		}, 0);
		this.#conf = {
			row : {
				size : sizeRow,
				edge : in_rowEdge
			},
			col : {
				size : sizeCol,
				edge : in_colEdge
			},
			corners : {
				angle000 : {
					pos : {
						row : 0,
						col : 0
					},
					dirRow : +1,
					dirCol : +1
				},
				angle090 : {
					pos : {
						row : 0,
						col : sizeCol - 1
					},
					dirRow : +1,
					dirCol : -1
				},
				angle180 : {
					pos : {
						row : sizeRow - 1,
						col : sizeCol - 1
					},
					dirRow : -1,
					dirCol : -1
				},
				angle270 : {
					pos : {
						row : sizeRow - 1,
						col : 0
					},
					dirRow : -1,
					dirCol : +1
				}
			},
			indexes : {
				corner : [],
				xSquare : [],
				sameRow : [],
				sameCol : [],
				radiating : []
			}
		};
		this.setTable(in_table);
		this.#initAreaScores();
		Object.keys(this.#conf.corners).forEach(in_angleKey => {
			const angle = this.#conf.corners[in_angleKey];
			this.#conf.indexes.corner.push(this.#posToIndex(
				angle.pos.row,
				angle.pos.col
			));
			// xSquare is neighbor to the corner on the diagonal
			this.#conf.indexes.xSquare.push(this.#posToIndex(
				angle.pos.row + angle.dirRow,
				angle.pos.col + angle.dirCol
			));
		});
		for (let row = 0; row < sizeRow; row++) {
			this.#conf.indexes.sameRow[row] = [];
			for (let col = 0; col < sizeCol; col++) {
				this.#conf.indexes.sameRow[row].push(this.#posToIndex(row, col));
			}
		}
		for (let col = 0; col < sizeCol; col++) {
			this.#conf.indexes.sameCol[col] = [];
			for (let row = 0; row < sizeRow; row++) {
				this.#conf.indexes.sameCol[col].push(this.#posToIndex(row, col));
			}
		}
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const {row : initRow, col : initCol} = this.#indexToPos(ix);
			const radiating = this.#conf.indexes.radiating[ix] = [];
			for (let dir = 0; dir < cReversi.#directions.length; dir++) {
				const [dr, dc] = cReversi.#directions[dir];
				const towards = [];
				let currRow = initRow;
				let currCol = initCol;
				while (true) {
					currRow += dr;
					if (in_rowEdge) {
						if ((currRow < 0) || (sizeRow - 1 < currRow)) {
							// out of range
							break;
						}
					} else {
						currRow = (currRow + sizeRow) % sizeRow;
						if ((currRow === initRow) && (dr !== 0)) {
							// cyclic
							break;
						}
					}
					currCol += dc;
					if (in_colEdge) {
						if ((currCol < 0) || (sizeCol - 1 < currCol)) {
							// out of range
							break;
						}
					} else {
						currCol = (currCol + sizeCol) % sizeCol;
						if ((currCol === initCol) && (dc !== 0)) {
							// cyclic
							break;
						}
					}
					towards.push(this.#posToIndex(currRow, currCol));
				}
				if (towards.length > 0) {
					radiating.push(towards);
				}
			}
		}
		const argoArr = ['spiteful', 'balance', 'greedy', 'learner', 'classic', 'beginner', 'monkey'];
		for (let i = 0; i < argoArr.length; i++) {
			this.#npcArgoPriority.push((argoArr.slice(0, i + 1))[arrRand]());
		}
		this.#updateOptionsAll();
	}
	#updateOptions(in_ix) {
		const radiating = this.#conf.indexes.radiating[in_ix];
		radiating.forEach(in_towards => {
			const aroundIx = in_towards[0];
			if (this.#getItemByIndex(aroundIx) === cReversi.#empty) {
				this.#area.options.add(aroundIx);
			}
		});
		// in_ix should be new occupied position
		this.#area.options.delete(in_ix);
	}
	#updateOptionsAll() {
		this.#area.options.clear();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) === cReversi.#empty) {
				continue;
			}
			this.#updateOptions(ix);
		}
	}
	#createRollback() {
		const backup = {
			items : [...this.#area.items],
			options : [...this.#area.options]
		};
		return () => {
			this.#area.items = [...backup.items];
			this.#area.options = new Set(backup.options);
		};
	}
	#indexToPos(in_ix) {
		return {
			row : Math.floor(in_ix / this.#conf.col.size),
			col : in_ix % this.#conf.col.size
		};
	}
	#posToIndex(in_row, in_col) {
		return in_row * this.#conf.col.size + in_col;
	}
	#setItemByIndex(in_ix, in_item) {
		this.#area.items[in_ix] = in_item;
	}
	#setItemByPos(in_row, in_col, in_item) {
		this.#setItemByIndex(this.#posToIndex(in_row, in_col), in_item);
	}
	#getItemByIndex(in_ix) {
		return this.#area.items[in_ix];
	}
	#getItemByPos(in_row, in_col) {
		return this.#getItemByIndex(this.#posToIndex(in_row, in_col));
	}
	#items(in_indexes) {
		const items = [];
		in_indexes.forEach(in_ix => {
			items.push(this.#getItemByIndex(in_ix));
		});
		return items;
	}
	#rotateItems(in_indexes, in_delta) {
		const shifted = cReversi.#rotateArray(in_indexes, in_delta);
		const copy = [...this.#area.items];
		for (let i = 0; i < in_indexes.length; i++) {
			/*
				for example ...
				src = 5, 6, 7, 8
				dst = 8, 5, 6, 7
			*/
			this.#setItemByIndex(in_indexes[i], copy[shifted[i]]);
		}
	}
	#rotateSameRowItems(in_targetRow, in_deltaCol) {
		const sameRowIndexes = this.#conf.indexes.sameRow[in_targetRow];
		this.#rotateItems(sameRowIndexes, in_deltaCol);
	}
	#rotateSameColItems(in_targetCol, in_deltaRow) {
		const sameColIndexes = this.#conf.indexes.sameCol[in_targetCol];
		this.#rotateItems(sameColIndexes, in_deltaRow);
	}
	#flip(in_player, in_ix, in_test = false) {
		const radiating = this.#conf.indexes.radiating[in_ix];
		let flipped = false;
		for (let i = 0; i < radiating.length; i++) {
			const towards = radiating[i];
			const ixArr = [];
			let enemyAppears = false;
			for (let j = 0; j < towards.length; j++) {
				const ix = towards[j];
				const item = this.#getItemByIndex(ix);
				if (item === in_player) {
					if (enemyAppears) {
						if (in_test) {
							return true;
						} else {
							flipped = true;
							ixArr.forEach(in_flipped_ix => this.#setItemByIndex(in_flipped_ix, in_player));
						}
					}
					break;
				} else {
					if ((item === cReversi.#dmz) || (item === cReversi.#empty)) {
						break;
					} else {
						ixArr.push(ix);
						enemyAppears = true;
					}
				}
			}
		}
		if (flipped) {
			this.#setItemByIndex(in_ix, in_player);
			this.#updateOptions(in_ix);
			return true;
		} else {
			return false;
		}
	}
	#flippable(in_player, in_ix) {
		const isTest = true;
		return this.#flip(in_player, in_ix, isTest);
	}
	#choose(in_player, in_ix) {
		// in_ix must be choosable
		this.#flip(in_player, in_ix);
		this.#updatePlayersAreaScores(in_player, in_ix);
		const pos = this.#indexToPos(in_ix);
		this.#history.push({
			who : in_player,
			action : 'choose-item',
			row : pos.row,
			col : pos.col,
			target : -1,
			delta : -1
		});
		// this._debug();
	}
	#npcTryRotate(in_player, in_dir) {
		const rowSet = new Set();
		const colSet = new Set();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) !== in_player) {
				continue;
			}
			const col = ix % this.#conf.col.size;
			const row = (ix - col) / this.#conf.col.size;
			rowSet.add(row);
			colSet.add(col);
		}
		const setting = {
			row : {
				action : 'npc-col-wise-rotate',
				targetArr : Array.from(rowSet),
				rotateFunc : this.#rotateSameRowItems.bind(this),
				maxCnt : this.#conf.col.size
			},
			col : {
				action : 'npc-row-wise-rotate',
				targetArr : Array.from(colSet),
				rotateFunc : this.#rotateSameColItems.bind(this),
				maxCnt : this.#conf.row.size
			}
		}
		// this algorithm can be improved
		const {action, targetArr, rotateFunc, maxCnt} = setting[in_dir];
		let target, delta;
		const rollback = this.#createRollback();
		let rotated = targetArr.some(in_target => {
			target = in_target;
			let rest = maxCnt;
			while (--rest > 0) {
				// rotate +1 (maxCnt - 1) times
				(rotateFunc)(in_target, 1);
				const cand = this.#searchCandidates(in_player);
				if (cand.length > 0) {
					delta = maxCnt - rest;
					return true;
				}
			}
			(rollback)();
			return false;
		});
		if (rotated) {
			this.#updateOptionsAll();
			this.#history.push({
				who : in_player,
				action : action,
				row : -1,
				col : -1,
				target : target,
				delta : delta
			});
		}
		return rotated;
	}
	#count(in_player) {
		const items = this.#area.items.filter(in_el => in_el === in_player);
		return items.length;
	}
	#emptyCnt() {
		return this.#count(cReversi.#empty);
	}
	#searchCandidates(in_player) {
		const candidates = [];
		this.#area.options.forEach(in_empty_ix => {
			if (this.#flippable(in_player, in_empty_ix)) {
				candidates.push(in_empty_ix);
			}
		});
		return candidates;
	}
	#getAreaScore(in_player, in_ix) {
		return this.#area.scores.players[in_player][in_ix];
	}
	#updateScoresByAngle(io_areaScores, in_format, in_angleKey) {
		const angle = this.#conf.corners[in_angleKey];
		for (let i = 0; i < in_format.length; i++) {
			for (let j = 0; j < in_format[i].length; j++) {
				if (in_format[i][j] === cReversi.#ignore) {
					continue;
				}
				const row = angle.pos.row + i * angle.dirRow;
				const col = angle.pos.col + j * angle.dirCol;
				io_areaScores[this.#posToIndex(row, col)] = in_format[i][j];
			}
		}
	}
	#initAreaScores() {
		// default
		this.#area.scores.default = new Array(this.#conf.row.size * this.#conf.col.size).fill(-1);
		this.#initDefaultAreaScores();
		// players
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			this.#area.scores.players[player] = [...this.#area.scores.default];
		}
	}
	#initDefaultAreaScores() {
		if (this.#conf.row.edge) {
			if (this.#conf.col.edge) {
				this.#initDefaultAreaScoresEx2();
			} else {
				this.#initDefaultAreaScoresEx1();
			}
		} else {
			if (this.#conf.col.edge) {
				this.#initDefaultAreaScoresEx1();
			} else {
				this.#initDefaultAreaScoresEx0();
			}
		}
	}
	#updatePlayersAreaScores(in_player, in_ix) {
		if (this.#conf.row.edge) {
			if (this.#conf.col.edge) {
				this.#updatePlayersAreaScoresEx2(in_player, in_ix);
			} else {
				this.#updatePlayersAreaScoresEx1(in_player, in_ix);
			}
		} else {
			if (this.#conf.col.edge) {
				this.#updatePlayersAreaScoresEx1(in_player, in_ix);
			} else {
				this.#updatePlayersAreaScoresEx0(in_player, in_ix);
			}
		}
	}
	#initDefaultAreaScoresEx2() {
		const newScore = [
			[+35,  -4, +2, +1],
			[ -4, -10, -2,  0],
			[ +2,  -2,  1, -1],
			[ +1,   0, -1, -1],
		];
		const size = Math.min(newScore.length, Math.floor(Math.min(this.#conf.row.size, this.#conf.col.size) / 2));
		const format = newScore.slice(0, size).map(in_row => in_row.slice(0, size));
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle000');
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle090');
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle180');
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle270');
	}
	#updatePlayersAreaScoresEx2(in_player, in_ix) {
		const newScore = +4;
		const pos = this.#indexToPos(in_ix);
		const angleKey = Object.keys(this.#conf.corners).find(in_angleKey => {
			const corner = this.#conf.corners[in_angleKey].pos;
			return ((corner.row === pos.row) && (corner.col === pos.col));
		});
		if (!angleKey) {
			// in_ix is not on the corner
			return;
		}
		const format = [];
		const size = Math.min(this.#conf.row.size, this.#conf.col.size);
		for (let row = 0; row < size; row++) {
			format[row] = new Array(size).fill(cReversi.#ignore);
			for (let col = 0; col < size; col++) {
				if ((row !== 0) && (col !== 0)) {
					continue;
				}
				const score = this.#area.scores.players[in_player][this.#posToIndex(row, col)];
				if (newScore > score) {
					format[row][col] = newScore;
				}
			}
		}
		format[1][1] = newScore;
		this.#updateScoresByAngle(this.#area.scores.players[in_player], format, angleKey);
	}
	#initDefaultAreaScoresEx1() {
		const newScore = [+4, -3, +2];
		let format = [];
		if (this.#conf.row.edge) {
			for (let row = 0; row < newScore.length; row++) {
				format[row] = new Array(this.#conf.col.size).fill(newScore[row]);
			}
		}
		if (this.#conf.col.edge) {
			for (let row = 0; row < this.#conf.row.size; row++) {
				format[row] = [...newScore];
			}
		}
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle000');
		this.#updateScoresByAngle(this.#area.scores.default, format, 'angle180');
	}
	#updatePlayersAreaScoresEx1(in_player, in_ix) {
		const newScore = +3;
		const pos = this.#indexToPos(in_ix);
		let edge, repl;
		const indexes = this.#conf.indexes;
		if (this.#conf.row.edge) {
			if (pos.row === 0) {
				edge = indexes.sameRow[pos.row];
				repl = indexes.sameRow[pos.row + 1];
			} else if (pos.row === this.#conf.row.size - 1) {
				edge = indexes.sameRow[pos.row];
				repl = indexes.sameRow[pos.row - 1];
			} else {
				// in_ix is not on the row-edge
				return;
			}
		}
		if (this.#conf.col.edge) {
			if (pos.col === 0) {
				edge = indexes.sameRow[pos.col];
				repl = indexes.sameRow[pos.col + 1];
			} else if (pos.col === this.#conf.col.size - 1) {
				edge = indexes.sameRow[pos.col];
				repl = indexes.sameRow[pos.col - 1];
			} else {
				// in_ix is not on the col-edge
				return;
			}
		}
		for (let i = 0; i < edge.length; i++) {
			const index = repl[i];
			const owner = this.#getItemByIndex(edge[i]);
			// 1. rollback to default
			for (let player = 0; player < cReversi.#maxPlayers; player++) {
				this.#area.scores.players[player][index] = this.#area.scores.default[index];
			}
			// 2. update for owner
			if (owner < cReversi.#maxPlayers) {
				this.#area.scores.players[owner][index] = newScore;
			}
		}
	}
	#initDefaultAreaScoresEx0() {
		return;
	}
	#updatePlayersAreaScoresEx0(in_player, in_ix) {
		return;
	}
	static #evaluateStats = {};
	#evaluate(in_player, in_ix) {
		const registerStats = in_key => {
			if (cReversi.#evaluateStats[in_key]) {
				cReversi.#evaluateStats[in_key]++;
			} else {
				cReversi.#evaluateStats[in_key] = 1;
			}
		};
		registerStats('total');
		const pos = this.#indexToPos(in_ix);
		const corner_x4 = this.#conf.row.edge && this.#conf.col.edge;
		const ixIsEdge = in_dir => ((this.#conf[in_dir].edge) && ((pos[in_dir] === this.#conf[in_dir].size - 1) || (pos[in_dir] === 0)));
		const ixIsRowEdge = ixIsEdge('row');
		const ixIsColEdge = ixIsEdge('col');
		/*
			1. e (= edge) : check if area of edge is safe
			2. x (= xSquare) : check if xSquare positions will be not changed
		*/
		const check = {
			e : {
				indexes : null,
				currItems : [],
				nextItems : [],
				currParsed : {},
				nextParsed : {}
			},
			x : {
				indexes : null,
				currItems : [],
				nextItems : [],
				increased : false
			}
		};
		const indexes = this.#conf.indexes;
		if (ixIsRowEdge) {
			if (ixIsColEdge) {
				registerStats('corner');
				return +999;
			} else {
				check.e.indexes = indexes.sameRow[pos.row];
			}
		} else {
			if (ixIsColEdge) {
				check.e.indexes = indexes.sameCol[pos.col];
			} else {
				if (!corner_x4) {
					registerStats('inside & without xSquare');
					return 0;
				}
			}
		}
		if (corner_x4) {
			check.x.indexes = [];
			for (let i = 0; i < indexes.corner.length; i++) {
				if (indexes.corner[i] === in_player) {
					// does not need to check x
					continue;
				} else {
					check.x.indexes.push(indexes.xSquare[i]);
				}
			}
		}
		if (check.e.indexes) {
			check.e.currItems = this.#items(check.e.indexes);
		}
		if (check.x.indexes) {
			check.x.currItems = this.#items(check.x.indexes);
		}
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		if (check.e.indexes) {
			check.e.nextItems = this.#items(check.e.indexes);
			check.e.currParsed = cLineParser.parse(check.e.currItems, in_player, !corner_x4);
			check.e.nextParsed = cLineParser.parse(check.e.nextItems, in_player, !corner_x4);
		}
		if (check.x.indexes) {
			check.x.nextItems = this.#items(check.x.indexes);
			check.x.increased = !check.x.nextItems.every((in_item, in_ix) => in_item === check.x.currItems[in_ix]);
		}
		(rollback)();
		const priorityArr = [
			{format : 'eCriticalToMe', positive : false},
			{format : 'ePreRiskToMe', positive : false},
			{format : 'xSquare', positive : false},
			{format : 'ePressureByMe', positive : true},
			{format : 'ePressureToMe', positive : false},
			{format : 'ePrePressureToMe', positive : false},
			{format : 'bFulfilledWith', positive : true},
			{format : 'bPressureByMe', positive : true},
			{format : 'bPressureToMe', positive : false},
			{format : 'bPrePressureToMe', positive : false},
			{format : 'bInnerByMe', positive : true},
			{format : 'bPreOuterByMe', positive : false},
			{format : 'safetyScore', positive : true},
			{format : 'bOuterByMe', positive : true}
		];
		const scale = 10;
		for (let i = 0; i < priorityArr.length; i++) {
			const {format, positive} = priorityArr[i];
			let score = ((priorityArr.length - i - 1) * scale + 1) * (positive ? +1 : -1);
			if (format === 'xSquare') {
				// 1. special case (xSquare)
				if (check.x.increased) {
					registerStats(format);
					return score;
				} else {
					continue;
				}
			}
			if (check.e.currParsed[format] === check.e.nextParsed[format]) {
				// 2. special case (bOuterByMe)
				if ((format === 'bOuterByMe') && (check.e.nextParsed[format])) {
					registerStats(format);
					return score;
				} else {
					continue;
				}
			} else {
				// 3. generic cases
				if (typeof check.e.nextParsed[format] === 'number') {
					const delta = check.e.nextParsed[format] - check.e.currParsed[format];
					registerStats(format);
					return (delta > 0) ? score * +1 : score * -1;
				} else {
					let statsKey;
					if (check.e.nextParsed[format]) {
						statsKey = format + '-false-to-true';
						score *= +1;
					} else {
						statsKey = format + '-true-to-false';
						score *= -1;
					}
					registerStats(statsKey);
					return score;
				}
			}
		}
		registerStats('can not evaluate');
		return 0;
	}
	#countNextEnemyOption(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const player = (in_player + 1 + cReversi.#maxPlayers) % cReversi.#maxPlayers;
		const count = this.#searchCandidates(player).length;
		(rollback)();
		return count;
	}
	#countNextOption(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const count = this.#searchCandidates(in_player).length;
		(rollback)();
		return count;
	}
	#countNextOwnedArea(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const count = this.#count(in_player);
		(rollback)();
		return count;
	}
	#calculateNextScore(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		let score = 0;
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) === in_player) {
				score += this.#getAreaScore(in_player, ix);
			}
		}
		(rollback)();
		return score;
	}
	static #randomizeCnt = 5;
	#npc_min_enemy_option(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextEnemyOption(in_player, in_ix) * -1;
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_option(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOption(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_owned_area(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOwnedArea(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_score_smart(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#getAreaScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_score_total(in_player, in_candArr) {
		const evaluator = (in_player, in_ix) => {
			return this.#calculateNextScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_score_spot(in_player, in_candArr) {
		const evaluator = (in_player, in_ix) => {
			return this.#getAreaScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_random(in_player, in_candArr) {
		return in_candArr[arrRand]();
	}
	#npcSet = {
		spiteful : this.#npc_min_enemy_option,
		balance : this.#npc_max_option,
		greedy : this.#npc_max_owned_area,
		learner : this.#npc_score_smart,
		classic : this.#npc_score_total,
		beginner : this.#npc_score_spot,
		monkey : this.#npc_random
	}
	_simulation(in_repeat = 100) {
		const truncateDecimal = (in_value, in_digit) => {
			const order = 10 ** in_digit;
			return Math.floor(in_value * order) / order;
		};
		const test = (in_argoArr) => {
			let cnt = 100;
			while (true) {
				const resultArr = [];
				for (let i = 0; i < in_argoArr.length; i++) {
					resultArr[i] = this.npc(i, in_argoArr[i]);
				}
				if (resultArr.some(in_result => in_result)) {
					if (cnt-- === 0) {
						break;
					}
				} else {
					break;
				}
				// this.dp();
			}
			let max = -Infinity;
			let winner = -1;
			const cond = this.getCurrentCondition();
			for (let i = 0; i < cond.players.length; i++) {
				if (cond.players[i].score > max) {
					max = cond.players[i].score;
					winner = i;
				}
			}
			return winner;
		};
		const rollback = this.#createRollback();
		// start simulation
		const table = [];
		table.push(['(vs)', ...Object.keys(this.#npcSet)]);
		Object.keys(this.#npcSet).forEach(p1 => {
			const row = [p1];
			Object.keys(this.#npcSet).forEach(p2 => {
				const players = [p1, p2];
				if (p1 === p2) {
					row.push('-');
					return;
				}
				let cnt = in_repeat;
				let win = 0;
				while (true) {
					if (cnt-- > 0) {
						if (test(players) === 0) {
							win++;
						}
						this.#initAreaScores();
						this.#history.length = 0;
						(rollback)();
					} else {
						break;
					}
				}
				row.push(truncateDecimal(win / in_repeat, 2));
				this.#initAreaScores();
				this.#history.length = 0;
				(rollback)();
			});
			table.push(row);
		});
		const elem = (in_table => {
			const ret = document.createElement('TABLE');
			in_table.forEach(in_row => {
				const row = document.createElement('TR');
				in_row.forEach(in_cell => {
					const cell = document.createElement('TD');
					cell.innerText = in_cell;
					let color = 'eeeeee';
					if (typeof in_cell === 'boolean') {
						if (in_cell) {
							color = 'ccccff';
						} else {
							color = 'ffcccc';
						}
					} else {
						if (typeof in_cell === 'number') {
							if (in_cell > 0.5) {
								color = 'ccccff';
							} else {
								color = 'ffcccc';
							}
						}
					}
					cell.style.backgroundColor = color;
					cell.style.textAlign = 'center';
					cell.style.border = '1px solid black';
					cell.style.padding = '3px';
					cell.style.width = '5em';
					row.appendChild(cell);
				});
				ret.appendChild(row);
			});
			ret.style.borderCollapse = 'collapse';
			return ret;
		})(table);
		const script = document.currentScript;
		script.parentNode.insertBefore(elem, script.nextSibling);
		let total = 1;
		Object.keys(cReversi.#evaluateStats).forEach(in_key => {
			if (in_key === 'total') {
				total = cReversi.#evaluateStats[in_key];
				return;
			}
			const taking = truncateDecimal(cReversi.#evaluateStats[in_key] / total, 4);
			console.log(in_key + ' : ' + taking);
		});
	}
	_debug() {
		const sources = {area : this.#area.items};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			sources['p-' + player] = this.#area.scores.players[player];
		}
		Object.keys(sources).forEach(in_key => {
			console.log('*** ' + in_key + ' ***');
			const data = sources[in_key];
			for (let row = 0; row < this.#conf.row.size; row++) {
				const items = [];
				for (let col = 0; col < this.#conf.col.size; col++) {
					const ix = this.#posToIndex(row, col);
					items.push(data[ix]);
				}
				console.log(items);
			}
		});
	}
	pc(in_player, in_row, in_col) {
		const index = this.#posToIndex(in_row, in_col);
		if (this.#getItemByIndex(index) !== cReversi.#empty) {
			return false;
		}
		if (this.#flippable(in_player, index)) {
			this.#choose(in_player, index);
			return true;
		} else {
			return false;
		}
	}
	npc(in_player, in_argo = null) {
		let npcAlive = false;
		let playerCnt = 0;
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			if (this.#area.items.indexOf(player) >= 0) {
				playerCnt++;
				if (player === in_player) {
					npcAlive = true;
				}
			}
		}
		if (npcAlive) {
			if (playerCnt === 1) {
				// only in_player
				return false;
			}
		} else {
			// in_player is died
			return false;
		}
		if (this.#area.items.indexOf(cReversi.#empty) === -1) {
			// fulfilled
			return false;
		}
		let npcArgo;
		if (in_argo) {
			npcArgo = in_argo;
		} else {
			npcArgo = this.#npcArgoPriority[in_player];
		}
		// console.log(in_player, npcAlive, playerCnt, npcArgo);
		const candidates = this.#searchCandidates(in_player);
		if (candidates.length > 0) {
			const index = (this.#npcSet[npcArgo].bind(this))(in_player, candidates);
			this.#choose(in_player, index);
			return true;
		} else {
			if (this.#conf.row.edge) {
				if (this.#conf.col.edge) {
					// can not do anything
					return false;
				} else {
					// try col-wise rotation
					return this.#npcTryRotate(in_player, 'row');
				}
			} else {
				// try row-wise rotation
				return this.#npcTryRotate(in_player, 'col');
			}
		}
	}
	canRowWiseLoop() {
		return !this.#conf.row.edge;
	}
	canColWiseLoop() {
		return !this.#conf.col.edge;
	}
	getLast(in_conditions = {}) {
		// in_conditions : {who, action, row, col, target, delta}
		for (let i = this.#history.length - 1; i >= 0; i--) {
			const last = this.#history[i];
			if (Object.keys(in_conditions).some(in_key => in_conditions[in_key] !== last[in_key])) {
				continue;
			} else {
				return last;
			}
		}
		return null;
	}
	getTable() {
		const table = [];
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const pos = this.#indexToPos(ix);
			if (!table[pos.row]) {
				table[pos.row] = [];
			}
			table[pos.row][pos.col] = parseInt(this.#getItemByIndex(ix));
		}
		return table;
	}
	setTable(in_table) {
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const item = in_table[row][col];
				if (cReversi.#validData.indexOf(item) < 0) {
					throw new Error('invalid input');
				} else {
					this.#setItemByPos(row, col, item);
				}
			}
		}
	}
	setActionResult(in_player, in_action, in_table) {
		this.setTable(in_table);
		this.#history.push({
			who : in_player,
			action : in_action,
			row : -1,
			col : -1,
			target : -1,
			delta : -1
		});
	}
	getCurrentCondition() {
		const condition = {
			finished : false,
			players : []
		};
		const canRotate = !(this.#conf.row.edge && this.#conf.col.edge);
		const cnt = {
			activePlayer : 0,
			frozenPlayer : 0
		};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			let score, dead, frozen;
			score = this.#count(player);
			dead = (score === 0);
			if (dead) {
				frozen = true;
			} else {
				const candidates = (this.#searchCandidates(player)).length;
				if ((candidates > 0) || canRotate) {
					cnt.activePlayer++;
					frozen = false;
				} else {
					cnt.frozenPlayer++;
					frozen = true;
				}
			}
			condition.players[player] = {score : score, dead : dead, frozen : frozen};
		}
		condition.finished =
			// only 1 player is active
			(cnt.activePlayer + cnt.frozenPlayer === 1) ||
			// all players are frozen
			(cnt.activePlayer === 0) ||
			// there is no emply
			(this.#emptyCnt() === 0);
		return condition;
	}
}

/*
	the cTurnController class is designed to manage turns in turn-based games like reversi.
*/

class cTurnController {
	#players = new cCyclicValues();
	#active = false;
	#turns = 0;
	registerPlayer(in_turnHook, in_playerId = randomString()) {
		this.#players.push({
			turnHook : in_turnHook,
			playerId : in_playerId
		});
		return in_playerId;
	}
	#turnStart(in_player) {
		this.#turns++;
		in_player.turnHook(in_player.playerId);
	}
	turnEnd() {
		if (!this.#active) {
			return;
		}
		this.#turnStart(this.#players.incrementedValue());
	}
	gameStart() {
		this.#active = true;
		this.#turnStart(this.#players.currValue());
	}
	gameEnd() {
		this.#active = false;
	}
}

/*
	the cColony class related functions provide the ability to create cylinder-shaped threejs objects.
*/

const textureFactory = factoryBuilder((in_w, in_h, in_dmz = false) => {
	const gradationCnt = 4
	// gradationCnt (from black to white)
	const maxDepth = 255;
	const rgbArr = [];
	for (let i = 0; i < gradationCnt; i++) {
		const depth = Math.ceil(maxDepth / gradationCnt * (i + 1));
		rgbArr[i] = 'rgb(' + depth + ',' + depth + ',' + depth + ')';
	}
	// draw and convert using toDataUR
	const canvas = document.createElement('CANVAS');
	canvas.width = in_w;
	canvas.height = in_h;
	const ctx = canvas.getContext('2d');
	for (let i = 0; i < gradationCnt; i++) {
		if (in_dmz) {
			ctx.strokeStyle = rgbArr[gradationCnt - i - 1];
			ctx.fillStyle = rgbArr[gradationCnt - i - 1];
			if (i > 0) {
				ctx.lineWidth = (gradationCnt - i) * 2 - 1;
				ctx.beginPath();
				ctx.moveTo(0, 0);
				ctx.lineTo(in_w, in_h);
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo(in_w, 0);
				ctx.lineTo(0, in_h);
				ctx.stroke();
			} else {
				ctx.fillRect(0, 0, in_w, in_h);
			}
		} else {
			/*
				Rect           RoundRect      RoundRect

				##########     ##########     ##########
				##########     ##******##     ##******##
				##########     #********#     #**++++**#
				##########     #********#     #*++++++*#
				########## --> #********# --> #*++++++*# --> ...
				##########     #********#     #*++++++*#
				##########     #********#     #**++++**#
				##########     ##******##     ##******##
				##########     ##########     ##########
			*/
			const radius = gradationCnt + 2;
			ctx.fillStyle = rgbArr[i];
			if (i > 0) {
				ctx[fillRoundRect](i, i, in_w - i * 2, in_h - i * 2, radius - i);
			} else {
				ctx.fillRect(i, i, in_w - i * 2, in_h - i * 2);
			}
		}
	}
	return (new THREE.TextureLoader()).load(canvas.toDataURL());
});

const surfaceFactory = factoryBuilder((in_color, in_size, in_type) => {
	const material = new THREE.MeshLambertMaterial();
	material.color = new THREE.Color(in_color);
	switch (in_type) {
	case 'normal-texture' :
		material.map = textureFactory.create(in_size, in_size, false);
		break;
	case 'dmz-texture' :
		material.map = textureFactory.create(in_size, in_size, true);
		break;
	case 'no-texture' :
	default :
		break;
	}
	return material;
});

const SHELL_COLOR_INDEX = 2;

function shellMaterials(in_size, in_color_main, in_color_back, in_dmz) {
	const materials = [];
	for (let i = 0; i < Object.keys(DIRECTION).length; i++) {
		if (i === SHELL_COLOR_INDEX) {
			const texture = in_dmz ? 'dmz-texture' : 'normal-texture';
			materials.push(surfaceFactory.create(in_color_main, in_size, texture));
		} else {
			materials.push(surfaceFactory.create(in_color_back, in_size, 'no-texture'));
		}
	}
	return materials;
}

function getShellColor(in_object) {
	return in_object.material[SHELL_COLOR_INDEX].color.getHex();
}

function setShellColor(in_object, in_color) {
	const setting = in_object.geometry.parameters;
	return in_object.material[SHELL_COLOR_INDEX] = surfaceFactory.create(in_color, setting.size);
}

const shellGeometryFactory = factoryBuilder((in_size, in_innerRatio, in_thickness) => {
	const radian = 6;
	const outerLen = in_size - radian * 2;
	const innerLen = outerLen * in_innerRatio;
	const thickness = in_thickness - radian * 2;
	const geometry = trapezoidGeometryUtil(outerLen, outerLen, outerLen, innerLen, thickness, radian);
	geometry.parameters = {
		size : in_size,
		innerRatio : in_innerRatio,
		thickness : in_thickness
	};
	return geometry;
});

const GRAY1 = 0x222222;
const GRAY2 = 0x444444;
const GRAY3 = 0x666666;

const BGCOLOR = GRAY1;
const DMZCOLOR = GRAY2;
const EMPTYCOLOR = GRAY3;

const ORANGE = 0xFFAA00;
const RED = 0xFF0000;
const WHITE = 0xFFFFFF;
const YELLOW = 0xFFFF00;
const BLUE = 0x3333FF;
const GREEN = 0x118811;
const LIGHTBLUE = 0x5588FF;
const LIGHTGREEN = 0x55CC55;

const edgeMaterial = new THREE.MeshLambertMaterial({color : BGCOLOR});

const COLONY_SIZE = 400;

const gMeshLevelMap = ((in_diameter) => {
	const map = new cCyclicMap();
	const B = BLUE;
	const R = RED;
	const Y = YELLOW;
	const G = GREEN;
	const D = DMZCOLOR;
	const E = EMPTYCOLOR;
	let shellInfo;
	switch (getParam('type')) {
	case '4-loop' :
		shellInfo = [
			{
				name : '12x6x4-loop',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,G,Y,E,E],
					[E,E,Y,G,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '18x6x4-loop',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,Y,E,E],
					[E,G,R,B,E,E],
					[E,E,Y,G,R,E],

					[E,E,B,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,G,E,E],

					[E,B,Y,R,E,E],
					[E,E,G,B,Y,E],
					[E,E,R,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '16x8x4-loop',
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,G,Y,E,E,E],
					[E,E,E,Y,G,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				name : '20x10x4-loop',
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,E,Y,G,E,E,E,E],
					[E,E,E,Y,E,E,G,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,E,Y,G,E,E,E,E],
					[E,E,E,Y,E,E,G,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E]
				]
			}
		];
		break;
	case '2-loop' :
		shellInfo = [
			{
				name : '12x6x2-loop',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,R,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '18x6x2-loop',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,D,E,E],
					[E,E,R,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,B,E,E],
					[E,E,D,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '16x8x2-loop',
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				name : '20x10x2-loop',
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,E,B,R,E,E,E,E],
					[E,E,E,B,E,E,R,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,B,E,E,R,E,E,E],
					[E,E,E,E,B,R,E,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E]
				]
			}
		];
		break;
	case '4-non-loop' :
		shellInfo = [
			{
				name : '6x6x4',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,Y,E,E],
					[E,G,R,B,E,E],
					[E,E,Y,G,R,E],
					[E,E,B,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '12x6x4',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,Y,G,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,Y,G,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '8x8x4',
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,B,E,Y,G,E,E],
					[E,E,G,R,B,E,E,E],
					[E,E,E,Y,G,R,E,E],
					[E,E,R,B,E,Y,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				name : '10x10x4',
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,Y,E,E,E,E],
					[E,E,E,G,R,B,E,E,E,E],
					[E,E,E,E,Y,G,R,E,E,E],
					[E,E,E,E,B,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D]
				]
			}
		];
		break;
	case '2-non-loop' :
	default :
		shellInfo = [
			{
				name : '6x6x2',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '12x6x2',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,R,B,E,E],

					[E,E,B,R,E,E],
					[E,E,R,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '8x8x2',
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				name : '10x10x2',
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,R,E,D,B,E,E,E],
					[E,E,E,D,R,B,E,E,E,E],
					[E,E,E,E,B,R,D,E,E,E],
					[E,E,E,B,D,E,R,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D]
				]
			}
		];
		break;
	}
	shellInfo.forEach(in_shell => {
		const radius = in_diameter / 2;
		const circumf = in_diameter * Math.PI;
		const unitSize = circumf / in_shell.table.length;
		const unitThick = unitSize * 0.3;
		const unitAngle = Math.PI * 2 / in_shell.table.length;
		const geometry = shellGeometryFactory.create(unitSize, ((radius - unitThick) / radius), unitThick);
		const pieces = [];
		const cols = in_shell.table.reduce((in_maxLen, in_row) => {
			return Math.max(in_maxLen, in_row.length);
		}, 0);
		for (let col = 0; col < cols; col++) {
			let x = unitSize * col - unitSize * (cols - 1) / 2;
			let y = (in_diameter / 2 - unitThick) * 1.2;
			for (let row = 0; row < in_shell.table.length; row++) {
				const color = in_shell.table[row][col];
				const materials = shellMaterials(unitSize, color, BGCOLOR, (color === D));
				materials.push(edgeMaterial);
				const piece = new THREE.Mesh(geometry, materials);
				const pivot = new THREE.Object3D();
				pivot.add(piece);
				piece.position.copy(VEC3(x, y, 0));
				pivot.rotateX(unitAngle * row);
				/*
					*** NOTE ***
					you can use matrix,
					to apply rotated position before adding to scene
				*/
				pivot.updateMatrixWorld();
				piece.applyMatrix4(pivot.matrix);
				pivot.remove(piece);
				pieces.push(piece);
			}
		}
		map.set(in_shell.name, pieces);
	});
	return map;
})(COLONY_SIZE);

/*
	the cBoard is designed to represent a reversi board.
*/

class cColonyBoard extends cColony {
	#makeRotationX(in_rad) {
		return this.settingVal.origin.clone().applyMatrix4((new THREE.Matrix4()).makeRotationX(in_rad));
	}
	indexToPiece(in_row, in_col) {
		const vec3 = this.#makeRotationX(this.settingVal.unitAngle * in_row);
		vec3.x += this.settingVal.unitDelta * in_col;
		const piece = this.children.find(in_child => XYZ.every(in_xyz => Math.abs(in_child.position[in_xyz] - vec3[in_xyz]) < cColony.error));
		if (!piece) {
			console.log('indexToPiece failed : ', in_row, in_col);
			throw new Error('');
		}
		return piece;
	}
	pieceToIndex(in_piece) {
		const pos = in_piece.position;
		const ret = {
			row : -1,
			col : -1
		};
		for (ret.row = 0; ret.row < this.settingVal.rowsForCircle; ret.row++) {
			const vec3 = this.#makeRotationX(this.settingVal.unitAngle * ret.row);
			if (Math.abs(vec3.y - pos.y) > cColony.error) {
				continue;
			}
			if (Math.abs(vec3.z - pos.z) > cColony.error) {
				continue;
			}
			ret.col = Math.round((pos.x - vec3.x) / this.settingVal.unitDelta);
			break;
		}
		const max = {
			row : this.settingVal.rowsForCircle - 1,
			col : this.settingVal.colsForLength - 1
		};
		if ((ret.row < 0) || (max.row < ret.row) || (ret.col < 0) || (max.col < ret.col)) {
			console.log('pieceToIndex failed : ', in_piece, ret);
			throw new Error('');
		}
		return ret;
	}
	getColorTable() {
		const table = [];
		for (let row = 0; row <  this.settingVal.rowsForCircle; row++) {
			table[row] = [];
			for (let col = 0; col < this.settingVal.colsForLength; col++) {
				const piece = this.indexToPiece(row, col);
				table[row].push(getShellColor(piece));
			}
		}
		return table;
	}
	changedPieces(in_table) {
		const changedArr = [];
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const piece = this.indexToPiece(row, col);
				const currColor = getShellColor(piece);
				const nextColor = in_table[row][col];
				if (currColor !== nextColor) {
					changedArr.push({
						piece : piece,
						curr : currColor,
						next : nextColor
					});
				}
			}
		}
		return changedArr;
	}
	makeRotateProgress(in_col, in_delta, in_ending_callback) {
		this.uiDisable();
		const last = this.settingVal.unitAngle * in_delta;
		const x = this.settingVal.origin.x + this.settingVal.unitDelta * in_col;
		const pieces = this.children.filter(in_child => Math.abs(in_child.position.x - x) < cColony.error);
		const group = this.setupGroup(pieces);
		return this.makeAnimationProgress(group, cColony.axes.x, 0, last, in_ratio => {
			if (in_ratio < 1) {
				return;
			}
			this.uiEnable();
			(in_ending_callback)();
		});
	}
}

/*
	gWorld (cSphericalWorld)
		|
		+-- gColony (cColonyBoard)
			|
			+-- gColony.children <--- gMeshLevelMap

	gController (cGameController) : knows the internal structure of the following instances
		|
		+-- gReversi (cReversi) : used for npc algorithm
		|
		+-- gColony : used for user interface
		|
		+-- gWorld : used for animation
*/

const gColony = new cColonyBoard();

const WORLD_RADIUS = COLONY_SIZE * 10;
const WORLD_INIT_ZOOM = WORLD_RADIUS / 2;

const gWorld = new cSphericalWorld(WORLD_RADIUS);
gWorld.add(gColony);
gWorld.moveView(0.5, 0.5);
gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);

let gController = null;
let gReversi = null;

class cGameController {
	static #UNUSED = -1;
	static PC = BLUE;
	static #NPC = [
		RED,
		YELLOW,
		GREEN,
		ORANGE,
		LIGHTBLUE,
		LIGHTGREEN
	];
	#mapping = new Array(10).fill(cGameController.#UNUSED);
	#turnHook = () => {};
	#curIndex = 0;
	#tableSize;
	enableHandler = false;
	// cGameController knows the internal structure of cColonyBoard, cReversi and cSphericalWorld
	constructor(in_playerCnt, in_pc = 0) {
		const colors = Array.from(cGameController.#NPC);
		for (let i = 0; i < in_playerCnt; i++) {
			let color;
			if (i === in_pc) {
				color = cGameController.PC;
			} else {
				color = colors.shift();
			}
			this.#mapping[i] = color;
		}
		// 8, 9 are declared as follows in cReversi
		this.#mapping[8] = DMZCOLOR;
		this.#mapping[9] = EMPTYCOLOR;
		this.setTableSize(-1, -1);
	}
	setTableSize(in_rows, in_cols) {
		// as cColonyBoard and cReversi may not have the same rows and cols, in_rows and in_cols are needed.
		this.#tableSize = {
			rows : in_rows,
			cols : in_cols
		};
	}
	setTurnHook(in_hook) {
		this.#turnHook = in_hook;
	}
	#execTurnHook() {
		const color = this.#mapping[this.#curIndex];
		this.enableHandler = (color === cGameController.PC);
		(this.#turnHook)(this.#curIndex, color, this.enableHandler);
	}
	#incrementIndex() {
		this.#curIndex++;
		if (this.#mapping[this.#curIndex] === cGameController.#UNUSED) {
			this.#curIndex = 0;
		}
	}
	endTurn(in_reversi = null) {
		this.#incrementIndex();
		const cond = in_reversi.getCurrentCondition();
		if (cond.finished) {
			// all players can not do anything
			const winner = cond.players.reduce((in_accum, in_curVal, in_curIndex, in_arr) => {
				return in_curVal.score > in_arr[in_accum].score ? in_curIndex : in_accum;
			}, 0);
			return this.#mapping[winner];
		} else {
			while (true) {
				const {dead, frozen, score} = cond.players[this.#curIndex];
				if (dead || (frozen && !in_reversi.canRowWiseLoop())) {
					// curIndex can not do anything
					this.#incrementIndex();
				} else {
					break;
				}
			}
			// to prevent stack overflow
			setTimeout(() => this.#execTurnHook(), 0);
			// in this context, no winner
			return -1;
		}
	}
	start() {
		this.#execTurnHook();
	}
	end() {
		this.setTurnHook(() => {});
		this.#mapping.fill(cGameController.#UNUSED);
	}
	static #update(in_changedArr) {
		in_changedArr.forEach(in_changed => {
			setShellColor(in_changed.piece, in_changed.next);
		});
	}
	static #updateDynamic(in_changedArr, in_world) {
		// in_changedArr : see cColonyBoard.changedPieces()
		in_changedArr.forEach(in_changed => {
			// backup initial value
			in_changed.initRotationX = in_changed.piece.rotation.x;
		});
		const ease = new cEase(0, Math.PI * 2, 500);
		return new Promise(in_resolved => {
			let updated = false;
			const hook = () => {
				const angle = ease.currentEasingOut();
				if (angle === Math.PI * 2) {
					in_world.removeAnimationHook(hook);
					in_changedArr.forEach(in_changed => {
						// restore initial value
						in_changed.piece.rotation.x = in_changed.initRotationX;
					});
					/*
						execute the process that follows the await (or callback defined in then),
						which corresponds to the then block of a promise
					*/
					(in_resolved)();
					return;
				}
				if ((angle > Math.PI) && (!updated)) {
					SE_MOVED.play();
					cGameController.#update(in_changedArr);
					updated = true;
				}
				in_changedArr.forEach(in_changed => {
					in_changed.piece.rotation.x = in_changed.initRotationX + angle;
				});
			};
			in_world.addAnimationHook(hook);
		});
	}
	#makeChangedArr(in_reversi, in_colony) {
		const indexTable = in_reversi.getTable();
		const colorTable = indexTable.map(in_row => in_row.map(in_cell => this.#mapping[in_cell]));
		// this can handle smaller table than colony
		return in_colony.changedPieces(colorTable);
	}
	reversiToColony(in_reversi, in_colony) {
		const changedArr = this.#makeChangedArr(in_reversi, in_colony);
		cGameController.#update(changedArr);
	}
	async reversiToColonyDynamic(in_reversi, in_colony, in_world) {
		const changedArr = this.#makeChangedArr(in_reversi, in_colony);
		await cGameController.#updateDynamic(changedArr, in_world);
	}
	convertColonyTable(in_colony) {
		const reverse = {};
		this.#mapping.forEach((in_value, in_ix) => {
			reverse[in_value] = in_ix;
		});
		let table = in_colony.getColorTable();
		if ((this.#tableSize.rows > 0) && (this.#tableSize.cols > 0)) {
			// resize to #tableSize
			table = table.slice(0, this.#tableSize.rows).map(in_row => in_row.slice(0, this.#tableSize.cols));
		}
		return table.map(in_row => in_row.map(in_cell => reverse[in_cell]));
	}
	async moveViewTo(in_piece, in_world) {
		const cameraPos = in_world.getCameraPos();
		const angleX = Math.atan2(cameraPos.y, cameraPos.z) - Math.atan2(in_piece.position.y, in_piece.position.z);
		const vec3 = cameraPos.applyMatrix4((new THREE.Matrix4()).makeRotationX(angleX));
		await in_world.motionViewFrom(vec3, 500);
	}
	async #playLastAction(in_reversi, in_colony, in_world) {
		const last = in_reversi.getLast();
		switch (last.action) {
		case 'choose-item' :
			const piece = in_colony.indexToPiece(last.row, last.col);
			await this.moveViewTo(piece, in_world);
			// choose
			setShellColor(piece, this.#mapping[last.who]);
			await this.reversiToColonyDynamic(in_reversi, in_colony, in_world);
			break;
		case 'npc-row-wise-rotate' :
			console.log('rotating', last);
			await (async ()=> {
				return new Promise(in_resolve => {
					const hook = in_colony.makeRotateProgress(last.target, last.delta, () => {
						in_world.removeAnimationHook(hook);
						(in_resolve)();
					});
					in_world.addAnimationHook(hook);
				});
			})();
			break;
		default :
			break;
		}
	}
	async npc(in_reversi, in_colony, in_world) {
		if (in_reversi.npc(this.#curIndex)) {
			await this.#playLastAction(in_reversi, in_colony, in_world);
			return true;
		} else {
			// can't do anything
			return false;
		}
	}
	async pc(in_piece, in_reversi, in_colony, in_world) {
		const resume = this.enableHandler;
		this.enableHandler = false;
		const pos = in_colony.pieceToIndex(in_piece);
		const result = in_reversi.pc(this.#curIndex, pos.row, pos.col);
		if (result) {
			SE_BEEP.play();
			await this.#playLastAction(in_reversi, in_colony, in_world);
		}
		this.enableHandler = resume;
		return result;
	}
	pcRotate(in_reversi, in_colony) {
		const table = this.convertColonyTable(in_colony);
		in_reversi.setActionResult(this.#curIndex, 'pc-row-wise-rotate', table);
	}
}

class cWarpLine {
	static #speed = 10;
	static #gradation = 10;
	constructor(in_canvas) {
		const w = in_canvas.width;
		const h = in_canvas.height;
		this.ctx = in_canvas.getContext('2d');
		this.box = new THREE.Box2(
			new THREE.Vector2(0, 0),
			new THREE.Vector2(w, h)
		);
		this.from = new THREE.Vector2(w / 2, h / 2);
		this.#reset();
	}
	#reset() {
		const angle = Math.random() * Math.PI * 2;
		this.direction = new THREE.Vector2(Math.cos(angle), Math.sin(angle));
		this.speed = Math.random() * cWarpLine.#speed + 5;
		this.length = 0;
	}
	#curVec(in_scalar) {
		return this.from.clone().add(this.direction.clone().multiplyScalar(in_scalar));
	}
	#drawGrayLine(in_from, in_to, in_grayScale) {
		const gray = (in_grayScale << 16) | (in_grayScale << 8) | in_grayScale;
		this.ctx.strokeStyle = '#' + gray.toString(16).padStart(6, '0');
		this.ctx.beginPath();
		this.ctx.moveTo(in_from.x, in_from.y);
		this.ctx.lineTo(in_to.x, in_to.y);
		this.ctx.stroke();
	}
	update() {
		this.length += this.speed;
		const to = this.#curVec(this.length);
		if (this.box.containsPoint(to)) {
			const notch = this.length / cWarpLine.#gradation;
			for (let i = 0; i < cWarpLine.#gradation; i++) {
				this.#drawGrayLine(
					this.#curVec(notch * i),
					this.#curVec(notch * (i + 1)),
					255 / cWarpLine.#gradation * (i + 1)
				);
			}
		} else {
			/*
				*** NOTE ***
				even if overwritung using black,
				this.#drawGrayLine(this.from, to, 0x00);
				smudge of white line will remain.
			*/
			this.#reset();
		}
	}
}

function warpViewProgress(in_canvas, in_lineCount) {
	const warpLines = [];
	for (let i = 0; i < in_lineCount; i++) {
		warpLines.push(new cWarpLine(in_canvas));
	}
	return () => {
		warpLines.forEach(in_line => {
			in_line.update();
		});
	}
}

function complete(in_player) {
	gController.end();
	gOrderChar.style.visibility = 'hidden';
	const progress = warpViewProgress(gBackgroundCanvas, 50);
	gWorld.addAnimationHook(progress);
	const duration = 2000;
	gWorld.motionZoom2(WORLD_RADIUS * 1.5, duration * 0.9);
	setTimeout(() => {
		gWorld.removeAnimationHook(progress);
		const dialog = document.createElement('div');
		Object.assign(dialog.style, {
			width : 'auto',
			height : 'auto',
			color : 'white',
			background : 'black',
			borderRadius : '1em',
			padding : '1.5em'
		});
		([
			'<div>Winner is ...</div>',
			'<div style="text-align:center"><img src="' + RES.get(in_player) + '" /></div>',
			'<div>Thanks to your wisdom, peace in the universe has been preserved.</div>',
			'<div>Click to go next stage.</div>',
		]).forEach(in_fragment => {
			dialog.innerHTML += in_fragment;
		});
		startDialog(dialog, async () => {
			drawCosmicView(gBackgroundCanvas, 400, 50);
			await nextLevel(false);
			gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);
		});
	}, duration);
}

const gOrderChar = (() => {
	const elem = document.createElement('IMG');
	const maxInt = 2 ** 31 - 1;
	Object.assign(elem.style, {
		position : 'absolute',
		bottom : '20px',
		right : '20px',
		width : '100px',
		height : 'auto',
		zIndex : maxInt
	});
	document.body.appendChild(elem);
	return elem;
})();

function initializeByLevel() {
	const curr = gMeshLevelMap.currItemByOrder();
	const [level, loop] = curr.k.split('-');
	const rowEdge = !loop;
	const [rows, cols, players] = level.split('x');
	const pc = 0;
	gController = new cGameController(players, pc);
	gController.setTableSize(rows, cols);
	const table = gController.convertColonyTable(gColony);
	gReversi = new cReversi(table, rowEdge, true);
	gController.setTurnHook(async (in_player, in_color, in_pc) => {
		gOrderChar.style.visibility = 'visible';
		gOrderChar.src = RES.get(in_color);
		if (in_pc) {
			const last = gReversi.getLast({who : pc, action : 'choose-item'});
			if (last) {
				const piece = gColony.indexToPiece(last.row, last.col);
				await gController.moveViewTo(piece, gWorld);
			}
			return;
		}
		const acted = await gController.npc(gReversi, gColony, gWorld);
		const winner = gController.endTurn(gReversi);
		if (winner < 0) {
			return;
		}
		complete(winner);
	});
	gController.reversiToColony(gReversi, gColony);
	gController.start();
}

(in_level => {
	if (in_level === false) {
		gMeshLevelMap.setOrder(2);
	} else {
		gMeshLevelMap.setOrder(in_level);
	}
})(getParam('level'));

const ID_PREV_LEVEL = randomString();
const ID_NEXT_LEVEL = randomString();

async function updateLevel() {
	const color = 0x000000;
	await gWorld.motionFog(color, 0, 100);
	gColony.removePieces();
	const current = gMeshLevelMap.currItemByOrder();
	gColony.addPieces(current.v);
	await gWorld.motionFog(color, 100, 0);
	const prev = gMeshLevelMap.prevItemByOrder();
	const next = gMeshLevelMap.nextItemByOrder();
	document.getElementById(ID_PREV_LEVEL).innerText = prev.k;
	document.getElementById(ID_NEXT_LEVEL).innerText = next.k;
	resetFocus();
	initializeByLevel();
}

updateLevel();

/*
	*** NOTE ***
	in Safari, using await to get audio will cause the process to fail.
	I'm not sure of the reason, but top-level await might be the cause.
	this time use then() to avoid the issue.
*/

let SE_BEEP = beep(2000);
let SE_DUMMY = beep(10);
let SE_MOVED = SE_BEEP;
let SE_ERROR = SE_BEEP;

SOUND.MOVED.then(in_decompress => {
	SE_MOVED = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

SOUND.ERROR.then(in_decompress => {
	SE_ERROR = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

function uiHelp() {
	const url = {
		ver : './version.txt',
		img : './side-six-reversi-help.gif',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div><img src="' + url.img + '" /></div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getResource(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.error(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		color : 'white',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Rights</dt>',
		'<dd>This software is based on MIT License.</dd>',
		'<dd>The code can be freely modified and reused.</dd>',
		'<dd>For full license details, please refer to :</dd>',
		'<dd>https://opensource.org/licenses/MIT</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	startDialog(dialog);
}

async function prevLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	gMeshLevelMap.shiftOrder(-1);
	await updateLevel();
}

async function nextLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	gMeshLevelMap.shiftOrder(+1);
	await updateLevel();
}

(in_settings => {
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	in_settings.forEach(in_setting => {
		let button = document.createElement('button');
		if (in_setting.id) {
			button.id = in_setting.id;
		}
		if (in_setting.text) {
			button.innerText = in_setting.text;
		}
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})([
	{
		id : ID_PREV_LEVEL,
		text : '(Prev)',
		func : prevLevel
	},
	{
		id : ID_NEXT_LEVEL,
		text : '(Next)',
		func : nextLevel
	},
	{
		text : 'help',
		func : uiHelp
	},
	{
		text : 'rights',
		func : uiRights
	}
]);

function hex2rgb(in_hex) {
	const mask = 0xFF;
	const r = (in_hex >> 16) & mask;
	const g = (in_hex >> 8) & mask;
	const b = in_hex & mask;
	return [r, g, b];
}

function drawCosmicView(in_canvas, in_stars, in_nebulae_patterns, in_color = 0x000064) {
	const ctx = in_canvas.getContext('2d');
	const w = in_canvas.width;
	const h = in_canvas.height;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	for (let i = 0; i < in_nebulae_patterns; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 100 + 50;
		const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
		const rgb = hex2rgb(in_color);
		gradient.addColorStop(0, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0.5)');
		gradient.addColorStop(1, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0)');
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = gradient;
		ctx.fill();
	}
	for (let i = 0; i < in_stars; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 1;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = 'white';
		ctx.fill();
	}
}

/*
	event handlers
*/

function drawBackground(in_canvas) {
	Object.assign(in_canvas.style, {
		position : 'absolute',
		left : 0,
		top : 0,
		zIndex : -1
	});
	drawCosmicView(in_canvas, 400, 50);
}

const gBackgroundCanvas = document.createElement('CANVAS');

function setupBody(in_document) {
	if (!in_document.body) {
		in_document.documentElement.appendChild(in_document.createElement('BODY'));
	}
	Object.assign(in_document.body.style, {
		margin : '0',
		overflow : 'hidden'
	});
}

function createChildWindow(in_document) {
	return new Promise(in_callback => {
		setupBody(in_document);
		const iframe = in_document.createElement('iframe');
		in_document.body.appendChild(iframe);
		Object.assign(iframe.style, {
			width: '100%',
			height: '100%',
			border: 'none'
		});
		/*
			*** NOTE ***
			although Chrome can use iframe.contentDocument right after createElement,
			Firefox can not use it ant needs to use asynchronous process.
			by the way, if you use not timer but load event,
			your code will not work for Chrome.
		*/
		setTimeout(() => {
			setupBody(iframe.contentDocument);
			(in_callback)(iframe.contentWindow);
		}, 0);
	});
}

document.addEventListener('DOMContentLoaded', (async () => {
	/*
		*** NOTE ***
		without iframe (outer window),
		geometry in event will be wrong because of google ads
	*/
	const outer = await createChildWindow(document);
	let resizeWorld = in_ev => {
		gWorld.resize(outer.innerWidth, outer.innerHeight);
		gBackgroundCanvas.width = outer.innerWidth;
		gBackgroundCanvas.height = outer.innerHeight;
		drawBackground(gBackgroundCanvas);
	};
	outer.addEventListener('resize', debouncing(resizeWorld, 300));
	outer.dispatchEvent(new Event('resize'));
	outer.document.body.appendChild(gWorld.canvas);
	outer.document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

const knock = nonReentrantAsync(async () => {
	SE_ERROR.play();
	await gWorld.motionKnock();
});

const notifyDelta = (() => {
	const RC = cColony.uiSetDeltaPositionRC;
	return in_ndc => {
		const intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			return;
		}
		const result = gColony.uiNotifyDeltaPosition(intersects[0].object, intersects[0].point, ndcToAbs(in_ndc));
		if (result === RC.UNMOVABLE) {
			knock();
		}
	}
})();

const focusHere = (() => {
	let focusedEmpty = null;
	const HIGHLIGHT = (new THREE.Color(EMPTYCOLOR)).lerp(new THREE.Color(0xFFFFFF), 0.3).getHex();
	return in_ndc => {
		let current, color;
		let intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length > 0) {
			current = intersects[0].object;
			color = getShellColor(current);
		} else {
			current = null;
			color = -1;
		}
		if ((color === EMPTYCOLOR) || (color === HIGHLIGHT)) {
			if (current === focusedEmpty) {
				return;
			}
			setShellColor(current, HIGHLIGHT);
			if (focusedEmpty) {
				setShellColor(focusedEmpty, EMPTYCOLOR);
			}
			focusedEmpty = current;
		} else {
			if (focusedEmpty) {
				setShellColor(focusedEmpty, EMPTYCOLOR);
			}
			focusedEmpty = null;
		}
	}
})();

function resetFocus() {
	const outOfRange = new THREE.Vector2(Infinity, Infinity);
	focusHere(outOfRange);
}

function rotateDone() {
	resetFocus();
	gController.pcRotate(gReversi, gColony);
	gController.endTurn(gReversi);
}

async function chooseHere(in_ev) {
	const ndc = ndcFromEvent(in_ev);
	let intersects = gWorld.intersectPositive(ndc);
	if (intersects.length === 0) {
		return;
	}
	resetFocus();
	const curr = intersects[0].object;
	if (getShellColor(curr) !== EMPTYCOLOR) {
		knock();
	} else {
		if (await gController.pc(curr, gReversi, gColony, gWorld)) {
			const winner = gController.endTurn(gReversi);
			if (winner < 0) {
				return;
			}
			complete(winner);
		} else {
			knock();
		}
	}
}

(() => {
	const closure = {
		x : -1,
		y : -1,
		once : false
	};
	const start = in_ev => {
		if (!closure.once) {
			/*
				*** NOTE ***
				Safari may restrict sound without user interaction.
				because of this, the sound does not work without this code.
			*/
			SE_DUMMY.play();
			closure.once = true;
		}
		const ndc = ndcFromEvent(in_ev);
		const intersects = gWorld.intersectPositive(ndc);
		if (intersects.length === 0) {
			return;
		}
		resetFocus();
		closure.x = in_ev.clientX;
		closure.y = in_ev.clientY;
		// can drag only cGameController.PC
		const drag = intersects[0].object
		if (gReversi.canRowWiseLoop() && (getShellColor(drag) === cGameController.PC)) {
			gColony.uiSetInitPosition(intersects[0].point, ndcToAbs(ndc));
		}
	};
	const move = thresholding(in_ev => {
		closure.x = -1;
		closure.y = -1;
		const ndc = ndcFromEvent(in_ev);
		if (gColony.uiIsMoving()) {
			if (gColony.uiUpdatePosition(ndcToAbs(ndc))) {
				SE_MOVED.play();
			}
		} else {
			if (gColony.uiIsDragging()) {
				notifyDelta(ndc);
			} else {
				if (!in_ev[isEmulated]) {
					focusHere(ndc);
				}
			}
		}
	});
	const stop = in_ev => {
		const releaseProgress = gColony.uiRelease(in_changed => {
			gWorld.removeAnimationHook(releaseProgress);
			if (in_changed) {
				rotateDone();
			}
		});
		if (releaseProgress) {
			gWorld.addAnimationHook(releaseProgress);
		} else {
			if ((closure.x !== in_ev.clientX) || (closure.y !== in_ev.clientY)) {
				return;
			}
			chooseHere(in_ev);
		}
	};
	let handlers = {
		'mousedown' : start,
		'mousemove' : move,
		'mouseleave' : stop,
		'mouseout' : stop,
		'mouseup' : stop
	};
	for (let [name, func] of Object.entries(handlers)) {
		gWorld.canvas.addEventListener(name, in_ev => {
			if (gController && gController.enableHandler) {
				(func.bind(this))(in_ev);
			}
		});
	}
})();

</script>
</body>
</html>
