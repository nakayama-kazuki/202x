<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports" : {
		"three" : "https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.min.js",
		"utils" : "https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/utils/BufferGeometryUtils.js",
		"basic" : "./basic-functions.js",
		"side6" : "./side-six.js",
		"s6res" : "./side-six-reversi-res.js",
		"sound" : "./sound-effect.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';
import {
	getResource,
	postResource,
	getParam,
	DEBUG,
	randomString,
	snapToNotch,
	snapToPI,
	snapTo05PI,
	createPeriodicSin,
	createPeriodicCos,
	pseudoMessageDigest1,
	pseudoMessageDigest2,
	beep,
	isEmulated,
	throttling,
	thresholding,
	debouncing,
	nonReentrantAsync,
	autoTransition,
	startDialog,
	factoryBuilder,
	arrRand,
	arrTrim,
	cEase,
	cApproximateMap,
	cApproximateSet,
	cCyclicMap,
	cCyclicValues,
	forEachCombination,
	clipArea,
	clipClearArea,
	fillRoundRect,
	XYZ,
	VEC3,
	DIRECTION,
	ndcFromEvent,
	ndcToAbs,
	getWorldVec3,
	getWorldUp,
	instanceInAncestor,
	lookAtWithoutRotation,
	safeMergeGeometry,
	makeTrapezoidGeometryParts,
	trapezoidGeometryUtil,
	roundBoxGeometry,
	roundRegularBoxGeometry,
	roundTrapezoidGeometry,
	capsuleConfigure,
	customCapsuleGeometry,
	cSphericalWorld
} from 'basic';
import {
	cColony
} from 'side6';
import {
	RES
} from 's6res';
import * as SOUND from 'sound';

/*
	the cReversi class is designed to implement NPC algorithms for the game of reversi.
*/

class cLineParser {
	static #border = -1;
	static #empty = 9;
	static #cntEmpty(in_arr) {
		return in_arr.filter(in_el => in_el === cLineParser.#empty).length;
	}
	static #findOneInnerEmpty(in_arr) {
		let emptyAppear = false;
		for (let i = 1; i < in_arr.length - 1; i++) {
			if (emptyAppear) {
				if (in_arr[i] === cLineParser.#empty) {
					return false;
				} else {
					return true;
				}
			}
			if (in_arr[i] === cLineParser.#empty) {
				emptyAppear = true;
			}
		}
		return false;
	}
	/*
		fmt_eXXXXX is for edge
	*/
	static #fmt_eCriticalToMe(in_l, in_r) {
		// B90011 ---> [B9][11]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty)) {
			if (in_r[0] !== cLineParser.#empty) {
				return true;
			}
		}
		return false;
	}
	static #fmt_ePreRiskToMe(in_l, in_r) {
		// B90090 ---> [B9][9]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty)) {
			if ((in_r.length === 1) &&
				(in_r[0] === cLineParser.#empty)) {
				return true;
			}
		}
		return false;
	}
	static #fmt_ePressureToMe(in_l, in_r) {
		// B900191 ---> [B9][191]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border)) {
			return cLineParser.#fmt_bPressureToMe(in_l, in_r);
		}
		return false;
	}
	static #fmt_ePrePressureToMe(in_l, in_r) {
		// B909191 ---> [B9][9191]
		if ((in_l.length === 2) &&
			(in_l[0] === cLineParser.#border)) {
			return cLineParser.#fmt_bPrePressureToMe(in_l, in_r);
		}
		return false;
	}
	static #fmt_ePressureByMe(in_l, in_r) {
		// B911090 ---> [B911][9]
		if ((in_l.length >= 3) &&
			(in_l[0] === cLineParser.#border) &&
			(in_l[1] === cLineParser.#empty) &&
			(cLineParser.#cntEmpty(in_l) === 1)) {
			return cLineParser.#fmt_bPressureByMe(in_l, in_r);
		}
		return false;
	}
	/*
		fmt_bXXXXX is for both edge and inner
	*/
	static #fmt_bPressureToMe(in_l, in_r) {
		// 9900191 ---> [99][191]
		if (in_l[in_l.length - 1] === cLineParser.#empty) {
			if ((in_r.length >= 3) &&
				(in_r[0] !== cLineParser.#empty)) {
				return cLineParser.#findOneInnerEmpty(in_r);
			}
		}
		return false;
	}
	static #fmt_bPrePressureToMe(in_l, in_r) {
		// 9909191 ---> [99][9191]
		if (in_l[in_l.length - 1] === cLineParser.#empty) {
			if ((in_r.length >= 3) &&
				(in_r[0] === cLineParser.#empty)) {
				return cLineParser.#findOneInnerEmpty(in_r);
			}
		}
		return false;
	}
	static #fmt_bPressureByMe(in_l, in_r) {
		// 9911090 ---> [9911][9]
		if ((in_l[in_l.length - 1] !== cLineParser.#empty) &&
			(cLineParser.#cntEmpty(in_l) >= 1)) {
			if ((in_r.length === 1) &&
				(in_r[0] === cLineParser.#empty)) {
				return true;
			}
		}
		return false;
	}
	static #fmt_bInnerByMe(in_l, in_r) {
		// 110199 --> [11][199]
		if ((in_l[in_l.length - 1] === in_r[0]) &&
			(in_r[0] !== cLineParser.#empty)) {
			return true;
		}
		return false;
	}
	static parse(in_items, in_player, in_loop, in_debug = false) {
		const parsed = {
			eCriticalToMe : false,
			ePreRiskToMe : false,
			ePressureToMe : false,
			ePrePressureToMe : false,
			ePressureByMe : false,
			bFulfilledWith : false,
			bPressureToMe : false,
			bPrePressureToMe : false,
			bPressureByMe : false,
			bPreOuterByMe : false,
			bOuterByMe : false,
			bInnerByMe : false,
			safetyScore : 0
		};
		let items;
		if (in_loop) {
			items = [...in_items];
		} else {
			items = [cLineParser.#border, ...in_items, cLineParser.#border];
		}
		if (items.indexOf(in_player) === -1) {
			return parsed;
		}
		/*
			(1) as in_player should be exist from here, split array using in_player

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : [12],[34]
				ex2 (loop) : [12],[34],[]
				ex3 (loop) : [],[12],[34],[]

				ex1 (non-loop) : [B12],[45B]
				ex2 (non-loop) : [B12],[34],[B]
				ex3 (non-loop) : [B],[12],[34],[B]
		*/
		let meMaxIx = 0;
		let meStart = false;
		// the 1st item may be empty
		const subsets = [[]];
		parsed.bFulfilledWith = true;
		for (let i = 0; i < items.length; i++) {
			if (items[i] === in_player) {
				if (meStart) {
					continue;
				} else {
					meStart = true;
					// the last item may be empty
					subsets[++meMaxIx] = [];
				}
			} else {
				meStart = false;
				if (items[i] === cLineParser.#empty) {
					parsed.bFulfilledWith = false;
				}
				subsets[meMaxIx].push(items[i]);
			}
		}
		if (parsed.bFulfilledWith) {
			return parsed;
		}
		/*
			(2) relate left side / right side to in_player

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : L[12]+R[34]
				ex2 (loop) : L[12]+R[34], L[34]+R[]
				ex3 (loop) : L[]+R[12],L[12]+R[34],L[34]+R[]

				ex1 (non-loop) : L[B12]+R[45B]
				ex2 (non-loop) : L[B12]+R[34],L[34]+R[B]
				ex3 (non-loop) : L[B]+R[12],L[12]+R[34],L[34]+R[B]
		*/
		const meNodes = [];
		for (let i = 0; i < meMaxIx; i++) {
			meNodes[i] = {
				L : subsets[i],
				R : subsets[i + 1]
			};
		}
		/*
			(3) normalize

				from ...

				ex1 : [12*34]
				ex2 : [12*34*]
				ex3 : [*12*34*]

				to ...

				ex1 (loop) : L[3412]+R[3412]
				ex2 (loop) : L[12]+R[34],L[34]+R[12]
				ex3 (loop) : L[34]+R[12],L[12]+R[34]

				ex1 (non-loop) : L[B12]+R[45B]
				ex2 (non-loop) : L[B12]+R[34],L[34]+R[B]
				ex3 (non-loop) : L[B]+R[12],L[12]+R[34],L[34]+R[B]
		*/
		const meFirst = meNodes[0];
		const meLast = meNodes[meNodes.length - 1];
		if (in_loop) {
			if ((meFirst.L.length === 0) && (meLast.R.length === 0)) {
				meFirst.L = [...meLast.L];
				meNodes.pop();
			} else {
				meFirst.L = [...meLast.R, ...meFirst.L];
				meLast.R = meFirst.L;
			}
		}
		/*
			(4) bPreOuterByMe, bOuterByMe
		*/
		if (in_loop) {
			for (let i = 0; i < meNodes.length; i++) {
				const cnt = cLineParser.#cntEmpty(meNodes[i].L);
				parsed['bPreOuterByMe'] ||= (cnt === 1);
				parsed['bOuterByMe'] ||= (cnt === 0);
			}
		} else {
			// except for both edges
			for (let i = 1; i < subsets.length - 1; i++) {
				const cnt = cLineParser.#cntEmpty(subsets[i]);
				parsed['bPreOuterByMe'] ||= (cnt === 1);
				parsed['bOuterByMe'] ||= (cnt === 0);
			}
		}
		/*
			(5) calculate score + check format
		*/
		const formatArr = [
			['eCriticalToMe', cLineParser.#fmt_eCriticalToMe],
			['ePreRiskToMe', cLineParser.#fmt_ePreRiskToMe],
			['ePressureToMe', cLineParser.#fmt_ePressureToMe],
			['ePrePressureToMe', cLineParser.#fmt_ePrePressureToMe],
			['ePressureByMe', cLineParser.#fmt_ePressureByMe],
			['bPressureToMe', cLineParser.#fmt_bPressureToMe],
			['bPrePressureToMe', cLineParser.#fmt_bPrePressureToMe],
			['bPressureByMe', cLineParser.#fmt_bPressureByMe],
			['bInnerByMe', cLineParser.#fmt_bInnerByMe]
		];
		for (let i = 0; i < meNodes.length; i++) {
			const curr = meNodes[i];
			const neighborL = curr.L[curr.L.length - 1];
			const neighborR = curr.R[0];
			if ((neighborL === neighborR) ||
				(neighborL === cLineParser.#border) ||
				(neighborR === cLineParser.#border)) {
				parsed.safetyScore += 1;
			} else {
				parsed.safetyScore -= 1;
			}
			const reversedR = curr.R.toReversed();
			const reversedL = curr.L.toReversed()
			formatArr.forEach(([in_format, in_checker]) => {
				if (parsed[in_format]) {
					return;
				}
				const toL = (in_checker)(curr.L, curr.R);
				const toR = (in_checker)(reversedR, reversedL);
				parsed[in_format] = toL || toR;
			});
		}
		return parsed;
	}
}

(in_test => {

if (!in_test) {
	return;
}

const suites = [

	{group : '*** 1. there is no pc ***'},

		{items : [9,9,9,9,9,9,9,9], loop : false, safetyScore : 0, dp : false},
		{items : [9,9,9,9,1,2,1,2], loop : false, safetyScore : 0, dp : false},
		{items : [1,2,1,2,1,2,1,2], loop : false, safetyScore : 0, dp : false},

		{items : [9,9,9,9,9,9,9,9], loop : true, safetyScore : 0, dp : false},
		{items : [9,9,9,9,1,2,1,2], loop : true, safetyScore : 0, dp : false},
		{items : [1,2,1,2,1,2,1,2], loop : true, safetyScore : 0, dp : false},

	{group : '*** 2. no empty ***'},

		{items : [0,0,0,0,0,0,0,0], loop : false, safetyScore : 0, dp : false},
		{items : [1,2,1,2,0,0,0,0], loop : false, safetyScore : 0, dp : false},

		{items : [0,0,0,0,0,0,0,0], loop : true, safetyScore : 0, dp : false},
		{items : [1,2,1,2,0,0,0,0], loop : true, safetyScore : 0, dp : false},

	{group : '*** 3. pc is on the left side ***'},

		{items : [0,9,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,9], loop : false, safetyScore : 1, dp : false},
		{items : [0,9,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,1], loop : false, safetyScore : 1, dp : false},

		{items : [0,9,9,9,9,9,9,9], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,9], loop : true, safetyScore : -1, dp : false},
		{items : [0,9,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
		{items : [0,1,9,9,9,9,9,1], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,2], loop : true, safetyScore : -1, dp : false},

	{group : '*** 4. pc is on the right side ***'},

		{items : [9,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
		{items : [9,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},
		{items : [1,9,9,9,9,9,9,0], loop : false, safetyScore : 1, dp : false},
		{items : [1,9,9,9,9,9,1,0], loop : false, safetyScore : 1, dp : false},

		{items : [9,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
		{items : [9,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,1,0], loop : true, safetyScore : 0, dp : false},
		{items : [2,0,9,9,9,9,1,0], loop : true, safetyScore : -2, dp : false},

	{group : '*** 5. pc is on the both sides ***'},

		{items : [0,9,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,1,9,9,9,9,9,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,9,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : false, safetyScore : 2, dp : false},

		{items : [0,9,9,9,9,9,9,0], loop : true, safetyScore : 1, dp : false},
		{items : [0,1,9,9,9,9,9,0], loop : true, safetyScore : -1, dp : false},
		{items : [0,9,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : true, safetyScore : 1, dp : false},
		{items : [0,2,9,9,9,9,1,0], loop : true, safetyScore : -1, dp : false},

	{group : '*** 6. npc is on the both sides ***'},

		{items : [1,9,9,9,9,9,9,1], loop : false, safetyScore : 0, dp : false},
		{items : [1,0,9,9,9,9,9,1], loop : false, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,0,1], loop : false, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,0,1], loop : false, safetyScore : -2, dp : false},

		{items : [1,9,9,9,9,9,9,1], loop : true, safetyScore : 0, dp : false},
		{items : [1,0,9,9,9,9,9,1], loop : true, safetyScore : -1, dp : false},
		{items : [1,9,9,9,9,9,0,1], loop : true, safetyScore : -1, dp : false},
		{items : [1,0,9,9,9,9,0,1], loop : true, safetyScore : -2, dp : false},

	{group : '*** 7. bFulfilledWith ***'},

		{items : [1,1,1,1,1,1,1,1], loop : false, bFulfilledWith : false, dp : false},
		{items : [1,1,1,9,0,1,1,1], loop : false, bFulfilledWith : false, dp : false},
		{items : [1,1,1,0,0,1,1,1], loop : false, bFulfilledWith : true, dp : false},
		{items : [0,0,0,0,0,0,0,0], loop : false, bFulfilledWith : true, dp : false},
		{items : [0,0,0,9,0,0,0,0], loop : false, bFulfilledWith : false, dp : false},

		{items : [1,1,1,1,1,1,1,1], loop : true, bFulfilledWith : false, dp : false},
		{items : [1,1,1,9,0,1,1,1], loop : true, bFulfilledWith : false, dp : false},
		{items : [1,1,1,0,0,1,1,1], loop : true, bFulfilledWith : true, dp : false},
		{items : [0,0,0,0,0,0,0,0], loop : true, bFulfilledWith : true, dp : false},
		{items : [0,0,0,9,0,0,0,0], loop : true, bFulfilledWith : false, dp : false},

	{group : '*** 8. bOuterByMe ***'},

		{items : [0,1,0,9,9,9,9,9], loop : false, bOuterByMe : true, dp : false},
		{items : [1,0,9,9,9,9,9,0], loop : false, bOuterByMe : false, dp : false},
		{items : [0,9,9,9,9,9,0,1], loop : false, bOuterByMe : false, dp : false},
		{items : [9,9,9,9,9,0,1,0], loop : false, bOuterByMe : true, dp : false},
		{items : [9,9,0,1,2,0,9,9], loop : false, bOuterByMe : true, dp : false},
		{items : [2,0,9,9,9,9,0,1], loop : false, bOuterByMe : false, dp : false},

		{items : [0,1,0,9,9,9,9,9], loop : true, bOuterByMe : true, dp : false},
		{items : [1,0,9,9,9,9,9,0], loop : true, bOuterByMe : true, dp : false},
		{items : [0,9,9,9,9,9,0,1], loop : true, bOuterByMe : true, dp : false},
		{items : [9,9,9,9,9,0,1,0], loop : true, bOuterByMe : true, dp : false},
		{items : [9,9,0,1,2,0,9,9], loop : true, bOuterByMe : true, dp : false},
		{items : [2,0,9,9,9,9,0,1], loop : true, bOuterByMe : true, dp : false},

	{group : '*** 9. bPreOuterByMe ***'},

		{items : [9,0,9,9,9,9,9,0], loop : false, bPreOuterByMe : false, dp : false},
		{items : [0,9,0,9,9,9,9,9], loop : false, bPreOuterByMe : true, dp : false},
		{items : [9,0,9,0,9,9,9,9], loop : false, bPreOuterByMe : true, dp : false},
		{items : [9,0,1,0,9,9,9,9], loop : false, bPreOuterByMe : false, dp : false},
		{items : [9,0,9,9,0,9,9,9], loop : false, bPreOuterByMe : false, dp : false},

		{items : [9,0,9,9,9,9,9,0], loop : true, bPreOuterByMe : true, dp : false},

	{group : '*** 10. eCriticalToMe ***'},

		{items : [0,1,9,9,9,9,9,9], loop : false, eCriticalToMe : false, dp : false},
		{items : [9,0,1,9,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,1,0,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,1,2,9,9,9,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,0,9,1,9,9,9,9], loop : false, eCriticalToMe : false, dp : false},

		{items : [9,9,9,9,9,9,1,0], loop : false, eCriticalToMe : false, dp : false},
		{items : [9,9,9,9,9,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,0,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,2,1,0,9], loop : false, eCriticalToMe : true, dp : false},
		{items : [9,9,9,9,1,9,0,9], loop : false, eCriticalToMe : false, dp : false},

	{group : '*** 11. ePreRiskToMe ***'},

		{items : [9,0,9,0,9,9,9,9], loop : false, ePreRiskToMe : true, dp : false},
		{items : [9,0,9,9,0,9,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,0,9,0,9,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,0,0,9,0,0,9,9], loop : false, ePreRiskToMe : true, dp : false},

		{items : [9,9,9,9,0,9,0,9], loop : false, ePreRiskToMe : true, dp : false},
		{items : [9,9,9,0,9,9,0,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,9,0,9,0,9,9], loop : false, ePreRiskToMe : false, dp : false},
		{items : [9,9,0,0,9,0,0,9], loop : false, ePreRiskToMe : true, dp : false},

	{group : '*** 12. ePressureToMe ***'},

		{items : [9,0,1,9,1,9,9,9], loop : false, ePressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : false, ePressureToMe : false, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : false, ePressureToMe : true, dp : false},
		{items : [9,0,1,9,1,9,9,9], loop : true, ePressureToMe : false, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : true, ePressureToMe : false, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : true, ePressureToMe : false, dp : false},

		{items : [9,9,1,9,1,0,9,9], loop : false, ePressureToMe : false, dp : false},
		{items : [9,1,9,1,1,0,0,9], loop : false, ePressureToMe : true, dp : false},

	{group : '*** 13. bPressureToMe ***'},

		{items : [9,0,1,9,1,9,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,0,1,9,1,9,9,9], loop : true, bPressureToMe : true, dp : false},
		{items : [9,9,0,1,9,1,9,9], loop : true, bPressureToMe : true, dp : false},
		{items : [9,0,0,1,1,9,1,9], loop : true, bPressureToMe : true, dp : false},

		{items : [9,9,1,9,1,0,9,9], loop : false, bPressureToMe : true, dp : false},
		{items : [9,1,9,1,1,0,0,9], loop : false, bPressureToMe : true, dp : false},

	{group : '*** 14. ePrePressureToMe ***'},

		{items : [9,0,9,9,1,9,9,9], loop : false, ePrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : false, ePrePressureToMe : false, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : false, ePrePressureToMe : true, dp : false},
		{items : [9,0,9,9,1,9,9,9], loop : true, ePrePressureToMe : false, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : true, ePrePressureToMe : false, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : true, ePrePressureToMe : false, dp : false},

		{items : [9,9,1,9,9,0,9,9], loop : false, ePrePressureToMe : false, dp : false},
		{items : [9,1,9,1,9,0,0,9], loop : false, ePrePressureToMe : true, dp : false},

	{group : '*** 15. bPrePressureToMe ***'},

		{items : [9,0,9,9,1,9,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,0,9,9,1,9,9,9], loop : true, bPrePressureToMe : true, dp : false},
		{items : [9,9,0,9,9,1,9,9], loop : true, bPrePressureToMe : true, dp : false},
		{items : [9,0,0,9,1,9,1,9], loop : true, bPrePressureToMe : true, dp : false},

		{items : [9,9,1,9,9,0,9,9], loop : false, bPrePressureToMe : true, dp : false},
		{items : [9,1,9,1,9,0,0,9], loop : false, bPrePressureToMe : true, dp : false},

	{group : '*** 16. ePressureByMe ***'},

		{items : [1,1,0,9,0,9,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,1,0,9,0,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,1,0,9,0,9,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,0,0,9,0,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : true, ePressureByMe : false, dp : false},

		{items : [9,9,9,0,9,0,1,1], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,0,9,0,1,9,9], loop : false, ePressureByMe : false, dp : false},
		{items : [9,9,9,0,9,0,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,0,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : false, ePressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : true, ePressureByMe : false, dp : false},

	{group : '*** 17. bPressureByMe ***'},

		{items : [1,1,0,9,0,9,9,9], loop : false, bPressureByMe : false, dp : false},
		{items : [9,9,1,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,0,9,0,9,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,0,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,1,1,0,9,0,9,9], loop : true, bPressureByMe : true, dp : false},

		{items : [9,9,9,0,9,0,1,1], loop : false, bPressureByMe : false, dp : false},
		{items : [9,9,0,9,0,1,9,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,9,0,9,0,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,0,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : false, bPressureByMe : true, dp : false},
		{items : [9,9,0,9,0,1,1,9], loop : true, bPressureByMe : true, dp : false},

	{group : '*** 18. bInnerByMe ***'},

		{items : [9,9,9,9,9,9,9,9], loop : false, bInnerByMe : false, dp : false},

		{items : [1,0,1,9,9,9,9,9], loop : false, bInnerByMe : true, dp : false},
		{items : [1,0,0,1,9,9,9,9], loop : false, bInnerByMe : true, dp : false},
		{items : [2,0,0,1,9,9,9,9], loop : false, bInnerByMe : false, dp : false},
		{items : [1,9,0,1,9,9,9,9], loop : false, bInnerByMe : false, dp : false},

		{items : [0,1,9,9,9,9,9,1], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,2,0], loop : false, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,9], loop : false, bInnerByMe : false, dp : false},

		{items : [0,1,9,9,9,9,9,1], loop : true, bInnerByMe : true, dp : false},
		{items : [0,1,9,9,9,9,1,0], loop : true, bInnerByMe : true, dp : false},
		{items : [0,1,9,9,9,9,2,0], loop : true, bInnerByMe : false, dp : false},
		{items : [0,1,9,9,9,9,1,9], loop : true, bInnerByMe : false, dp : false}
];
suites.forEach(in_suite => {
	if (in_suite.group) {
		console.log(in_suite.group);
	} else {
		const parsed = cLineParser.parse(in_suite.items, 0, in_suite.loop, in_suite.dp);
		Object.keys(parsed).forEach(in_prop => {
			if (!in_suite.hasOwnProperty(in_prop)) {
				return;
			}
			if (in_suite[in_prop] !== parsed[in_prop]) {
				const loop = in_suite.loop ? ' (loop)' : '';
				console.log('failed : ' + in_suite.items.join() + loop + ' is ' + parsed[in_prop]);
			}
		});
	}
});

})(false);

class cReversi {
	static #maximize(in_evaluator, in_player, in_candArr) {
		const evaluated = new Map();
		in_candArr.forEach(in_ix => evaluated.set(in_ix, (in_evaluator)(in_player, in_ix)));
		const max = {
			value : -Infinity,
			indexes : []
		};
		for (const [index, value] of evaluated.entries()) {
			if (value > max.value) {
				max.value = value;
				max.indexes = [index];
			} else {
				if (value === max.value) {
					max.indexes.push(index);
				}
			}
		}
		if (max.indexes.length === 0) {
			console.log(evaluated);
			throw new Error();
		}
		return max.indexes;
	}
	static #rotateArray(in_array, in_delta) {
		const len = in_array.length;
		const delta = ((in_delta % len) + len) % len;
		return in_array.slice(delta).concat(in_array.slice(0, delta));
	}
	static #dmz = 8;
	static #empty = 9;
	static #maxPlayers = 6;
	static #validData = (() => {
		const arr = [cReversi.#dmz, cReversi.#empty];
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			arr.push(player);
		}
		return arr;
	})();
	static #addUniqueSet(in_newSet, in_arr) {
		const duplicated = in_arr.some(in_addedSet => {
			if (in_newSet.size !== in_addedSet.size) {
				return false;
			}
			for (const item of in_newSet) {
				if (!in_addedSet.has(item)) {
					return false;
				}
			}
			return true;
		});
		if (!duplicated) {
			in_arr.push(in_newSet);
		}
	}
	static #dirStyle = {
		square : {
			onehand : {
				regular : [
					[-1, -1],
					[-1,  0],
					[-1, +1],
					[ 0, -1],
					[ 0, +1],
					[+1, -1],
					[+1,  0],
					[+1, +1]
				],
				offset : [
					[-1, -1],
					[-1,  0],
					[-1, +1],
					[ 0, -1],
					[ 0, +1],
					[+1, -1],
					[+1,  0],
					[+1, +1]
				]
			},
			pair : new Map([
				[  0, [1, 6]],
				[ 45, [2, 5]],
				[ 90, [3, 4]],
				[135, [0, 7]]
			])
		},
		hexPointyTopped : {
			onehand : {
				/*
					@@
					@+@
					@@
				*/
				regular : [
					[-1, -1],
					[-1,  0],
					[ 0, +1],
					[+1,  0],
					[+1, -1],
					[ 0, -1]
				],
				/*
					 @@
					@+@
					 @@
				*/
				offset : [
					[-1,  0],
					[-1, +1],
					[ 0, +1],
					[+1, +1],
					[+1,  0],
					[ 0, -1]
				]
			},
			pair : new Map([
				[ 30, [1, 4]],
				[ 90, [2, 5]],
				[150, [0, 3]]
			])
		},
		hexFlatTopped : {
			onehand : {
				/*
					@@@
					@+@
					 @
				*/
				regular : [
					[-1, -1],
					[-1,  0],
					[-1, +1],
					[ 0, +1],
					[+1,  0],
					[ 0, -1]
				],
				/*
					 @
					@+@
					@@@
				*/
				offset : [
					[ 0, -1],
					[-1,  0],
					[ 0, +1],
					[+1, +1],
					[+1,  0],
					[+1, -1]
				]
			},
			pair : new Map([
				[  0, [1, 4]],
				[ 60, [2, 5]],
				[120, [0, 3]]
			])
		}
	};
	#area = {
		items : [],
		options : new Set(),
		scores : {
			default : [],
			players : []
		}
	};
	#npcArgoPriority = [];
	#history = [];
	#conf = null;
	#rotations = null;
	#getDirections(in_row, in_col) {
		const dirStyle = this.#conf.dirStyle;
		let useOffset = false;
		if (dirStyle.pair.get(0)) {
			// square or hexFlatTopped
			useOffset = (in_col % 2 === this.#conf.offset);
		} else {
			// hexPointyTopped
			useOffset = (in_row % 2 === this.#conf.offset);
		}
		if (useOffset) {
			return dirStyle.onehand.offset;
		} else {
			return dirStyle.onehand.regular;
		}
	}
	#getDirection(in_row, in_col, in_dirIx) {
		return this.#getDirections(in_row, in_col)[in_dirIx];
	}
	#aroundIndexes(in_ix) {
		const pos = this.#indexToPos(in_ix);
		return this.#aroundPositions(pos.row, pos.col).map(([in_row, in_col]) => this.#posToIndex(in_row, in_col));
	}
	#aroundPositions(in_row, in_col) {
		const directions = this.#getDirections(in_row, in_col);
		const aroundPos = [];
		const sizeRow = this.#conf.row.size;
		const sizeCol = this.#conf.col.size;
		directions.forEach(([in_dr, in_dc]) => {
			let row = in_row + in_dr;
			let col = in_col + in_dc;
			if ((row < 0) || (sizeRow -1 < row)) {
				if (this.#conf.row.edge) {
					return;
				} else {
					row = (sizeRow + row) % sizeRow;
				}
			}
			if ((col < 0) || (sizeCol -1 < col)) {
				if (this.#conf.col.edge) {
					return;
				} else {
					col = (sizeCol + col) % sizeCol;
				}
			}
			aroundPos.push([row, col]);
		});
		return aroundPos;
	}
	#indexesUntil(in_indexes, in_item) {
		const toItem = in_indexes.findIndex(in_ix => this.#getItemByIndex(in_ix) === in_item);
		if (toItem < 0) {
			return in_indexes;
		} else {
			return in_indexes.slice(0, toItem);
		}
	}
	constructor(in_table, in_rowEdge, in_colEdge, in_format = 'square', in_offset = 1) {
		const sizeRow = in_table.length;
		const sizeCol = in_table.reduce((in_maxLen, in_row) => {
			return Math.max(in_maxLen, in_row.length);
		}, 0);
		if (cReversi.#dirStyle.hasOwnProperty(in_format)) {
			if (!in_rowEdge && (sizeRow % 2 === 1) && (in_format === 'hexPointyTopped')) {
				throw new Error('invalid rows (' + sizeRow + ') for row-loop of ' + in_format);
			}
			if (!in_colEdge && (sizeCol % 2 === 1) && (in_format === 'hexFlatTopped')) {
				throw new Error('invalid cols (' + sizeRow + ') for col-loop of ' + in_format);
			}
		} else {
			throw new Error('invalid input');
		}
		const dirStyle = cReversi.#dirStyle[in_format];
		this.#conf = {
			row : {
				size : sizeRow,
				edge : in_rowEdge
			},
			col : {
				size : sizeCol,
				edge : in_colEdge
			},
			dirStyle : dirStyle,
			// square can accommodate any offset
			offset : (in_offset % 2),
			rotatable : {
				fixedCol : !in_rowEdge && dirStyle.pair.has(0),
				fixedRow : !in_colEdge && dirStyle.pair.has(90)
			},
			tagIndexes : {
				radiating : [],
				edgeSetArr : [],
				cornerSet : new Set(),
				xInsideSet : new Set()
			}
		};
		this.setTable(in_table);
		this.#initTagIndexes();
		this.#initScore();
		const argoArr = ['safety', 'spiteful', 'balance', 'greedy', 'learner', 'classic', 'beginner', 'monkey'];
		for (let i = 0; i < argoArr.length; i++) {
			this.#npcArgoPriority.push((argoArr.slice(0, i + 1))[arrRand]());
		}
		this.#updateOptionsAll();
		// console.log(this.#conf.tagIndexes);
	}
	#initTagIndexesRadiating() {
		const tagIndexes = this.#conf.tagIndexes;
		for (let areaIx = 0; areaIx < this.#area.items.length; areaIx++) {
			const {row : initRow, col : initCol} = this.#indexToPos(areaIx);
			const radiating = tagIndexes.radiating[areaIx] = [];
			const dirStyle = this.#getDirections(initRow, initCol);
			// don't need radiating which starts from dmz
			const wouldScan = (this.#getItemByIndex(areaIx) !== cReversi.#dmz);
			for (let dirIx = 0; dirIx < dirStyle.length; dirIx++) {
				const towards = [];
				let currRow = initRow;
				let currCol = initCol;
				while (wouldScan) {
					const [dr, dc] = this.#getDirection(currRow, currCol, dirIx);
					currRow += dr;
					if (this.#conf.row.edge) {
						if ((currRow < 0) || (this.#conf.row.size - 1 < currRow)) {
							// out of range
							break;
						}
					} else {
						currRow = (currRow + this.#conf.row.size) % this.#conf.row.size;
						if ((currRow === initRow) && (dr !== 0)) {
							// cyclic
							break;
						}
					}
					currCol += dc;
					if (this.#conf.col.edge) {
						if ((currCol < 0) || (this.#conf.col.size - 1 < currCol)) {
							// out of range
							break;
						}
					} else {
						currCol = (currCol + this.#conf.col.size) % this.#conf.col.size;
						if ((currCol === initCol) && (dc !== 0)) {
							// cyclic
							break;
						}
					}
					towards.push(this.#posToIndex(currRow, currCol));
				}
				radiating.push(towards);
			}
		}
	}
	#initTagIndexes() {
		this.#initTagIndexesRadiating();
		const pairs = Array.from(this.#conf.dirStyle.pair.values());
		const edgeAdhocMinLength = 6;
		const tagIndexes = this.#conf.tagIndexes;
		for (let areaIx = 0; areaIx < this.#area.items.length; areaIx++) {
			if (this.#getItemByIndex(areaIx) === cReversi.#dmz) {
				continue;
			}
			const radiating = tagIndexes.radiating[areaIx];
			// (1) edgeSetArr
			pairs.forEach(([in_pos, in_neg]) => {
				const pos = this.#indexesUntil(radiating[in_pos], cReversi.#dmz);
				const neg = this.#indexesUntil(radiating[in_neg], cReversi.#dmz);
				const edgeSet = new Set([...pos, areaIx, ...neg]);
				if (edgeSet.size < edgeAdhocMinLength) {
					return;
				}
				const isEdge = Array.from(edgeSet).every(edgeIx => {
					const aroundArr = this.#aroundIndexes(edgeIx);
					if (aroundArr.length < pairs.length * 2) {
						return true;
					}
					return aroundArr.some(in_aroundIx => {
						return (this.#getItemByIndex(in_aroundIx) === cReversi.#dmz);
					});
				});
				if (isEdge) {
					cReversi.#addUniqueSet(edgeSet, tagIndexes.edgeSetArr);
				}
			});
			// (2) corner
			const isCorner = pairs.every(([in_pos, in_neg]) => {
				const P = radiating[in_pos];
				const N = radiating[in_neg];
				if ((P.length === 0) || (this.#getItemByIndex(P[0]) === cReversi.#dmz)) {
					return true;
				}
				if ((N.length === 0) || (this.#getItemByIndex(N[0]) === cReversi.#dmz)) {
					return true;
				}
				// both sides are available
				return false;
			});
			if (!isCorner) {
				continue;
			} else {
				tagIndexes.cornerSet.add(areaIx);
			}
			// (3) xInsideSet, when areaIx is corner
			const aroundArr = this.#aroundIndexes(areaIx);
			aroundArr.forEach(in_aroundIx => {
				const testArr = this.#aroundIndexes(in_aroundIx);
				if (testArr.length < pairs.length * 2) {
					return;
				}
				if (testArr.every(in_testIx => this.#getItemByIndex(in_testIx) === cReversi.#empty)) {
					tagIndexes.xInsideSet.add(in_aroundIx);
				}
			});
		}
	}
	#indexToPos(in_ix) {
		return {
			row : Math.floor(in_ix / this.#conf.col.size),
			col : in_ix % this.#conf.col.size
		};
	}
	#posToIndex(in_row, in_col) {
		return in_row * this.#conf.col.size + in_col;
	}
	#setItemByIndex(in_ix, in_item) {
		this.#area.items[in_ix] = in_item;
	}
	#setItemByPos(in_row, in_col, in_item) {
		this.#setItemByIndex(this.#posToIndex(in_row, in_col), in_item);
	}
	#getItemByIndex(in_ix) {
		return this.#area.items[in_ix];
	}
	#getItemByPos(in_row, in_col) {
		return this.#getItemByIndex(this.#posToIndex(in_row, in_col));
	}
	#items(in_indexes) {
		const items = [];
		in_indexes.forEach(in_ix => {
			items.push(this.#getItemByIndex(in_ix));
		});
		return items;
	}
	#rotateItems(in_indexes, in_delta) {
		const shifted = cReversi.#rotateArray(in_indexes, in_delta);
		const copy = [...this.#area.items];
		for (let i = 0; i < in_indexes.length; i++) {
			/*
				for example ...
				src = 5, 6, 7, 8
				dst = 8, 5, 6, 7
			*/
			this.#setItemByIndex(in_indexes[i], copy[shifted[i]]);
		}
	}
	#rotateSameRowItems(in_fixedRow, in_deltaCol) {
		const ix = this.#posToIndex(in_fixedRow, 0);
		const radiating = this.#conf.tagIndexes.radiating[ix];
		// in case of loop, forward and backward include the same indexes
		const [forward, backward] = this.#conf.dirStyle.pair.get(90);
		this.#rotateItems([ix, ...radiating[forward]], in_deltaCol);
	}
	#rotateSameColItems(in_fixedCol, in_deltaRow) {
		const ix = this.#posToIndex(0, in_fixedCol);
		const radiating = this.#conf.tagIndexes.radiating[ix];
		// in case of loop, forward and backward include the same indexes
		const [forward, backward] = this.#conf.dirStyle.pair.get(0);
		this.#rotateItems([ix, ...radiating[forward]], in_deltaRow);
	}
	#flip(in_player, in_ix, in_dryRun = false) {
		const radiating = this.#conf.tagIndexes.radiating[in_ix];
		let flipped = false;
		for (let i = 0; i < radiating.length; i++) {
			const towards = radiating[i];
			const ixArr = [];
			let enemyAppears = false;
			for (let j = 0; j < towards.length; j++) {
				const ix = towards[j];
				const item = this.#getItemByIndex(ix);
				if (item === in_player) {
					if (enemyAppears) {
						if (in_dryRun) {
							// the same as Array.some() for dry run
							return true;
						} else {
							flipped = true;
							ixArr.forEach(in_flipped_ix => this.#setItemByIndex(in_flipped_ix, in_player));
						}
					}
					break;
				} else {
					if ((item === cReversi.#dmz) || (item === cReversi.#empty)) {
						break;
					} else {
						ixArr.push(ix);
						enemyAppears = true;
					}
				}
			}
		}
		if (flipped) {
			this.#setItemByIndex(in_ix, in_player);
			this.#updateOptions(in_ix);
			this.#updateScore();
		}
		return flipped;
	}
	#tryRotation(in_player, in_action) {
		// step1 : find rows/cols where in_player owns at least one cell
		const rowSet = new Set();
		const colSet = new Set();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) !== in_player) {
				continue;
			}
			const col = ix % this.#conf.col.size;
			const row = (ix - col) / this.#conf.col.size;
			rowSet.add(row);
			colSet.add(col);
		}
		// step2 : test for in_action. this algorithm can be improved
		const setting = {
			'fixed-row-rotate' : {
				targetArr : Array.from(rowSet),
				rotateFunc : this.#rotateSameRowItems.bind(this),
				maxCnt : this.#conf.col.size
			},
			'fixed-col-rotate' : {
				targetArr : Array.from(colSet),
				rotateFunc : this.#rotateSameColItems.bind(this),
				maxCnt : this.#conf.row.size
			}
		}
		const {targetArr, rotateFunc, maxCnt} = setting[in_action];
		const result = {target : -1, delta : -1};
		const rollback = this.#createRollback();
		const rotated = targetArr.some(in_target => {
			result.target = in_target;
			let rest = maxCnt;
			while (--rest > 0) {
				// rotate +1 (maxCnt - 1) times
				(rotateFunc)(in_target, 1);
				const cand = this.#searchCandidates(in_player);
				if (cand.length > 0) {
					result.delta = maxCnt - rest;
					return true;
				}
			}
			return false;
		});
		if (rotated) {
			return result;
		} else {
			(rollback)();
			return null;
		}
	}
	#count(in_player) {
		const items = this.#area.items.filter(in_el => in_el === in_player);
		return items.length;
	}
	#emptyCnt() {
		return this.#count(cReversi.#empty);
	}
	#searchCandidates(in_player) {
		const candidates = [];
		const asDryRun = true;
		this.#area.options.forEach(in_empty_ix => {
			if (this.#flip(in_player, in_empty_ix, asDryRun)) {
				candidates.push(in_empty_ix);
			}
		});
		return candidates;
	}
	#updateOptions(in_ix) {
		const aroundArr = this.#aroundIndexes(in_ix);
		aroundArr.forEach(in_aroundIx => {
			if (this.#getItemByIndex(in_aroundIx) === cReversi.#empty) {
				this.#area.options.add(in_aroundIx);
			}
		});
		// in_ix should be new occupied position
		this.#area.options.delete(in_ix);
	}
	#updateOptionsAll() {
		this.#area.options.clear();
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const item = this.#getItemByIndex(ix);
			if ((item === cReversi.#empty) || (item === cReversi.#dmz)) {
				continue;
			}
			this.#updateOptions(ix);
		}
	}
	#getAreaScore(in_player, in_ix) {
		return this.#area.scores.players[in_player][in_ix];
	}
	#initScore() {
		this.#initScore_forDefault();
		this.#initScore_forPlayers();
	}
	#initScore_forDefault() {
		const attenuation = 5;
		this.#area.scores.default = new Array(this.#area.items.length).fill(0);
		let loopCnt = 3;
		while (loopCnt-- > 0) {
			const buff = [];
			for (let areaIx = 0; areaIx < this.#area.items.length; areaIx++) {
				const aroundArr = this.#aroundIndexes(areaIx);
				let score = this.#conf.dirStyle.pair.size * 2 - aroundArr.length;
				aroundArr.forEach(in_aroundIx => {
					if (this.#area.items[in_aroundIx] === cReversi.#dmz) {
						score++;
					} else {
						// a cell adjacent to a high-score cell should have its score reduced
						score -= Math.floor(this.#area.scores.default[in_aroundIx] / attenuation);
					}
				});
				buff[areaIx] = score;
			}
			for (let areaIx = 0; areaIx < this.#area.scores.default.length; areaIx++) {
				this.#area.scores.default[areaIx] += buff[areaIx];
			}
		}
	}
	#initScore_forPlayers() {
		// each player has own score based on owned area
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			this.#area.scores.players[player] = [...this.#area.scores.default];
		}
	}
	#updateScore() {
		this.#updateScore_forPlayersCorner();
		this.#updateScore_forPlayersEdge();
	}
	#updateScore_forPlayersCorner() {
		for (const cornerIx of this.#conf.tagIndexes.cornerSet) {
			const owner = this.#getItemByIndex(cornerIx);
			if ((owner === cReversi.#empty) || (owner === cReversi.#dmz)) {
				continue;
			}
			const aroundArr = this.#aroundIndexes(cornerIx);
			const newScore = this.#area.scores.default[cornerIx];
			aroundArr.forEach(in_aroundIx => this.#area.scores.players[owner][in_aroundIx] = newScore);
		}
	}
	#updateScore_forPlayersEdge() {
		const tagIndexes = this.#conf.tagIndexes;
		tagIndexes.edgeSetArr.forEach(in_edgeSet => {
			for (const edgeIx of in_edgeSet) {
				const owner = this.#getItemByIndex(edgeIx);
				if ((owner === cReversi.#dmz) || (owner === cReversi.#empty)) {
					// edge is not owned
					continue;
				}
				const aroundArr = this.#aroundIndexes(edgeIx);
				aroundArr.forEach(in_aroundIx => {
					// edgeSetArr should be removed
					if (in_edgeSet.has(in_aroundIx)) {
						return;
					}
					// xInsideSet should be removed
					if (tagIndexes.xInsideSet.has(in_aroundIx)) {
						return;
					}
					for (let player = 0; player < cReversi.#maxPlayers; player++) {
						let update = this.#area.scores.default[in_aroundIx];
						if (player === owner) {
							update = this.#area.scores.default[edgeIx];
						}
						this.#area.scores.players[player][in_aroundIx] = update;
					}
				});
			}
		});
	}
	#createRollback() {
		const backup = {
			items : [...this.#area.items],
			options : [...this.#area.options],
			players : this.#area.scores.players.map(in_arr => [...in_arr]) 
		};
		return () => {
			const area = this.#area;
			area.items = [...backup.items];
			area.options = new Set(backup.options);
			area.scores.players = backup.players.map(in_arr => [...in_arr]);
		};
	}
	static #evaluateStats = {};
	#evaluate(in_player, in_ix) {
		const registerStats = in_key => {
			if (cReversi.#evaluateStats[in_key]) {
				cReversi.#evaluateStats[in_key]++;
			} else {
				cReversi.#evaluateStats[in_key] = 1;
			}
		};
		registerStats('total');
		const loop = !this.#conf.row.edge || !this.#conf.col.edge;
		/*
			1. e (= edge) : check if area of edge is safe
			2. x (= xInside) : check if xInside positions will be not changed
		*/
		const check = {
			e : {
				indexes : [],
				currItems : [],
				nextItems : [],
				currParsed : {},
				nextParsed : {}
			},
			x : {
				indexes : [],
				currItems : [],
				nextItems : [],
				increased : false
			}
		};
		const tagIndexes = this.#conf.tagIndexes;
		if (tagIndexes.cornerSet.has(in_ix)) {
			registerStats('corner');
			return +999;
		}
		const ixInEdge = tagIndexes.edgeSetArr.some(in_edgeSet => {
			if (in_edgeSet.has(in_ix)) {
				check.e.indexes = [...in_edgeSet];
				return true;
			} else {
				return false;
			}
		});
		if (loop) {
			if (!ixInEdge) {
				registerStats('inside & loop = without xInside');
				return 0;
			}
		} else {
			const riskCornerSet = new Set();
			for (const cornerIx of tagIndexes.cornerSet) {
				if (this.#getItemByIndex(cornerIx) === cReversi.#empty) {
					riskCornerSet.add(cornerIx);
				}
			}
			for (const xInsideIx of tagIndexes.xInsideSet) {
				const aroundArr = this.#aroundIndexes(xInsideIx);
				if (aroundArr.some(in_aroundIx => riskCornerSet.has(in_aroundIx))) {
					check.x.indexes.push(xInsideIx);
				}
			}
		}
		if (check.e.indexes.length > 0) {
			check.e.currItems = this.#items(check.e.indexes);
		}
		if (check.x.indexes.length > 0) {
			check.x.currItems = this.#items(check.x.indexes);
		}
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		if (check.e.indexes.length > 0) {
			check.e.nextItems = this.#items(check.e.indexes);
			check.e.currParsed = cLineParser.parse(check.e.currItems, in_player, loop);
			check.e.nextParsed = cLineParser.parse(check.e.nextItems, in_player, loop);
		}
		if (check.x.indexes.length > 0) {
			check.x.nextItems = this.#items(check.x.indexes);
			check.x.increased = !check.x.nextItems.every((in_item, in_ix) => in_item === check.x.currItems[in_ix]);
		}
		(rollback)();
		const priorityArr = [
			{format : 'eCriticalToMe', positive : false},
			{format : 'ePreRiskToMe', positive : false},
			{format : 'xInside', positive : false},
			{format : 'ePressureByMe', positive : true},
			{format : 'ePressureToMe', positive : false},
			{format : 'ePrePressureToMe', positive : false},
			{format : 'bFulfilledWith', positive : true},
			{format : 'bPressureByMe', positive : true},
			{format : 'bPressureToMe', positive : false},
			{format : 'bPrePressureToMe', positive : false},
			{format : 'bInnerByMe', positive : true},
			{format : 'bPreOuterByMe', positive : false},
			{format : 'safetyScore', positive : true},
			{format : 'bOuterByMe', positive : true}
		];
		const scale = 10;
		for (let i = 0; i < priorityArr.length; i++) {
			const {format, positive} = priorityArr[i];
			let score = ((priorityArr.length - i - 1) * scale + 1) * (positive ? +1 : -1);
			if (format === 'xInside') {
				// 1. special case (xInside)
				if (check.x.increased) {
					registerStats(format);
					return score;
				} else {
					continue;
				}
			}
			if (check.e.currParsed[format] === check.e.nextParsed[format]) {
				// 2. special case (bOuterByMe)
				if ((format === 'bOuterByMe') && (check.e.nextParsed[format])) {
					registerStats(format);
					return score;
				} else {
					continue;
				}
			} else {
				// 3. generic cases
				if (typeof check.e.nextParsed[format] === 'number') {
					const delta = check.e.nextParsed[format] - check.e.currParsed[format];
					registerStats(format);
					return (delta > 0) ? score * +1 : score * -1;
				} else {
					let statsKey;
					if (check.e.nextParsed[format]) {
						statsKey = format + '-false-to-true';
						score *= +1;
					} else {
						statsKey = format + '-true-to-false';
						score *= -1;
					}
					registerStats(statsKey);
					return score;
				}
			}
		}
		registerStats('can not evaluate');
		return 0;
	}
	#countNextEnemyOption(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const player = (in_player + 1 + cReversi.#maxPlayers) % cReversi.#maxPlayers;
		const count = this.#searchCandidates(player).length;
		(rollback)();
		return count;
	}
	#countNextOption(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const count = this.#searchCandidates(in_player).length;
		(rollback)();
		return count;
	}
	#countNextOwnedSafeArea(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		let count = 0;
		const findNeighbor = in_arr => {
			for (let i = 0; i < in_arr.length; i++) {
				const neighbor = this.#getItemByIndex(in_arr[i]);
				if (neighbor !== in_player) {
					return neighbor;
				}
			}
			return null;
		}
		const pairs = Array.from(this.#conf.dirStyle.pair.values());
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) !== in_player) {
				continue;
			}
			const radiating = this.#conf.tagIndexes.radiating[ix];
			const isSafe = pairs.every(([in_pos, in_neg])  => {
				const P = findNeighbor(radiating[in_pos]);
				const N = findNeighbor(radiating[in_neg]);
				// player reachs all the way to the board edge, or to the DMZ
				if ((P === null) || (P === cReversi.#dmz)) {
					return true;
				}
				if ((N === null) || (N === cReversi.#dmz)) {
					return true;
				}
				// both sides are bordered by the same object
				if (P === N) {
					return true;
				}
				return false;
			});
			count += isSafe ? 1 : 0;
		}
		(rollback)();
		return count;
	}
	#countNextOwnedArea(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		const count = this.#count(in_player);
		(rollback)();
		return count;
	}
	#calculateNextScore(in_player, in_ix) {
		const rollback = this.#createRollback();
		this.#flip(in_player, in_ix);
		let score = 0;
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			if (this.#getItemByIndex(ix) === in_player) {
				score += this.#getAreaScore(in_player, ix);
			}
		}
		(rollback)();
		return score;
	}
	static #randomizeCnt = 5;
	#npc_min_enemy_option(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextEnemyOption(in_player, in_ix) * -1;
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_option(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOption(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_owned_safe_area(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOwnedSafeArea(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_max_owned_area(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#countNextOwnedArea(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_score_spot(in_player, narrowedArr);
	}
	#npc_score_smart(in_player, in_candArr) {
		if (this.#history.length < cReversi.#randomizeCnt) {
			return this.#npc_random(in_player, in_candArr);
		}
		const evaluator = (in_player, in_ix) => {
			return this.#evaluate(in_player, in_ix) + this.#getAreaScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_score_total(in_player, in_candArr) {
		const evaluator = (in_player, in_ix) => {
			return this.#calculateNextScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_score_spot(in_player, in_candArr) {
		const evaluator = (in_player, in_ix) => {
			return this.#getAreaScore(in_player, in_ix);
		};
		const narrowedArr = cReversi.#maximize(evaluator, in_player, in_candArr);
		return this.#npc_random(in_player, narrowedArr);
	}
	#npc_random(in_player, in_candArr) {
		return in_candArr[arrRand]();
	}
	#npcSet = {
		safety : this.#npc_max_owned_safe_area,
		spiteful : this.#npc_min_enemy_option,
		balance : this.#npc_max_option,
		greedy : this.#npc_max_owned_area,
		learner : this.#npc_score_smart,
		classic : this.#npc_score_total,
		beginner : this.#npc_score_spot,
		monkey : this.#npc_random
	}
	_simulation(in_repeat = 17) {
		const truncateDecimal = (in_value, in_digit) => {
			const order = 10 ** in_digit;
			return Math.floor(in_value * order) / order;
		};
		const test = (in_argoArr) => {
			let cnt = 100;
			while (true) {
				const resultArr = [];
				for (let i = 0; i < in_argoArr.length; i++) {
					resultArr[i] = this.playAutomatically(i, in_argoArr[i]);
				}
				if (resultArr.some(in_result => in_result)) {
					if (cnt-- === 0) {
						break;
					}
				} else {
					break;
				}
				// this.dp();
			}
			let max = -Infinity;
			let winner = -1;
			const cond = this.getCurrentCondition();
			for (let i = 0; i < cond.players.length; i++) {
				if (cond.players[i].score > max) {
					max = cond.players[i].score;
					winner = i;
				}
			}
			return winner;
		};
		const rollback = this.#createRollback();
		// start simulation
		const table = [];
		table.push(['(vs)', ...Object.keys(this.#npcSet)]);
		Object.keys(this.#npcSet).forEach(p1 => {
			const row = [p1];
			Object.keys(this.#npcSet).forEach(p2 => {
				const players = [p1, p2];
				if (p1 === p2) {
					row.push('-');
					return;
				}
				let cnt = in_repeat;
				let win = 0;
				while (true) {
					if (cnt-- > 0) {
						if (test(players) === 0) {
							win++;
						}
						this.#initScore();
						this.#history.length = 0;
						(rollback)();
					} else {
						break;
					}
				}
				row.push(truncateDecimal(win / in_repeat, 2));
				this.#initScore();
				this.#history.length = 0;
				(rollback)();
			});
			table.push(row);
		});
		const elem = (in_table => {
			const ret = document.createElement('TABLE');
			in_table.forEach(in_row => {
				const row = document.createElement('TR');
				in_row.forEach(in_cell => {
					const cell = document.createElement('TD');
					cell.innerText = in_cell;
					let color = 'eeeeee';
					if (typeof in_cell === 'boolean') {
						if (in_cell) {
							color = 'ccccff';
						} else {
							color = 'ffcccc';
						}
					} else {
						if (typeof in_cell === 'number') {
							if (in_cell > 0.5) {
								color = 'ccccff';
							} else {
								color = 'ffcccc';
							}
						}
					}
					cell.style.backgroundColor = color;
					cell.style.textAlign = 'center';
					cell.style.border = '1px solid black';
					cell.style.padding = '3px';
					cell.style.width = '5em';
					row.appendChild(cell);
				});
				ret.appendChild(row);
			});
			ret.style.borderCollapse = 'collapse';
			return ret;
		})(table);
		const script = document.currentScript;
		script.parentNode.insertBefore(elem, script.nextSibling);
		let total = 1;
		Object.keys(cReversi.#evaluateStats).forEach(in_key => {
			if (in_key === 'total') {
				total = cReversi.#evaluateStats[in_key];
				return;
			}
			const taking = truncateDecimal(cReversi.#evaluateStats[in_key] / total, 4);
			console.log(in_key + ' : ' + taking);
		});
	}
	_snapshot() {
		const bg = new Map([
			[0, 'red'],
			[1, 'blue'],
			[2, 'green'],
			[3, 'yellow'],
			[cReversi.#empty, 'silver']
		]);
		const rightMargin = 10;
		const cellSize = 20;
		const cellMargin = 5;
		for (let row = 0; row < this.#conf.row.size; row++) {
			for (let col = 0; col < this.#conf.col.size; col++) {
				const color = bg.get(this.#getItemByPos(row, col));
				const id = '_' + row + 'x' + col;
				let cell = document.getElementById(id);
				if (cell) {
					cell.style.backgroundColor = color;
					continue;
				} else {
					cell = document.createElement('DIV');
				}
				let l = rightMargin + (cellSize + cellMargin) * col;
				let t = rightMargin + (cellSize + cellMargin) * row;
				const pair = this.#conf.dirStyle.pair;
				if (pair.has(90) && !pair.has(0)) {
					l += (row % 2 === this.#conf.offset ? (cellSize + cellMargin) / 2 : 0);
				}
				if (!pair.has(90) && pair.has(0)) {
					t += (col % 2 === this.#conf.offset ? (cellSize + cellMargin) / 2 : 0);
				}
				Object.assign(cell.style, {
					id : id,
					width : cellSize + 'px',
					height : cellSize + 'px',
					backgroundColor : color,
					border : 'solid gray 1px',
					position : 'absolute',
					left : l + 'px',
					top : t + 'px'
				});
				document.body.appendChild(cell);
			}
		}
	}
	_debug(in_stop = true) {
		const sources = {
			default : this.#area.scores.default,
			occupied : this.#area.items
		};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			sources['p-' + player] = this.#area.scores.players[player];
		}
		Object.keys(sources).forEach(in_key => {
			console.log('*** ' + in_key + ' ***');
			const data = sources[in_key];
			for (let row = 0; row < this.#conf.row.size; row++) {
				const items = [];
				for (let col = 0; col < this.#conf.col.size; col++) {
					const ix = this.#posToIndex(row, col);
					items.push(data[ix]);
				}
				console.log(items);
			}
		});
		if (in_stop) {
			throw new Error();
		}
	}
	playResetTable(in_player, in_action, in_table) {
		this.setTable(in_table);
		this.#history.push({
			who : in_player,
			action : in_action,
			row : -1,
			col : -1,
			delta : -1
		});
		this.#updateOptionsAll();
		this.#updateScore();
	}
	playSetPosition(in_player, in_row, in_col) {
		const ix = this.#posToIndex(in_row, in_col);
		if (this.#getItemByIndex(ix) !== cReversi.#empty) {
			return false;
		}
		const flipped = this.#flip(in_player, ix);
		if (flipped) {
			this.#history.push({
				who : in_player,
				action : 'choose-item',
				row : in_row,
				col : in_col,
				delta : -1
			});
		}
		return flipped;
	}
	playAutomatically(in_player, in_argo = null) {
		let npcAlive = false;
		let playerCnt = 0;
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			if (this.#area.items.indexOf(player) >= 0) {
				playerCnt++;
				if (player === in_player) {
					npcAlive = true;
				}
			}
		}
		if (npcAlive) {
			if (playerCnt === 1) {
				// only in_player
				return false;
			}
		} else {
			// in_player is died
			return false;
		}
		if (this.#area.items.indexOf(cReversi.#empty) === -1) {
			// fulfilled
			return false;
		}
		let npcArgo;
		if (in_argo) {
			npcArgo = in_argo;
		} else {
			npcArgo = this.#npcArgoPriority[in_player];
		}
		// console.log(in_player, npcAlive, playerCnt, npcArgo);
		const candidates = this.#searchCandidates(in_player);
		if (candidates.length > 0) {
			const ix = (this.#npcSet[npcArgo].bind(this))(in_player, candidates);
			this.#flip(in_player, ix);
			const pos = this.#indexToPos(ix);
			this.#history.push({
				who : in_player,
				action : 'choose-item',
				row : pos.row,
				col : pos.col,
				delta : -1
			});
			return true;
		} else {
			let action, result = null;
			if (!result && this.#conf.rotatable.fixedCol) {
				action = 'fixed-col-rotate';
				result = this.#tryRotation(in_player, action);
			}
			if (!result && this.#conf.rotatable.fixedRow) {
				action = 'fixed-row-rotate';
				result = this.#tryRotation(in_player, action);
			}
			if (result) {
				this.#history.push({
					who : in_player,
					action : action,
					row : (action === 'fixed-row-rotate' ? result.target : -1),
					col : (action === 'fixed-col-rotate' ? result.target : -1),
					delta : result.delta
				});
				this.#updateOptionsAll();
				this.#updateScore();
				return true;
			} else {
				// can not do anything
				return false;
			}
		}
	}
	rotatableFixedCol() {
		return this.#conf.rotatable.fixedCol;
	}
	rotatableFixedRol() {
		return this.#conf.rotatable.fixedRow;
	}
	getLast(in_conditions = {}) {
		// in_conditions : {who, action, row, col, delta}
		for (let i = this.#history.length - 1; i >= 0; i--) {
			const last = this.#history[i];
			if (Object.keys(in_conditions).some(in_key => in_conditions[in_key] !== last[in_key])) {
				continue;
			} else {
				return last;
			}
		}
		return null;
	}
	getTable() {
		const table = [];
		for (let ix = 0; ix < this.#area.items.length; ix++) {
			const pos = this.#indexToPos(ix);
			if (!table[pos.row]) {
				table[pos.row] = [];
			}
			table[pos.row][pos.col] = parseInt(this.#getItemByIndex(ix));
		}
		return table;
	}
	setTable(in_table) {
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const item = in_table[row][col];
				if (cReversi.#validData.indexOf(item) < 0) {
					throw new Error('invalid input');
				} else {
					this.#setItemByPos(row, col, item);
				}
			}
		}
	}
	getCurrentCondition() {
		const condition = {
			finished : false,
			players : []
		};
		const canRotate = this.#conf.rotatable.fixedCol || this.#conf.rotatable.fixedRow;
		const cnt = {
			activePlayer : 0,
			frozenPlayer : 0
		};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			let score, dead, frozen;
			score = this.#count(player);
			dead = (score === 0);
			if (dead) {
				frozen = true;
			} else {
				const candidates = (this.#searchCandidates(player)).length;
				if ((candidates > 0) || canRotate) {
					cnt.activePlayer++;
					frozen = false;
				} else {
					cnt.frozenPlayer++;
					frozen = true;
				}
			}
			condition.players[player] = {score : score, dead : dead, frozen : frozen};
		}
		condition.finished =
			// only 1 player is active
			(cnt.activePlayer + cnt.frozenPlayer === 1) ||
			// all players are frozen
			(cnt.activePlayer === 0) ||
			// there is no emply
			(this.#emptyCnt() === 0);
		return condition;
	}
}

/*
	the cTurnController class is designed to manage turns in turn-based games like reversi.
*/

class cTurnController {
	#players = new cCyclicValues();
	#active = false;
	#turns = 0;
	registerPlayer(in_turnHook, in_playerId = randomString()) {
		this.#players.push({
			turnHook : in_turnHook,
			playerId : in_playerId
		});
		return in_playerId;
	}
	#turnStart(in_player) {
		this.#turns++;
		in_player.turnHook(in_player.playerId);
	}
	turnEnd() {
		if (!this.#active) {
			return;
		}
		this.#turnStart(this.#players.incrementedValue());
	}
	gameStart() {
		this.#active = true;
		this.#turnStart(this.#players.currValue());
	}
	gameEnd() {
		this.#active = false;
	}
}

/*
	the cColony class related functions provide the ability to create cylinder-shaped threejs objects.
*/

const textureFactory = factoryBuilder((in_w, in_h, in_dmz = false) => {
	const gradationCnt = 4
	// gradationCnt (from black to white)
	const maxDepth = 255;
	const rgbArr = [];
	for (let i = 0; i < gradationCnt; i++) {
		const depth = Math.ceil(maxDepth / gradationCnt * (i + 1));
		rgbArr[i] = 'rgb(' + depth + ',' + depth + ',' + depth + ')';
	}
	// draw and convert using toDataUR
	const canvas = document.createElement('CANVAS');
	canvas.width = in_w;
	canvas.height = in_h;
	const ctx = canvas.getContext('2d');
	for (let i = 0; i < gradationCnt; i++) {
		if (in_dmz) {
			ctx.strokeStyle = rgbArr[gradationCnt - i - 1];
			ctx.fillStyle = rgbArr[gradationCnt - i - 1];
			if (i > 0) {
				ctx.lineWidth = (gradationCnt - i) * 2 - 1;
				ctx.beginPath();
				ctx.moveTo(0, 0);
				ctx.lineTo(in_w, in_h);
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo(in_w, 0);
				ctx.lineTo(0, in_h);
				ctx.stroke();
			} else {
				ctx.fillRect(0, 0, in_w, in_h);
			}
		} else {
			/*
				Rect           RoundRect      RoundRect

				##########     ##########     ##########
				##########     ##******##     ##******##
				##########     #********#     #**++++**#
				##########     #********#     #*++++++*#
				########## --> #********# --> #*++++++*# --> ...
				##########     #********#     #*++++++*#
				##########     #********#     #**++++**#
				##########     ##******##     ##******##
				##########     ##########     ##########
			*/
			const radius = gradationCnt + 2;
			ctx.fillStyle = rgbArr[i];
			if (i > 0) {
				ctx[fillRoundRect](i, i, in_w - i * 2, in_h - i * 2, radius - i);
			} else {
				ctx.fillRect(i, i, in_w - i * 2, in_h - i * 2);
			}
		}
	}
	return (new THREE.TextureLoader()).load(canvas.toDataURL());
});

const surfaceFactory = factoryBuilder((in_color, in_size, in_type) => {
	const material = new THREE.MeshLambertMaterial();
	material.color = new THREE.Color(in_color);
	switch (in_type) {
	case 'normal-texture' :
		material.map = textureFactory.create(in_size, in_size, false);
		break;
	case 'dmz-texture' :
		material.map = textureFactory.create(in_size, in_size, true);
		break;
	case 'no-texture' :
	default :
		break;
	}
	return material;
});

const SHELL_COLOR_INDEX = 2;

function shellMaterials(in_size, in_color_main, in_color_back, in_dmz) {
	const materials = [];
	for (let i = 0; i < Object.keys(DIRECTION).length; i++) {
		if (i === SHELL_COLOR_INDEX) {
			const texture = in_dmz ? 'dmz-texture' : 'normal-texture';
			materials.push(surfaceFactory.create(in_color_main, in_size, texture));
		} else {
			materials.push(surfaceFactory.create(in_color_back, in_size, 'no-texture'));
		}
	}
	return materials;
}

function getShellColor(in_object) {
	return in_object.material[SHELL_COLOR_INDEX].color.getHex();
}

function setShellColor(in_object, in_color) {
	const setting = in_object.geometry.parameters;
	return in_object.material[SHELL_COLOR_INDEX] = surfaceFactory.create(in_color, setting.size);
}

const shellGeometryFactory = factoryBuilder((in_size, in_innerRatio, in_thickness) => {
	const radian = 6;
	const outerLen = in_size - radian * 2;
	const innerLen = outerLen * in_innerRatio;
	const thickness = in_thickness - radian * 2;
	const geometry = trapezoidGeometryUtil(outerLen, outerLen, outerLen, innerLen, thickness, radian);
	geometry.parameters = {
		size : in_size,
		innerRatio : in_innerRatio,
		thickness : in_thickness
	};
	return geometry;
});

const GRAY1 = 0x222222;
const GRAY2 = 0x444444;
const GRAY3 = 0x666666;

const BGCOLOR = GRAY1;

const ORANGE = 0xFFAA00, O = ORANGE;
const RED = 0xFF0000, R = RED;
const WHITE = 0xFFFFFF, W = WHITE;
const YELLOW = 0xFFFF00, Y = YELLOW;
const BLUE = 0x3333FF, B = BLUE;
const GREEN = 0x118811, G = GREEN;
const SKYBLUE = 0x5588FF, S = SKYBLUE;
const LIME = 0x55CC55, L = LIME;
const DMZCOLOR = GRAY2, D = DMZCOLOR;
const EMPTYCOLOR = GRAY3, E = EMPTYCOLOR;

const edgeMaterial = new THREE.MeshLambertMaterial({color : BGCOLOR});

const COLONY_SIZE = 400;

const gColoredArgo = new Map([
	[RED, 'safety'],
	[YELLOW, 'spiteful'],
	[GREEN, 'greedy'],
	[ORANGE, 'balance'],
	[SKYBLUE, 'learner'],
	[LIME, 'classic']
]);

const BOARD_DB = [
	{
		type : 'traditional',
		desc : '2 players reversi using 8x8 square',
		levels : [
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,G,E,E,E],
					[E,E,E,G,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,G,B,E,E,E],
					[E,E,E,B,G,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,Y,E,E,E],
					[E,E,E,Y,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,Y,B,E,E,E],
					[E,E,E,B,Y,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			}
		]
	},
	{
		type : 'hexmap',
		desc : 'multiplayers reversi using hexmap',
		levels : [
			{
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[D,D,D,D,D,E,D,D,D,D,D],
					[D,D,D,E,E,E,E,E,D,D,D],
					[D,E,E,E,E,E,E,E,E,E,D],
					[E,E,E,E,E,B,E,E,E,E,E],
					[E,E,E,E,E,B,E,E,E,E,E],
					[E,E,E,B,G,E,G,G,E,E,E],
					[E,E,E,E,B,G,B,E,E,E,E],
					[E,E,E,E,E,G,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E,E],
					[D,D,E,E,E,E,E,E,E,D,D],
					[D,D,D,D,E,E,E,D,D,D,D],

					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[D,D,D,D,D,E,D,D,D,D,D],
					[D,D,D,E,E,E,E,E,D,D,D],
					[D,E,E,E,E,E,E,E,E,E,D],
					[E,E,E,E,E,B,E,E,E,E,E],
					[E,E,E,E,E,B,E,E,E,E,E],
					[E,E,E,B,Y,E,Y,Y,E,E,E],
					[E,E,E,E,B,Y,B,E,E,E,E],
					[E,E,E,E,E,Y,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E,E],
					[D,D,E,E,E,E,E,E,E,D,D],
					[D,D,D,D,E,E,E,D,D,D,D],

					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[D,D,D,D,D,E,D,D,D,D,D],
					[D,D,D,E,E,E,E,E,D,D,D],
					[D,E,E,E,E,E,E,E,E,E,D],
					[E,E,E,E,E,B,E,E,E,E,E],
					[E,E,E,E,E,B,E,E,E,E,E],
					[E,E,E,B,R,E,R,R,E,E,E],
					[E,E,E,E,B,R,B,E,E,E,E],
					[E,E,E,E,E,R,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E,E],
					[D,D,E,E,E,E,E,E,E,D,D],
					[D,D,D,D,E,E,E,D,D,D,D],

					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[D,D,D,D,D,E,D,D,D,D,D],
					[D,D,D,E,E,E,E,E,D,D,D],
					[D,E,E,E,E,E,E,E,E,E,D],
					[E,E,E,E,E,B,E,E,E,E,E],
					[E,E,E,S,Y,E,G,R,E,E,E],
					[E,E,E,R,E,B,E,O,E,E,E],
					[E,E,E,O,E,E,E,Y,E,E,E],
					[E,E,E,E,B,G,S,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E,E],
					[D,D,E,E,E,E,E,E,E,D,D],
					[D,D,D,D,E,E,E,D,D,D,D],

					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D]
				]
			}
		]
	},
	{
		type : 'variety',
		desc : 'variety rectangle formats using dmz',
		levels : [
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E],
					[E,E,R,R,B,E,E],
					[E,E,B,D,B,E,E],
					[E,E,B,R,R,E,E],
					[E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E],
					[E,E,R,G,Y,E,E],
					[E,E,Y,D,B,E,E],
					[E,E,B,R,G,E,E],
					[E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,E,E,E,E],
					[E,E,D,B,B,B,E,E],
					[E,E,R,R,R,D,E,E],
					[E,E,E,E,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,G,G,E,E,E],
					[E,E,R,D,D,B,E,E],
					[E,E,R,D,D,B,E,E],
					[E,E,E,Y,Y,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[D,D,D,D,D,E,E,E,E,E,E,E],
					[D,D,D,D,D,E,E,E,E,E,E,E],
					[D,D,D,D,D,E,E,B,E,E,E,E],
					[D,D,D,D,D,E,E,R,B,E,E,E],
					[D,D,D,D,D,E,E,B,R,B,E,E],
					[E,E,E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E,E,E],
					[E,E,R,B,R,E,E,D,D,D,D,D],
					[E,E,E,R,B,E,E,D,D,D,D,D],
					[E,E,E,E,R,E,E,D,D,D,D,D],
					[E,E,E,E,E,E,E,D,D,D,D,D],
					[E,E,E,E,E,E,E,D,D,D,D,D],

					[D,D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D,D,D]
				]
			},
		]
	},
	{
		type : 'loop',
		desc : 'reversi using looped board',
		levels : [
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				format : 'square',
				offsetCol : -1,
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,Y,G,E,E,E],
					[E,E,E,G,Y,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				format : 'hexFlatTopped',
				offsetCol : 1,
				table : [
					[E,E,E,B,Y,E,E,E],
					[E,E,E,R,G,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,Y,E,E,E],
					[E,E,E,R,G,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,Y,B,E,E,E],
					[E,E,E,G,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,Y,B,E,E,E],
					[E,E,E,G,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
		]
	}
];

let gTypeIsInvalid = false;

const gCyclicLevels = ((in_diameter) => {
	const values = new cCyclicValues();
	const shellInfo = (in_type => {
		const board = BOARD_DB.find(in_board => in_board.type === in_type);
		if (!board) {
			gTypeIsInvalid = true;
			const defaultIndex = 0;
			return BOARD_DB[defaultIndex].levels;
		} else {
			return board.levels;
		}
	})(getParam('type'));
	const uniqueNameSet = new Set();
	shellInfo.forEach(in_shell => {
		const radius = in_diameter / 2;
		const circumf = in_diameter * Math.PI;
		const rows = in_shell.table.length;
		const cols = Math.max(...in_shell.table.map(row => row.length));
		const unitSize = circumf / rows;
		const unitThick = unitSize * 0.3;
		const unitAngle = Math.PI * 2 / rows;
		const geometry = shellGeometryFactory.create(unitSize, ((radius - unitThick) / radius), unitThick);
		const pieces = [];
		/*
			create a cylinder oriented around the x-axis
				row : a position along the circumference of the cylinder
				col : a position along the height of the cylinder
		*/
		for (let row = 0; row < rows; row++) {
			for (let col = 0; col < cols; col++) {
				let x = unitSize * col - unitSize * (cols - 1) / 2;
				let y = (in_diameter / 2 - unitThick) * 1.2;
				const color = in_shell.table[row][col] ?? E;
				const materials = shellMaterials(unitSize, color, BGCOLOR, (color === D));
				materials.push(edgeMaterial);
				const piece = new THREE.Mesh(geometry, materials);
				const pivot = new THREE.Object3D();
				pivot.add(piece);
				piece.position.copy(VEC3(x, y, 0));
				if ((in_shell.format === 'hexFlatTopped') && (col % 2 === in_shell.offsetCol)) {
					pivot.rotateX(unitAngle * (row + 0.5));
				} else {
					pivot.rotateX(unitAngle * row);
				}
				/*
					*** NOTE ***
					you can use matrix,
					to apply rotated position before adding to scene
				*/
				pivot.updateMatrixWorld();
				piece.applyMatrix4(pivot.matrix);
				pivot.remove(piece);
				pieces.push(piece);
			}
		}
		const colorSet = new Set(in_shell.table.flat());
		colorSet.delete(D);
		colorSet.delete(E);
		const emptyCnt = in_shell.table.flat().filter(in_color => in_color === E).length;
		let name = 'vs ';
		if (colorSet.size > 2) {
			name += (colorSet.size - 1) + 'NPC';
		} else {
			let argo;
			for (const color of colorSet) {
				if (color !== B) {
					argo = gColoredArgo.get(color);
				}
			}
			name += argo.charAt(0).toUpperCase() + argo.slice(1);
		}
		name += ' (' + emptyCnt + ')';
		if (uniqueNameSet.has(name)) {
			name += ' mirrored';
		}
		uniqueNameSet.add(name);
		const dmzRow = in_shell.table.some(in_row => in_row.every(in_color => in_color === D));
		values.push({
			name : name,
			loop : !dmzRow,
			format : in_shell.format,
			offset : in_shell.offsetCol,
			colorArr : Array.from(colorSet),
			pieces : pieces
		});
	});
	return values;
})(COLONY_SIZE);

/*
	the cBoard is designed to represent a reversi board.
*/

class cColonyBoard extends cColony {
	#makeRotationX(in_rad) {
		return this.settingVal.origin.clone().applyMatrix4((new THREE.Matrix4()).makeRotationX(in_rad));
	}
	setupAllPieces(in_pieces, in_offsetCol = -1) {
		super.setupAllPieces(in_pieces);
		this.settingVal.offset = in_offsetCol;
		if (this.settingVal.offset >= 0) {
			this.settingVal.offset %= 2;
		}
	}
	indexToPiece(in_row, in_col) {
		let row = in_row;
		if ((this.settingVal.offset >= 0) && (in_col % 2 === this.settingVal.offset)) {
			row += 0.5;
		}
		const vec3 = this.#makeRotationX(this.settingVal.unitAngle * row);
		vec3.x += this.settingVal.unitDelta * in_col;
		const piece = this.children.find(in_child => XYZ.every(in_xyz => Math.abs(in_child.position[in_xyz] - vec3[in_xyz]) < cColony.error));
		if (!piece) {
			console.log('indexToPiece failed : ', in_row, in_col);
			throw new Error('');
		}
		return piece;
	}
	pieceToIndex(in_piece) {
		const pos = in_piece.position;
		const col = Math.round((pos.x - this.settingVal.origin.x) / this.settingVal.unitDelta);
		let offset = 0;
		if ((this.settingVal.offset >= 0) && (col % 2 === this.settingVal.offset)) {
			offset = 0.5;
		}
		for (let row = 0; row < this.settingVal.rowsForCircle; row++) {
			const vec3 = this.#makeRotationX(this.settingVal.unitAngle * (row + offset));
			if ((Math.abs(pos.y - vec3.y) < cColony.error) && (Math.abs(pos.z - vec3.z) < cColony.error)) {
				return {row : row, col : col};
			}
		}
		throw new Error('pieceToIndex failed');
	}
	getColorTable() {
		const table = [];
		for (let row = 0; row < this.settingVal.rowsForCircle; row++) {
			table[row] = [];
			for (let col = 0; col < this.settingVal.colsForLength; col++) {
				const piece = this.indexToPiece(row, col);
				table[row].push(getShellColor(piece));
			}
		}
		return table;
	}
	changedPieces(in_table) {
		const changedArr = [];
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const piece = this.indexToPiece(row, col);
				const currColor = getShellColor(piece);
				const nextColor = in_table[row][col];
				if (currColor !== nextColor) {
					changedArr.push({
						piece : piece,
						curr : currColor,
						next : nextColor
					});
				}
			}
		}
		return changedArr;
	}
	makeRotateProgress(in_col, in_delta, in_ending_callback) {
		this.uiDisable();
		const last = this.settingVal.unitAngle * in_delta;
		const x = this.settingVal.origin.x + this.settingVal.unitDelta * in_col;
		const pieces = this.children.filter(in_child => Math.abs(in_child.position.x - x) < cColony.error);
		const group = this.setupGroup(pieces);
		return this.makeAnimationProgress(group, cColony.axes.x, 0, last, in_ratio => {
			if (in_ratio < 1) {
				return;
			}
			this.uiEnable();
			(in_ending_callback)();
		});
	}
}

/*
	gWorld (cSphericalWorld)
		|
		+-- gColony (cColonyBoard)
			|
			+-- gColony.children <--- gCyclicLevels[n].pieces

	gController (cGameController) : knows the internal structure of the following instances
		|
		+-- gReversi (cReversi) : used for npc algorithm
		|
		+-- gColony : used for user interface
		|
		+-- gWorld : used for animation
*/

const gColony = new cColonyBoard();

const WORLD_RADIUS = COLONY_SIZE * 10;
const WORLD_INIT_ZOOM = WORLD_RADIUS / 2;

const gWorld = new cSphericalWorld(WORLD_RADIUS);
gWorld.add(gColony);
gWorld.moveView(0.5, 0.5);
gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);

let gController = null;
let gReversi = null;

class cGameController {
	static #UNUSED = -1;
	#mapping;
	#turnHook = () => {};
	#curIndex = 0;
	#pcColor;
	enableHandler = false;
	// cGameController knows the internal structure of cColonyBoard, cReversi and cSphericalWorld
	constructor(in_colorArr, in_pcColor) {
		this.#pcColor = in_pcColor;
		this.#mapping = new Array(10).fill(cGameController.#UNUSED);
		for (let i = 0; i < in_colorArr.length; i++) {
			this.#mapping[i] = in_colorArr[i];
		}
		// 8, 9 are declared as follows in cReversi
		this.#mapping[8] = DMZCOLOR;
		this.#mapping[9] = EMPTYCOLOR;
	}
	curNPCStrategy() {
		return gColoredArgo.get(this.#mapping[this.#curIndex]);
	}
	setTurnHook(in_hook) {
		this.#turnHook = in_hook;
	}
	#execTurnHook() {
		const color = this.#mapping[this.#curIndex];
		this.enableHandler = (color === this.#pcColor);
		(this.#turnHook)(this.#curIndex, color, this.enableHandler);
	}
	#incrementIndex() {
		this.#curIndex++;
		if (this.#mapping[this.#curIndex] === cGameController.#UNUSED) {
			this.#curIndex = 0;
		}
	}
	endTurn(in_reversi = null) {
		this.#incrementIndex();
		const cond = in_reversi.getCurrentCondition();
		if (cond.finished) {
			// all players can not do anything
			const winner = cond.players.reduce((in_accum, in_curVal, in_curIndex, in_arr) => {
				return in_curVal.score > in_arr[in_accum].score ? in_curIndex : in_accum;
			}, 0);
			return this.#mapping[winner];
		} else {
			while (true) {
				const {dead, frozen, score} = cond.players[this.#curIndex];
				if (dead || (frozen && !in_reversi.rotatableFixedCol())) {
					// curIndex can not do anything
					this.#incrementIndex();
				} else {
					break;
				}
			}
			// to prevent stack overflow
			setTimeout(() => this.#execTurnHook(), 0);
			// in this context, no winner
			return -1;
		}
	}
	start() {
		this.#execTurnHook();
	}
	end() {
		this.setTurnHook(() => {});
		this.#mapping.fill(cGameController.#UNUSED);
	}
	static #update(in_changedArr) {
		in_changedArr.forEach(in_changed => {
			setShellColor(in_changed.piece, in_changed.next);
		});
	}
	static #updateDynamic(in_changedArr, in_world) {
		// in_changedArr : see cColonyBoard.changedPieces()
		in_changedArr.forEach(in_changed => {
			// backup initial value
			in_changed.initRotationX = in_changed.piece.rotation.x;
		});
		const ease = new cEase(0, Math.PI * 2, 500);
		return new Promise(in_resolved => {
			let updated = false;
			const hook = () => {
				const angle = ease.currentEasingOut();
				if (angle === Math.PI * 2) {
					in_world.removeAnimationHook(hook);
					in_changedArr.forEach(in_changed => {
						// restore initial value
						in_changed.piece.rotation.x = in_changed.initRotationX;
					});
					/*
						execute the process that follows the await (or callback defined in then),
						which corresponds to the then block of a promise
					*/
					(in_resolved)();
					return;
				}
				if ((angle > Math.PI) && (!updated)) {
					SE_MOVED.play();
					cGameController.#update(in_changedArr);
					updated = true;
				}
				in_changedArr.forEach(in_changed => {
					in_changed.piece.rotation.x = in_changed.initRotationX + angle;
				});
			};
			in_world.addAnimationHook(hook);
		});
	}
	#makeChangedArr(in_reversi, in_colony) {
		const indexTable = in_reversi.getTable();
		const colorTable = indexTable.map(in_row => in_row.map(in_cell => this.#mapping[in_cell]));
		// this can handle smaller table than colony
		return in_colony.changedPieces(colorTable);
	}
	reversiToColony(in_reversi, in_colony) {
		const changedArr = this.#makeChangedArr(in_reversi, in_colony);
		cGameController.#update(changedArr);
	}
	async reversiToColonyDynamic(in_reversi, in_colony, in_world) {
		const changedArr = this.#makeChangedArr(in_reversi, in_colony);
		await cGameController.#updateDynamic(changedArr, in_world);
	}
	convertColonyTable(in_colony) {
		const reverse = {};
		this.#mapping.forEach((in_value, in_ix) => {
			reverse[in_value] = in_ix;
		});
		let table = in_colony.getColorTable();
		return table.map(in_row => in_row.map(in_cell => reverse[in_cell]));
	}
	async moveViewTo(in_piece, in_world) {
		const cameraPos = in_world.getCameraPos();
		const angleX = Math.atan2(cameraPos.y, cameraPos.z) - Math.atan2(in_piece.position.y, in_piece.position.z);
		const vec3 = cameraPos.applyMatrix4((new THREE.Matrix4()).makeRotationX(angleX));
		await in_world.motionViewFrom(vec3, 500);
	}
	async #playLastAction(in_reversi, in_colony, in_world) {
		const last = in_reversi.getLast();
		switch (last.action) {
		case 'choose-item' :
			const piece = in_colony.indexToPiece(last.row, last.col);
			await this.moveViewTo(piece, in_world);
			// choose
			setShellColor(piece, this.#mapping[last.who]);
			await this.reversiToColonyDynamic(in_reversi, in_colony, in_world);
			break;
		case 'fixed-col-rotate' :
			console.log('rotating', last);
			await (async ()=> {
				return new Promise(in_resolve => {
					const hook = in_colony.makeRotateProgress(last.col, last.delta, () => {
						in_world.removeAnimationHook(hook);
						(in_resolve)();
					});
					in_world.addAnimationHook(hook);
				});
			})();
			break;
		default :
			break;
		}
	}
	async npc(in_reversi, in_colony, in_world) {
		if (in_reversi.playAutomatically(this.#curIndex, this.curNPCStrategy())) {
			await this.#playLastAction(in_reversi, in_colony, in_world);
			return true;
		} else {
			// can't do anything
			return false;
		}
	}
	async pcChoose(in_piece, in_reversi, in_colony, in_world) {
		const resume = this.enableHandler;
		this.enableHandler = false;
		const pos = in_colony.pieceToIndex(in_piece);
		const result = in_reversi.playSetPosition(this.#curIndex, pos.row, pos.col);
		if (result) {
			SE_BEEP.play();
			await this.#playLastAction(in_reversi, in_colony, in_world);
		}
		this.enableHandler = resume;
		return result;
	}
	pcRotate(in_reversi, in_colony) {
		const table = this.convertColonyTable(in_colony);
		in_reversi.playResetTable(this.#curIndex, 'fixed-col-rotate', table);
	}
}

class cWarpLine {
	static #speed = 10;
	static #gradation = 10;
	constructor(in_canvas) {
		const w = in_canvas.width;
		const h = in_canvas.height;
		this.ctx = in_canvas.getContext('2d');
		this.box = new THREE.Box2(
			new THREE.Vector2(0, 0),
			new THREE.Vector2(w, h)
		);
		this.from = new THREE.Vector2(w / 2, h / 2);
		this.#reset();
	}
	#reset() {
		const angle = Math.random() * Math.PI * 2;
		this.direction = new THREE.Vector2(Math.cos(angle), Math.sin(angle));
		this.speed = Math.random() * cWarpLine.#speed + 5;
		this.length = 0;
	}
	#curVec(in_scalar) {
		return this.from.clone().add(this.direction.clone().multiplyScalar(in_scalar));
	}
	#drawGrayLine(in_from, in_to, in_grayScale) {
		const gray = (in_grayScale << 16) | (in_grayScale << 8) | in_grayScale;
		this.ctx.strokeStyle = '#' + gray.toString(16).padStart(6, '0');
		this.ctx.beginPath();
		this.ctx.moveTo(in_from.x, in_from.y);
		this.ctx.lineTo(in_to.x, in_to.y);
		this.ctx.stroke();
	}
	update() {
		this.length += this.speed;
		const to = this.#curVec(this.length);
		if (this.box.containsPoint(to)) {
			const notch = this.length / cWarpLine.#gradation;
			for (let i = 0; i < cWarpLine.#gradation; i++) {
				this.#drawGrayLine(
					this.#curVec(notch * i),
					this.#curVec(notch * (i + 1)),
					255 / cWarpLine.#gradation * (i + 1)
				);
			}
		} else {
			/*
				*** NOTE ***
				even if overwritung using black,
				this.#drawGrayLine(this.from, to, 0x00);
				smudge of white line will remain.
			*/
			this.#reset();
		}
	}
}

function warpViewProgress(in_canvas, in_lineCount) {
	const warpLines = [];
	for (let i = 0; i < in_lineCount; i++) {
		warpLines.push(new cWarpLine(in_canvas));
	}
	return () => {
		warpLines.forEach(in_line => {
			in_line.update();
		});
	}
}

function complete(in_player) {
	gController.end();
	gFigure.hide();
	const progress = warpViewProgress(gBackgroundCanvas, 50);
	gWorld.addAnimationHook(progress);
	const duration = 2000;
	gWorld.motionZoom2(WORLD_RADIUS * 1.5, duration * 0.9);
	setTimeout(() => {
		gWorld.removeAnimationHook(progress);
		const dialog = document.createElement('div');
		Object.assign(dialog.style, {
			width : 'auto',
			height : 'auto',
			color : 'white',
			background : 'black',
			borderRadius : '1em',
			padding : '1.5em'
		});
		([
			'<div>Winner is ...</div>',
			'<div style="text-align:center"><img src="' + RES.get(in_player) + '" /></div>',
			'<div>Thanks to your wisdom, peace in the universe has been preserved.</div>',
			'<div>Click to go next stage.</div>',
		]).forEach(in_fragment => {
			dialog.innerHTML += in_fragment;
		});
		startDialog(dialog, async () => {
			drawCosmicView(gBackgroundCanvas, 400, 50);
			await nextLevel(false);
			gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);
		});
	}, duration);
}

const gFigure = (() => {
	const maxInt = 2 ** 31 - 1;
	const closure = {};
	closure.outer = document.createElement('DIV');
	Object.assign(closure.outer.style, {
		position : 'absolute',
		bottom : '20px',
		right : '20px',
		textAlign : 'center',
		zIndex : maxInt
	});
	closure.image = document.createElement('IMG');
	Object.assign(closure.image.style, {
		width : '100px',
		height : 'auto',
		display : 'block',
		margin : '0 auto'
	});
	closure.outer.appendChild(closure.image);
	closure.label = document.createElement('SPAN');
	Object.assign(closure.label.style, {
		display : 'inline-block',
		marginTop : '6px',
		fontFamily : 'cursive',
		color : 'silver'
	});
	closure.outer.appendChild(closure.label);
	document.body.appendChild(closure.outer);
	return {
		show(in_src, in_text) {
			closure.outer.style.visibility = 'visible';
			closure.image.src = in_src;
			closure.label.textContent = in_text;
		},
		hide() {
			closure.outer.style.visibility = 'hidden';
		}
	};
})();

const PC_COLOR = BLUE;

function menu() {
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += "<div>information :</div>\n<br />\n";
	let no = 1;
	BOARD_DB.forEach(in_board => {
		const url = location.pathname + "?type=" + in_board.type;
		dialog.innerHTML += "<div>" + (no++) + ". <a href='" + url + "'>" + in_board.type + "</a></div>\n";
		dialog.innerHTML += "<div style='margin-left:1em;'>" + in_board.desc + "</div>\n";
	});
	dialog.innerHTML += "</ul>\n";
	startDialog(dialog);
}

function initializeByLevel() {
	const curr = gCyclicLevels.currValue();
	const edge = {
		row : !(curr.loop),
		col : true
	};
	gController = new cGameController(curr.colorArr, PC_COLOR);
	const pcIndex = curr.colorArr.indexOf(PC_COLOR);
	const table = gController.convertColonyTable(gColony);
	if (curr.offset >= 0) {
		gReversi = new cReversi(table, edge.row, edge.col, curr.format, curr.offset);
	} else {
		gReversi = new cReversi(table, edge.row, edge.col, curr.format);
	}
	gController.setTurnHook(async (in_player, in_color, in_pc) => {
		const name = gController.curNPCStrategy() ?? 'you';
		gFigure.show(RES.get(in_color), name);
		if (in_pc) {
			const last = gReversi.getLast({who : pcIndex, action : 'choose-item'});
			if (last) {
				const piece = gColony.indexToPiece(last.row, last.col);
				await gController.moveViewTo(piece, gWorld);
			}
			return;
		}
		await gController.npc(gReversi, gColony, gWorld);
		const winner = gController.endTurn(gReversi);
		if (winner < 0) {
			return;
		}
		complete(winner);
	});
	gController.reversiToColony(gReversi, gColony);
	gController.start();
	if (gTypeIsInvalid) {
		menu();
		gTypeIsInvalid = false;
	}
}

(in_level => {
	if (typeof in_level === 'number') {
		gCyclicLevels.setCurrentIndex(in_level);
	}
})(getParam('level'));

const ID_PREV_LEVEL = randomString();
const ID_NEXT_LEVEL = randomString();

async function updateLevel(in_curr) {
	const color = 0x000000;
	await gWorld.motionFog(color, 0, 100);
	gColony.removePieces();
	if (in_curr.offset >= 0) {
		gColony.setupAllPieces(in_curr.pieces, in_curr.offset);
	} else {
		gColony.setupAllPieces(in_curr.pieces);
	}
	await gWorld.motionFog(color, 100, 0);
	const prev = gCyclicLevels.prevValue();
	const next = gCyclicLevels.nextValue();
	document.getElementById(ID_PREV_LEVEL).innerText = prev.name;
	document.getElementById(ID_NEXT_LEVEL).innerText = next.name;
	resetFocus();
	initializeByLevel();
}

updateLevel(gCyclicLevels.currValue());

/*
	*** NOTE ***
	in Safari, using await to get audio will cause the process to fail.
	I'm not sure of the reason, but top-level await might be the cause.
	this time use then() to avoid the issue.
*/

let SE_BEEP = beep(2000);
let SE_DUMMY = beep(10);
let SE_MOVED = SE_BEEP;
let SE_ERROR = SE_BEEP;

SOUND.MOVED.then(in_decompress => {
	SE_MOVED = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

SOUND.ERROR.then(in_decompress => {
	SE_ERROR = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

function uiHelp() {
	const url = {
		ver : './version.txt',
		img : './side-six-reversi-help.gif',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div><img src="' + url.img + '" /></div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getResource(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.error(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		color : 'white',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Rights</dt>',
		'<dd>This software is based on MIT License.</dd>',
		'<dd>The code can be freely modified and reused.</dd>',
		'<dd>For full license details, please refer to :</dd>',
		'<dd>https://opensource.org/licenses/MIT</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	startDialog(dialog);
}

async function prevLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	await updateLevel(gCyclicLevels.decrementedValue());
}

async function nextLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	await updateLevel(gCyclicLevels.incrementedValue());
}

(in_settings => {
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	in_settings.forEach(in_setting => {
		let button = document.createElement('button');
		if (in_setting.id) {
			button.id = in_setting.id;
		}
		if (in_setting.text) {
			button.innerText = in_setting.text;
		}
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})([
	{
		id : ID_PREV_LEVEL,
		text : '(Prev)',
		func : prevLevel
	},
	{
		id : ID_NEXT_LEVEL,
		text : '(Next)',
		func : nextLevel
	},
	{
		text : 'help',
		func : uiHelp
	},
	{
		text : 'rights',
		func : uiRights
	}
]);

function hex2rgb(in_hex) {
	const mask = 0xFF;
	const r = (in_hex >> 16) & mask;
	const g = (in_hex >> 8) & mask;
	const b = in_hex & mask;
	return [r, g, b];
}

function drawCosmicView(in_canvas, in_stars, in_nebulae_patterns, in_color = 0x000064) {
	const ctx = in_canvas.getContext('2d');
	const w = in_canvas.width;
	const h = in_canvas.height;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	for (let i = 0; i < in_nebulae_patterns; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 100 + 50;
		const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
		const rgb = hex2rgb(in_color);
		gradient.addColorStop(0, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0.5)');
		gradient.addColorStop(1, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0)');
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = gradient;
		ctx.fill();
	}
	for (let i = 0; i < in_stars; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 1;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = 'white';
		ctx.fill();
	}
}

/*
	event handlers
*/

function drawBackground(in_canvas) {
	Object.assign(in_canvas.style, {
		position : 'absolute',
		left : 0,
		top : 0,
		zIndex : -1
	});
	drawCosmicView(in_canvas, 400, 50);
}

const gBackgroundCanvas = document.createElement('CANVAS');

function setupBody(in_document) {
	if (!in_document.body) {
		in_document.documentElement.appendChild(in_document.createElement('BODY'));
	}
	Object.assign(in_document.body.style, {
		margin : '0',
		overflow : 'hidden'
	});
}

function createChildWindow(in_document) {
	return new Promise(in_callback => {
		setupBody(in_document);
		const iframe = in_document.createElement('iframe');
		in_document.body.appendChild(iframe);
		Object.assign(iframe.style, {
			width: '100%',
			height: '100%',
			border: 'none'
		});
		/*
			*** NOTE ***
			although Chrome can use iframe.contentDocument right after createElement,
			Firefox can not use it ant needs to use asynchronous process.
			by the way, if you use not timer but load event,
			your code will not work for Chrome.
		*/
		setTimeout(() => {
			setupBody(iframe.contentDocument);
			(in_callback)(iframe.contentWindow);
		}, 0);
	});
}

document.addEventListener('DOMContentLoaded', (async () => {
	/*
		*** NOTE ***
		without iframe (outer window),
		geometry in event will be wrong because of google ads
	*/
	const outer = await createChildWindow(document);
	let resizeWorld = in_ev => {
		gWorld.resize(outer.innerWidth, outer.innerHeight);
		gBackgroundCanvas.width = outer.innerWidth;
		gBackgroundCanvas.height = outer.innerHeight;
		drawBackground(gBackgroundCanvas);
	};
	outer.addEventListener('resize', debouncing(resizeWorld, 300));
	outer.dispatchEvent(new Event('resize'));
	outer.document.body.appendChild(gWorld.canvas);
	outer.document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

const knock = nonReentrantAsync(async () => {
	SE_ERROR.play();
	await gWorld.motionKnock();
});

const notifyDelta = (() => {
	const RC = cColony.uiSetDeltaPositionRC;
	return in_ndc => {
		const intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			return;
		}
		const result = gColony.uiNotifyDeltaPosition(intersects[0].object, intersects[0].point, ndcToAbs(in_ndc));
		if (result === RC.UNMOVABLE) {
			knock();
		}
	}
})();

const focusHere = (() => {
	let focusedEmpty = null;
	const HIGHLIGHT = (new THREE.Color(EMPTYCOLOR)).lerp(new THREE.Color(0xFFFFFF), 0.3).getHex();
	return in_ndc => {
		let current, color;
		let intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length > 0) {
			current = intersects[0].object;
			color = getShellColor(current);
		} else {
			current = null;
			color = -1;
		}
		if ((color === EMPTYCOLOR) || (color === HIGHLIGHT)) {
			if (current === focusedEmpty) {
				return;
			}
			setShellColor(current, HIGHLIGHT);
			if (focusedEmpty) {
				setShellColor(focusedEmpty, EMPTYCOLOR);
			}
			focusedEmpty = current;
		} else {
			if (focusedEmpty) {
				setShellColor(focusedEmpty, EMPTYCOLOR);
			}
			focusedEmpty = null;
		}
	}
})();

function resetFocus() {
	const outOfRange = new THREE.Vector2(Infinity, Infinity);
	focusHere(outOfRange);
}

function rotateDone() {
	resetFocus();
	gController.pcRotate(gReversi, gColony);
	gController.endTurn(gReversi);
}

async function chooseHere(in_ev) {
	const ndc = ndcFromEvent(in_ev);
	let intersects = gWorld.intersectPositive(ndc);
	if (intersects.length === 0) {
		return;
	}
	resetFocus();
	const curr = intersects[0].object;
	if (getShellColor(curr) !== EMPTYCOLOR) {
		knock();
	} else {
		if (await gController.pcChoose(curr, gReversi, gColony, gWorld)) {
			const winner = gController.endTurn(gReversi);
			if (winner < 0) {
				return;
			}
			complete(winner);
		} else {
			knock();
		}
	}
}

(() => {
	const closure = {
		x : -1,
		y : -1,
		once : false
	};
	const start = in_ev => {
		if (!closure.once) {
			/*
				*** NOTE ***
				Safari may restrict sound without user interaction.
				because of this, the sound does not work without this code.
			*/
			SE_DUMMY.play();
			closure.once = true;
		}
		const ndc = ndcFromEvent(in_ev);
		const intersects = gWorld.intersectPositive(ndc);
		if (intersects.length === 0) {
			return;
		}
		resetFocus();
		closure.x = in_ev.clientX;
		closure.y = in_ev.clientY;
		// can drag only PC_COLOR
		const drag = intersects[0].object
		if (gReversi.rotatableFixedCol() && (getShellColor(drag) === PC_COLOR)) {
			gColony.uiSetInitPosition(intersects[0].point, ndcToAbs(ndc));
		}
	};
	const move = thresholding(in_ev => {
		closure.x = -1;
		closure.y = -1;
		const ndc = ndcFromEvent(in_ev);
		if (gColony.uiIsMoving()) {
			if (gColony.uiUpdatePosition(ndcToAbs(ndc))) {
				SE_MOVED.play();
			}
		} else {
			if (gColony.uiIsDragging()) {
				notifyDelta(ndc);
			} else {
				if (!in_ev[isEmulated]) {
					focusHere(ndc);
				}
			}
		}
	});
	const stop = in_ev => {
		const releaseProgress = gColony.uiRelease(in_changed => {
			gWorld.removeAnimationHook(releaseProgress);
			if (in_changed) {
				rotateDone();
			}
		});
		if (releaseProgress) {
			gWorld.addAnimationHook(releaseProgress);
		} else {
			if ((closure.x !== in_ev.clientX) || (closure.y !== in_ev.clientY)) {
				return;
			}
			chooseHere(in_ev);
		}
	};
	let handlers = {
		'mousedown' : start,
		'mousemove' : move,
		'mouseleave' : stop,
		'mouseout' : stop,
		'mouseup' : stop
	};
	for (let [eventName, closure] of Object.entries(handlers)) {
		gWorld.canvas.addEventListener(eventName, in_ev => {
			if (gController && gController.enableHandler) {
				(closure.bind(this))(in_ev);
			}
		});
	}
})();

</script>
</body>
</html>
