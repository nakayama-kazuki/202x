<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports" : {
		"three" : "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.min.js",
		"utils" : "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/utils/BufferGeometryUtils.js",
		"basic" : "./basic-functions.js",
		"sound" : "./sound-effect.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';
import {
	getVersion,
	getParam,
	DEBUG,
	randomString,
	snapToNotch,
	snapToPI,
	snapTo05PI,
	createPeriodicSin,
	createPeriodicCos,
	pseudoMessageDigest1,
	pseudoMessageDigest2,
	beep,
	isEmulated,
	throttling,
	thresholding,
	debouncing,
	nonReentrantAsync,
	factoryBuilder,
	arrRand,
	cEase,
	cApproximateMap,
	cApproximateSet,
	cCyclicMap,
	cCyclicValues,
	forEachCombination,
	clipArea,
	clipClearArea,
	fillRoundRect,
	XYZ,
	VEC3,
	DIRECTION,
	ndcFromEvent,
	ndcToAbs,
	getWorldVec3,
	getWorldUp,
	instanceInAncestor,
	lookAtWithoutRotation,
	safeMergeGeometry,
	makeTrapezoidGeometryParts,
	trapezoidGeometryUtil,
	roundBoxGeometry,
	roundRegularBoxGeometry,
	roundTrapezoidGeometry,
	capsuleConfigure,
	customCapsuleGeometry,
	cSphericalWorld
} from 'basic';
import * as SOUND from 'sound';

/*
	(1) Texture, MeshLambertMaterial, and BoxGeometry using cCache, which returns the same object in cache without creating.
*/

const textureFactory = factoryBuilder((in_w, in_h) => {
	const gradation = 4
	// gradation (from black to white)
	let maxDepth = 255;
	let styles = [];
	for (let i = 0; i < gradation; i++) {
		let depth = Math.ceil(maxDepth / gradation * (i + 1));
		styles[i] = 'rgb(' + depth + ',' + depth + ',' + depth + ')';
	}
	// draw and convert using toDataUR
	let canvas = document.createElement('CANVAS');
	canvas.width = in_w;
	canvas.height = in_h;
	const ctx = canvas.getContext('2d');
	let radius = gradation + 2;
	/*
		Rect           RoundRect      RoundRect

		##########     ##########     ##########
		##########     ##******##     ##******##
		##########     #********#     #**++++**#
		##########     #********#     #*++++++*#
		########## --> #********# --> #*++++++*# --> ...
		##########     #********#     #*++++++*#
		##########     #********#     #**++++**#
		##########     ##******##     ##******##
		##########     ##########     ##########
	*/
	for (let i = 0; i < gradation; i++) {
		ctx.fillStyle = styles[i];
		if (i > 0) {
			ctx[fillRoundRect](i, i, in_w - i * 2, in_h - i * 2, radius - i);
		} else {
			ctx.fillRect(i, i, in_w - i * 2, in_h - i * 2);
		}
	}
	return (new THREE.TextureLoader()).load(canvas.toDataURL());
});

const surfaceFactory = factoryBuilder((in_color, in_size = -1) => {
	const material = new THREE.MeshLambertMaterial();
	material.color = new THREE.Color(in_color);
	if (in_size > 0) {
		material.map = textureFactory.create(in_size, in_size);
	}
	return material;
});

const SHELL_COLOR_INDEX = 2;

function shellMaterials(in_size, in_color_main, in_color_back) {
	const materials = [];
	for (let i = 0; i < Object.keys(DIRECTION).length; i++) {
		if (i === SHELL_COLOR_INDEX) {
			materials.push(surfaceFactory.create(in_color_main, in_size));
		} else {
			materials.push(surfaceFactory.create(in_color_back));
		}
	}
	return materials;
}

function getShellColor(in_object) {
	return in_object.material[SHELL_COLOR_INDEX].color.getHex();
}

function setShellColor(in_object, in_color) {
	const setting = in_object.geometry.parameters;
	return in_object.material[SHELL_COLOR_INDEX] = surfaceFactory.create(in_color, setting.size);
}

const shellGeometryFactory = factoryBuilder((in_size, in_innerRatio, in_thickness) => {
	const radian = 6;
	const outerLen = in_size - radian * 2;
	const innerLen = outerLen * in_innerRatio;
	const thickness = in_thickness - radian * 2;
	const geometry = trapezoidGeometryUtil(outerLen, outerLen, outerLen, innerLen, thickness, radian);
	geometry.parameters = {
		size : in_size,
		innerRatio : in_innerRatio,
		thickness : in_thickness
	};
	return geometry;
});

const GRAY1 = 0x222222;
const GRAY2 = 0x444444;
const GRAY3 = 0x666666;

const BGCOLOR = GRAY1;
const DMZCOLOR = GRAY2;
const EMPTYCOLOR = GRAY3;

const ORANGE = 0xFFAA00;
const RED = 0xFF0000;
const WHITE = 0xFFFFFF;
const YELLOW = 0xFFFF00;
const BLUE = 0x3333FF;
const GREEN = 0x118811;
const LIGHTBLUE = 0x5588FF;
const LIGHTGREEN = 0x55CC55;

const edgeMaterial = new THREE.MeshLambertMaterial({color : BGCOLOR});

/*
	(2) dimension of Cube and Meshes of them
*/

const PUZZLE_SIZE = 400;
const LABEL_LV = 'lv.';

const gMeshLevelMap = ((in_diameter) => {
	const map = new cCyclicMap();
	const shellInfo = [
		{
			rowsForCircle : 14,
			colsForLength : 7,
			dmzArr : [
				[ 7, 0], [ 7, 1], [ 7, 2], [ 7, 3], [ 7, 4], [ 7, 5], [ 7, 6],
				[ 8, 0], [ 8, 1], [ 8, 2], [ 8, 3], [ 8, 4], [ 8, 5], [ 8, 6],
				[ 9, 0], [ 9, 1], [ 9, 2], [ 9, 3], [ 9, 4], [ 9, 5], [ 9, 6],
				[10, 0], [10, 1], [10, 2], [10, 3], [10, 4], [10, 5], [10, 6],
				[11, 0], [11, 1], [11, 2], [11, 3], [11, 4], [11, 5], [11, 6],
				[12, 0], [12, 1], [12, 2], [12, 3], [12, 4], [12, 5], [12, 6],
				[13, 0], [13, 1], [13, 2], [13, 3], [13, 4], [13, 5], [13, 6]
			]
		},
		{
			rowsForCircle : 7,
			colsForLength : 7,
			dmzArr : []
		},
		{
			rowsForCircle : 16,
			colsForLength : 8,
			dmzArr : [
				[ 8, 0], [ 8, 1], [ 8, 2], [ 8, 3], [ 8, 4], [ 8, 5], [ 8, 6], [ 8, 7],
				[ 9, 0], [ 9, 1], [ 9, 2], [ 9, 3], [ 9, 4], [ 9, 5], [ 9, 6], [ 9, 7],
				[10, 0], [10, 1], [10, 2], [10, 3], [10, 4], [10, 5], [10, 6], [10, 7],
				[11, 0], [11, 1], [11, 2], [11, 3], [11, 4], [11, 5], [11, 6], [11, 7],
				[12, 0], [12, 1], [12, 2], [12, 3], [12, 4], [12, 5], [12, 6], [12, 7],
				[13, 0], [13, 1], [13, 2], [13, 3], [13, 4], [13, 5], [13, 6], [13, 7],
				[14, 0], [14, 1], [14, 2], [14, 3], [14, 4], [14, 5], [14, 6], [14, 7],
				[15, 0], [15, 1], [15, 2], [15, 3], [15, 4], [15, 5], [15, 6], [15, 7]
			]
		},
		{
			rowsForCircle : 8,
			colsForLength : 8,
			dmzArr : []
		}
	];
	shellInfo.forEach(in_shell => {
		const radius = in_diameter / 2;
		const circumf = in_diameter * Math.PI;
		const unitSize = circumf / in_shell.rowsForCircle;
		const unitThick = unitSize * 0.3;
		const unitAngle = Math.PI * 2 / in_shell.rowsForCircle;
		const geometry = shellGeometryFactory.create(unitSize, ((radius - unitThick) / radius), unitThick);
		const pieces = [];
		for (let col = 0; col < in_shell.colsForLength; col++) {
			let x = unitSize * col - unitSize * (in_shell.colsForLength - 1) / 2;
			let y = (in_diameter / 2 - unitThick) * 1.2;
			for (let row = 0; row < in_shell.rowsForCircle; row++) {
				let materials = null;
				if (in_shell.dmzArr.length > 0) {
					if (in_shell.dmzArr.some(in_dmz => in_dmz[0] === row && in_dmz[1] === col)) {
						materials = shellMaterials(unitSize, DMZCOLOR, BGCOLOR);
					}
				}
				if (!materials) {
					materials = shellMaterials(unitSize, EMPTYCOLOR, BGCOLOR);
				}
				materials.push(edgeMaterial);
				const piece = new THREE.Mesh(geometry, materials);
				const pivot = new THREE.Object3D();
				pivot.add(piece);
				piece.position.copy(VEC3(x, y, 0));
				pivot.rotateX(unitAngle * row);
				/*
					*** NOTE ***
					you can use matrix,
					to apply rotated position before adding to scene
				*/
				pivot.updateMatrixWorld();
				piece.applyMatrix4(pivot.matrix);
				pivot.remove(piece);
				pieces.push(piece);
			}
		}
		let stage = LABEL_LV + in_shell.colsForLength;
		if (in_shell.rowsForCircle === in_shell.colsForLength) {
			stage += '-loop'
		}
		map.set(stage, pieces);
	});
	return map;
})(PUZZLE_SIZE);

/*
	(3) Puzzle related functions
*/

class cCylinder extends THREE.Object3D {
	get settingVal() {
		if (this.userData.currentSettingKey) {
			return this.userData.settingPerPieces[this.userData.currentSettingKey];
		} else {
			throw new Error('no currentSettingKey');
		}
	}
	set #settingKey(in_value) {
		if (!this.userData.settingPerPieces) {
			this.userData.settingPerPieces = {};
		}
		if (!this.userData.settingPerPieces[in_value]) {
			this.userData.settingPerPieces[in_value] = {};
		}
		this.userData.currentSettingKey = in_value;
	}
	removePieces() {
		const pieces = this.children.slice();
		pieces.forEach(in_piece => {
			this.remove(in_piece);
		});
		this.userData.currentSettingKey = null;
	}
	addPieces(in_pieces) {
		this.removePieces();
		const uuids = [];
		const axisx = new Map();
		in_pieces.forEach(in_piece => {
			uuids.push(in_piece.uuid);
			this.add(in_piece);
			// how many pieces are at position x ?
			const x = in_piece.position.x;
			if (axisx.has(x)) {
				axisx.set(x, axisx.get(x) + 1);
			} else {
				axisx.set(x, 1);
			}
		});
		this.#settingKey = pseudoMessageDigest1(uuids);
		const sorted = [...axisx.keys()].sort((in_e1, in_e2) => in_e1 - in_e2);
		if (!this.settingVal.initialized) {
			this.settingVal.rowsForCircle = Math.max(...Array.from(axisx.values()));
			this.settingVal.colsForLength = Array.from(axisx.keys()).length;
			this.settingVal.origin = in_pieces[0].position.clone();
			this.settingVal.unitDelta = sorted[1] - sorted[0];
			this.settingVal.unitAngle = Math.PI * 2 / this.settingVal.rowsForCircle;
			this.settingVal.completeCallback = null;
			this.settingVal.shuffleCount = 0;
			this.settingVal.shuffled = false;
			this.settingVal.initialized = true;
		}
	}
}

class cCylinderPuzzle extends cCylinder {
	static error = 0.01;
	static #axes = {
		x : VEC3(1, 0, 0),
		y : VEC3(0, 1, 0),
		z : VEC3(0, 0, 1)
	};
	static axisComponent(in_axis, in_match = true) {
		const props = Object.keys(cCylinderPuzzle.#axes).filter(in_key => {
			const equal = cCylinderPuzzle.#axes[in_key].equals(in_axis);
			return in_match ? equal : !equal;
		});
		if (props.length > 1) {
			return props;
		} else {
			return props[0];
		}
	}
	indexToPiece(in_row, in_col) {
		const org = this.settingVal.origin;
		const angle = this.settingVal.unitAngle * in_row;
		const target = VEC3(
			org.x + this.settingVal.unitDelta * in_col,
			org.y * Math.cos(angle),
			org.y * Math.sin(angle)
		);
		return this.children.find(in_child => XYZ.every(in_xyz => Math.abs(in_child.position[in_xyz] - target[in_xyz]) < cCylinderPuzzle.error));
	}
	pieceToIndex(in_piece) {
		const pos = in_piece.position;
		const org = this.settingVal.origin;
		let row;
		for (row = 0; row < this.settingVal.rowsForCircle; row++) {
			const angle = this.settingVal.unitAngle * row;
			if (Math.abs(org.y * Math.cos(angle) - pos.y) > cCylinderPuzzle.error) {
				continue;
			}
			if (Math.abs(org.y * Math.sin(angle) - pos.z) > cCylinderPuzzle.error) {
				continue;
			}
			break;
		}
		return {
			row : row,
			col : Math.round((pos.x - org.x) / this.settingVal.unitDelta)
		};
	}
	getColorTable() {
		const table = [];
		for (let row = 0; row < this.settingVal.rowsForCircle; row++) {
			const rows = [];
			for (let col = 0; col < this.settingVal.colsForLength; col++) {
				const piece = this.indexToPiece(row, col);
				rows.push(getShellColor(piece));
			}
			table.push(rows);
		}
		return table;
	}
	setColorTable(in_table, in_delay = false) {
		const target = [];
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const piece = this.indexToPiece(row, col);
				if (getShellColor(piece) === in_table[row][col]) {
					continue;
				}
				if (in_delay) {
					target.push({
						piece : piece,
						color : in_table[row][col]
					});
				} else {
					setShellColor(piece, in_table[row][col]);
				}
			}
		}
		return target;
	}
	#approximateArr(in_callback, in_order = 1) {
		const xSet = new cApproximateSet(cCylinderPuzzle.error);
		this.children.forEach(in_child => xSet.add(in_callback(in_child)));
		return Array.from(xSet).sort((in_e1, in_e2) => (in_e1 - in_e2) * in_order);
	}
	getScore() {
		const max = 100;
		return Math.max(Math.ceil((max - this.settingVal.shuffleCount) / 10) * 10, 0);
	}
	#isComplete() {
		const evaluators = [
			// the same color appears at the same angle
			in_obj => Math.atan2(in_obj.position.z, in_obj.position.y),
			// the same color appears at the same position-x
			in_obj => in_obj.position.x
		];
		const results = [];
		evaluators.forEach(in_evaluator => {
			const arr = this.#approximateArr(in_evaluator);
			// for all variations
			results.push(arr.every(in_e => {
				let firstColor;
				// for all pieces
				return this.children.every(in_child => {
					const currentColor = getShellColor(in_child);
					if (Math.abs(in_e - in_evaluator(in_child)) < cCylinderPuzzle.error) {
						if (typeof firstColor === 'undefined') {
							firstColor = currentColor;
						} else {
							if (firstColor === currentColor) {
								return true;
							} else {
								return false;
							}
						}
					}
					return true;
				});
			}));
		});
		return results.some(in_result => in_result);
	}
	#setupGroup(in_pieces) {
		const group = new THREE.Object3D();
		this.add(group);
		in_pieces.forEach(in_piece => {
			group.attach(in_piece);
			// tmpCache may be used for customizing animations
			in_piece.userData.tmpCache = {
				position : in_piece.position.clone(),
				rotation : in_piece.rotation.clone()
			};
		});
		// group position is (0, 0, 0)
		return group;
	}
	#releaseGroup(in_group) {
		const copiedPieces = [...in_group.children];
		copiedPieces.forEach(in_piece => {
			/*
				*** NOTE ***
				"add" follows parent position.
				"attach" keeps world position.
				in addition, both of them internally call "remove" from other object.
			*/
			this.attach(in_piece);
			delete in_piece.userData.tmpCache;
		});
		this.remove(in_group);
	}
	// public because of customizing
	affectedPieces(in_piece, in_axis) {
		const pieces = [];
		const component = in_piece.position.dot(in_axis);
		this.children.forEach(in_child => {
			if (Math.abs(component - in_child.position.dot(in_axis)) < cCylinderPuzzle.error) {
				pieces.push(in_child);
			}
		});
		return pieces;
	}
	#affectedRotationPieces(in_piece, in_axis) {
		return this.affectedPieces(in_piece, in_axis);
	}
	#affectedSlidePieces(in_piece, in_sign) {
		const pieces = [];
		const y = in_piece.position.dot(cCylinderPuzzle.#axes.y);
		const z = in_piece.position.dot(cCylinderPuzzle.#axes.z);
		this.children.forEach(in_child => {
			const pos = in_child.position;
			if ((Math.abs(y - pos.y) < cCylinderPuzzle.error) && (Math.abs(z - pos.z) < cCylinderPuzzle.error)) {
				pieces.push(in_child);
			}
		});
		const currSide = (in_sign > 0) ? 'max' : 'min';
		const nextSide = (in_sign > 0) ? 'min' : 'max';
		pieces.sort((in_e1, in_e2) => (in_e1.position.x - in_e2.position.x) * in_sign);
		const getEdgeX = (in_object, in_edge) => {
			const box = new THREE.Box3();
			box.setFromObject(in_object);
			return box[in_edge].x;
		};
		let started = false;
		let edge = getEdgeX(in_piece, currSide);
		const affected = [in_piece];
		pieces.forEach(in_sorted => {
			if (started) {
				// find the adjacent piece
				if (Math.abs(edge - getEdgeX(in_sorted, nextSide)) < cCylinderPuzzle.error) {
					affected.push(in_sorted);
					edge = getEdgeX(in_sorted, currSide);
				}
			} else {
				if (in_sorted === in_piece) {
					started = true;
				}
			}
		});
		// for in_sign direction, there is not piece next to the last element
		return affected;
	}
	#slidableDistance(in_piece, in_sign) {
		const xArr = this.#approximateArr(in_obj => in_obj.position.x, in_sign);
		for (let i = 0; i < xArr.length - 1; i++) {
			if (Math.abs(xArr[i] - in_piece.position.x) < cCylinderPuzzle.error) {
				return xArr[i + 1] - in_piece.position.x;
			}
		}
		return 0;
	}
	// public because of customizing
	rotate(in_group, in_axis, in_rad) {
		in_group.rotation[cCylinderPuzzle.axisComponent(in_axis)] = in_rad;
	}
	#makeAnimationProgress(in_group, in_axis, in_startAmount, in_finalAmount, in_callback) {
		const amount = Math.abs(in_finalAmount - in_startAmount);
		let duration;
		if (in_axis) {
			duration = amount / (Math.PI / 2) * 500;
		} else {
			duration = 100;
		}
		const ease = new cEase(in_startAmount, in_finalAmount, duration);
		const progress = () => {
			const currAmount = ease.currentEasingIn();
			if (in_axis) {
				this.rotate(in_group, in_axis, currAmount);
			} else {
				in_group.position.x = currAmount;
			}
			let ratio = Math.abs(currAmount - in_startAmount) / amount;
			if (currAmount === in_finalAmount) {
				this.#releaseGroup(in_group);
				this.settingVal.shuffled = true;
				// in this case, progress function should be stopped (in in_callback)
				ratio = 1.0;
			}
			(in_callback)(ratio);
		};
		return progress;
	}
	makeRandomAnimationProgress(in_callback) {
		let axis, pieces, last;
		let maxLoopCount = 100;
		const order = Symbol.for('makeRandomAnimationProgress');
		if (!this.hasOwnProperty(order)) {
			this[order] = true;
		}
		while (true) {
			if (--maxLoopCount === 0) {
				throw new Error('maxLoopCount'); 
			}
			const _piece = (this.children)[arrRand]();
			if (this[order]) {
				axis = null;
				let _amount = 0;
				pieces = this.#affectedSlidePieces(_piece, +1);
				_amount = this.#slidableDistance(pieces[pieces.length - 1], +1);
				if (_amount !== 0) {
					last = _amount;
					break;
				}
				pieces = this.#affectedSlidePieces(_piece, -1);
				_amount = this.#slidableDistance(pieces[pieces.length - 1], -1);
				if (_amount !== 0) {
					last = _amount;
					break;
				}
			} else {
				axis = cCylinderPuzzle.#axes.x;
				pieces = this.#affectedRotationPieces(_piece, axis);
				if (pieces.length < this.children.length) {
					last = this.settingVal.unitAngle * [1, 2, 3][arrRand]();
					break;
				}
			}
		}
		this[order] = !this[order];
		const group = this.#setupGroup(pieces);
		return this.#makeAnimationProgress(group, axis, 0, last, in_callback);
	}
	registerCompleteCallback(in_callback) {
		this.settingVal.completeCallback = in_callback;
	}
	removeCompleteCallback() {
		this.settingVal.completeCallback = null;
	}
	static #uiStates  = {
		DISABLED : Symbol(),
		ENABLED : Symbol(),
		DRAGGING : Symbol(),
		MOVING : Symbol(),
		MOMENTUM : Symbol()
	}
	/*
		ENABLED <-------------------+
		|                           |
		+-[disable]-----+           |
		|               |           |
		|   DISABLED <--+           |
		|   |                       |
		|   +-[enable]--------------+
		|                           |
		+-[drag]--------+           |
		                |           |
		    DRAGGING <--+           |
		    |                       |
		    +-[release]-------------+
		    |                       |
		    +-[movable]-----+       |
		                    |       |
		        MOVING <----+       |
		        |                   |
		        +-[release]-----+   |
		                        |   |
		            MOMENTUM <--+   |
		            |               |
		            +-[stop]--------+
	*/
	static #uiTransitions = {
		[cCylinderPuzzle.#uiStates.DISABLED]: {
			enable : cCylinderPuzzle.#uiStates.ENABLED
		},
		[cCylinderPuzzle.#uiStates.ENABLED]: {
			disable : cCylinderPuzzle.#uiStates.DISABLED,
			drag : cCylinderPuzzle.#uiStates.DRAGGING
		},
		[cCylinderPuzzle.#uiStates.DRAGGING]: {
			release : cCylinderPuzzle.#uiStates.ENABLED,
			movable : cCylinderPuzzle.#uiStates.MOVING
		},
		[cCylinderPuzzle.#uiStates.MOVING]: {
			release : cCylinderPuzzle.#uiStates.MOMENTUM
		},
		[cCylinderPuzzle.#uiStates.MOMENTUM]: {
			stop : cCylinderPuzzle.#uiStates.ENABLED
		}
	};
	#uiSession = {
		state : cCylinderPuzzle.#uiStates.ENABLED,
		ctx : {}
	};
	#transition(in_action) {
		const newState = cCylinderPuzzle.#uiTransitions[this.#uiSession.state]?.[in_action];
		if (newState) {
			this.#uiSession.state = newState;
		} else {
			throw new Error('invalid transition : ' + in_action);
		}
	}
	uiEnable() {
		if (this.#uiSession.state !== cCylinderPuzzle.#uiStates.DISABLED) {
			console.log('state is not DISABLED');
			return;
		}
		this.#transition('enable');
	}
	uiDisable() {
		if (this.#uiSession.state !== cCylinderPuzzle.#uiStates.ENABLED) {
			console.log('state is not ENABLED');
			return;
		}
		this.#transition('disable');
	}
	#uiInitSession() {
		if (this.#uiSession.ctx.group) {
			this.#releaseGroup(this.#uiSession.ctx.group);
		}
		this.#uiSession.ctx = {};
	}
	uiSetInitPosition(in_posV3, in_posV2) {
		if (this.#uiSession.state !== cCylinderPuzzle.#uiStates.ENABLED) {
			console.log('state is not ENABLED');
			return;
		}
		this.#uiSession.ctx = {
			// intersection with a object
			initPosV3 : in_posV3,
			// abs value generated from NDC (Normalized Device Coordinates)
			initPosV2 : in_posV2,
			// vector from initPosV2
			initDirV2 : null,
			// target objects for animation
			group : null,
			// current value which will be updated during animation
			currAmount : 0,
			// sign which show the direction for animation
			direction : 0,
			// rotating animation uses this axis
			rotationAxis : null,
			// array of [min, max]
			movableRange : null,
		};
		this.#transition('drag');
	}
	uiIsDragging() {
		return (this.#uiSession.state === cCylinderPuzzle.#uiStates.DRAGGING);
	}
	uiIsMoving() {
		return (this.#uiSession.state === cCylinderPuzzle.#uiStates.MOVING);
	}
	static uiSetDeltaPositionRC = {
		NOOP : Symbol(),
		// as delta is not enough, need to call uiNotifyDeltaPosition again
		NOTENOUGH : Symbol(),
		// though delta is enough, can't make group
		UNMOVABLE : Symbol(),
		// as delta is enough, can call uiUpdatePosition
		MOVABLE : Symbol()
	};
	uiNotifyDeltaPosition(in_piece, in_posV3, in_posV2) {
		const RC = cCylinderPuzzle.uiSetDeltaPositionRC;
		if (this.#uiSession.state !== cCylinderPuzzle.#uiStates.DRAGGING) {
			console.log('state is not DRAGGING');
			return RC.NOOP;
		}
		const ctx = this.#uiSession.ctx;
		const srcYZ = new THREE.Vector2(ctx.initPosV3.y, ctx.initPosV3.z);
		const dstYZ = new THREE.Vector2(in_posV3.y, in_posV3.z);
		const rotateDelta = srcYZ.distanceTo(dstYZ);
		const movingDelta = Math.abs(in_posV3.x - ctx.initPosV3.x);
		const notEnough = (in_threshold => {
			return (in_a, in_b) => {
				return (in_a < in_threshold * in_b) && (in_b < in_threshold * in_a);
			};
		})(1.5);
		if (notEnough(rotateDelta, movingDelta)) {
			return RC.NOTENOUGH;
		}
		let pieces, direction, axis, range;
		if (rotateDelta > movingDelta) {
			pieces = this.#affectedRotationPieces(in_piece, cCylinderPuzzle.#axes.x);
			if (pieces.length < this.children.length) {
				direction = srcYZ.cross(dstYZ) > 0 ? 1 : -1;
				axis = cCylinderPuzzle.#axes.x;
				range = null;
			} else {
				return RC.UNMOVABLE;
			}
		} else {
			direction = Math.sign(in_posV3.x - ctx.initPosV3.x);
			pieces = this.#affectedSlidePieces(in_piece, direction);
			const amount = this.#slidableDistance(pieces[pieces.length - 1], direction);
			if (amount !== 0) {
				axis = null;
				range = {min : Math.min(0, amount), max : Math.max(0, amount)};
			} else {
				return RC.UNMOVABLE;
			}
		}
		this.#transition('movable');
		ctx.initDirV2 = in_posV2.clone().sub(ctx.initPosV2);
		ctx.group = this.#setupGroup(pieces);
		ctx.direction = direction;
		ctx.rotationAxis = axis;
		ctx.movableRange = range;
		return RC.MOVABLE;
	}
	uiUpdatePosition(in_posV2) {
		if (this.#uiSession.state !== cCylinderPuzzle.#uiStates.MOVING) {
			return;
		}
		const ctx = this.#uiSession.ctx;
		const currentDirV2 = in_posV2.clone().sub(ctx.initPosV2);
		let prev, next;
		let amount, notch;
		if (ctx.rotationAxis) {
			amount = in_posV2.distanceTo(ctx.initPosV2) * ctx.direction;
			if (ctx.initDirV2.dot(currentDirV2) > 0) {
				// currentDirV2 & initDirV2 --> SAME direction
				amount *= +1;
			} else {
				// currentDirV2 & initDirV2 --> OPPOSITE direction
				const thresholdToStopWarp = Math.PI / 8;
				if (Math.abs(ctx.currAmount + amount) < thresholdToStopWarp) {
					amount *= -1;
				}
			}
			this.rotate(ctx.group, ctx.rotationAxis, amount);
			notch = this.settingVal.unitAngle;
		} else {
			amount = in_posV2.distanceTo(ctx.initPosV2) * ctx.direction * 250;
			if (amount < ctx.movableRange.min) {
				amount = ctx.movableRange.min;
			}
			if (amount > ctx.movableRange.max) {
				amount = ctx.movableRange.max;
			}
			ctx.group.position.x = amount;
			notch = Math.abs(ctx.movableRange.min + ctx.movableRange.max);
		}
		prev = snapToNotch(ctx.currAmount, notch);
		next = snapToNotch(amount, notch);
		ctx.currAmount = amount;
		// over the top
		return (prev !== next);
	}
	uiRelease(in_ending_callback) {
		if (this.#uiSession.state === cCylinderPuzzle.#uiStates.DRAGGING) {
			this.#uiInitSession();
			this.#transition('release');
			return null;
		}
		if (this.#uiSession.state !== cCylinderPuzzle.#uiStates.MOVING) {
			return null;
		}
		this.#transition('release');
		const ctx = this.#uiSession.ctx;
		let notch;
		if (ctx.rotationAxis) {
			notch = this.settingVal.unitAngle;
		} else {
			notch = Math.abs(ctx.movableRange.min + ctx.movableRange.max);
		}
		const last = snapToNotch(ctx.currAmount, notch);
		return this.#makeAnimationProgress(ctx.group, ctx.rotationAxis, ctx.currAmount, last, in_ratio => {
			if (in_ratio < 1) {
				return;
			}
			this.#uiInitSession();
			this.#transition('stop');
			(in_ending_callback)();
			if (!this.settingVal.shuffled) {
				// when without shuffled, do nothing
				return;
			}
			this.settingVal.shuffleCount++;
			if (this.settingVal.completeCallback && this.#isComplete()) {
				(this.settingVal.completeCallback)(this.settingVal.shuffleCount);
			}
		});
	}
}

/*
	(4) algorithm + controller
*/

class cReversi {
	static #styles = {
		'2x6' : {
			size : 6,
			init : [
				0, 1,
				1, 0
			]
		},
		'2x7' : {
			size : 7,
			init : [
				0, 0, 1,
				1, 9, 1,
				1, 0, 0
			]
		},
		'2x8' : {
			size : 8,
			init : [
				0, 1,
				1, 0
			]
		},
		'4x7' : {
			size : 7,
			init : [
				0, 2, 1,
				1, 9, 3,
				3, 0, 2
			]
		},
		'4x8' : {
			size : 8,
			init : [
				9, 1, 9, 9,
				9, 3, 0, 2,
				0, 2, 1, 9,
				9, 9, 3, 9
			]
		}
	};
	static #positive = +1;
	static #negative = -1;
	static #maximize(in_evaluator, in_player, in_candidates) {
		const evaluated = new Map();
		in_candidates.forEach(in_ix => evaluated.set(in_ix, (in_evaluator)(in_player, in_ix)));
		const max = {
			value : -Infinity,
			indexes : null
		};
		for (const [index, value] of evaluated.entries()) {
			if (value > max.value) {
				max.value = value;
				max.indexes = [index];
			} else {
				if (value === max.value) {
					max.indexes.push(index);
				}
			}
		}
		return max.indexes;
	}
	static #minimize(in_evaluator, in_player, in_candidates) {
		const evaluator = (...in_args) => {
			return (in_evaluator)(...in_args) * cReversi.#negative;
		};
		return this.#maximize(evaluator, in_player, in_candidates);
	}
	static #dmz = Symbol(8);
	static #empty = Symbol(9);
	static #directions = (() => {
		const arr = [];
		[-1, 0, +1].forEach(in_row => {
			[-1, 0, +1].forEach(in_col => {
				if ((in_row === 0) && (in_col === 0)) {
					return;
				}
				arr.push({
					dr : in_row,
					dc : in_col
				});
			});
		});
		return arr;
	})();
	#style = null;
	#players = [];
	#edge = {
		row : true,
		col : true
	};
	#area = {
		latest : [],
		backup : null
	};
	#labels = null;
	#history = [];
	constructor(in_style = '2x8', in_rEdge = true, in_cEdge = true) {
		this.#style = cReversi.#styles[in_style];
		this.#edge = {
			row : in_rEdge,
			col : in_cEdge
		};
		const playerCnt = parseInt(in_style.split('x')[0]);
		for (let i = 0; i < playerCnt; i++) {
			this.#players[i] = Symbol(i);
		}
		this.#areaInitialize();
		this.#labels = this.#aroundSquareCornerLabels();
	}
	#areaInitialize() {
		this.#area.latest = new Array(this.#style.size ** 2).fill(cReversi.#empty);
		const centerSize = this.#style.init.length ** 0.5;
		const centerStart = (this.#style.size - centerSize) / 2;
		for (let row = 0; row < centerSize; row++) {
			for (let col = 0; col < centerSize; col++) {
				const init = this.#style.init[row * centerSize + col];
				if (init < this.#players.length) {
					this.#setAreaByPos(row + centerStart, col + centerStart, this.#players[init]);
				}
			}
		}
		this.#areaCommit();
	}
	#areaCommit() {
		this.#area.backup = null;
	}
	#areaRestore() {
		this.#area.latest = [...this.#area.backup];
		this.#area.backup = null;
	}
	#setAreaByIndex(in_ix, in_data) {
		if (!this.#area.backup) {
			this.#area.backup = [...this.#area.latest];
		}
		this.#area.latest[in_ix] = in_data;
	}
	#setAreaByPos(in_row, in_col, in_data) {
		this.#setAreaByIndex(in_row * this.#style.size + in_col, in_data);
	}
	#getAreaByIndex(in_ix) {
		return this.#area.latest[in_ix];
	}
	#getAreaByPos(in_row, in_col) {
		return this.#getAreaByIndex(in_row * this.#style.size + in_col);
	}
	#indexToPos(in_ix) {
		return {
			row : Math.floor(in_ix / this.#style.size),
			col : in_ix % this.#style.size
		};
	}
	#posToIndex(in_row, in_col) {
		return in_row * this.#style.size + in_col;
	}
	#aroundCornerLabels(in_rLen, in_cLen) {
		const cornerArr = [
			{
				pos : {
					row : 0,
					col : 0
				},
				dirRow : +1,
				dirCol : +1
			},
			{
				pos : {
					row : 0,
					col : in_cLen - 1
				},
				dirRow : +1,
				dirCol : -1
			},
			{
				pos : {
					row : in_rLen - 1,
					col : 0
				},
				dirRow : -1,
				dirCol : +1
			},
			{
				pos : {
					row : in_rLen - 1,
					col : in_cLen - 1
				},
				dirRow : -1,
				dirCol : -1
			}
		];
		/*
			P1, N2, P3
			N2, N1, XX
			P3, XX, P2
		*/
		const deltaList = {
			P1 : [{row : 0, col : 0}],
			P2 : [{row : 2, col : 2}],
			P3 : [{row : 2, col : 0}, {row : 0, col : 2}],
			N1 : [{row : 1, col : 1}],
			N2 : [{row : 1, col : 0}, {row : 0, col : 1}]
		};
		const labels = {};
		cornerArr.forEach(in_corner => {
			for (let posName in deltaList) {
				for (let i = 0; i < deltaList[posName].length; i++) {
					const delta = deltaList[posName][i];
					if (!labels[posName]) {
						labels[posName] = [];
					}
					labels[posName].push(this.#posToIndex(
						in_corner.pos.row + delta.row * in_corner.dirRow,
						in_corner.pos.col + delta.col * in_corner.dirCol
					));
				}
			}
		});
		return labels;
	}
	#aroundSquareCornerLabels() {
		return this.#aroundCornerLabels(this.#style.size, this.#style.size);
	}
	#isLabel(in_ix, in_label) {
		return this.#labels[in_label].includes(in_ix);
	}
	#inArea(in_row, in_col) {
		if ((in_row < 0) || (this.#style.size - 1 < in_row)) {
			return false;
		}
		if ((in_col < 0) || (this.#style.size - 1 < in_col)) {
			return false;
		}
		return true;
	}
	#checkCyclic(in_value, in_edge) {
		if (in_edge) {
			return in_value;
		} else {
			return (in_value + this.#style.size) % this.#style.size;
		}
	}
	#canFlipTowards(in_player, in_ix, in_dr, in_dc, in_flip = false) {
		const pos = this.#indexToPos(in_ix);
		let row = this.#checkCyclic(pos.row + in_dr, this.#edge.row);
		let col = this.#checkCyclic(pos.col + in_dc, this.#edge.col);
		let enemy = false;
		const indexes = [in_ix];
		while (this.#inArea(row, col)) {
			const data = this.#getAreaByPos(row, col);
			if (data === in_player) {
				if (enemy) {
					if (in_flip) {
						indexes.forEach(in_target_ix => this.#setAreaByIndex(in_target_ix, in_player));
					}
					return true;
				} else {
					break;
				}
			} else {
				if (data === cReversi.#empty) {
					break;
				} else {
					indexes.push(this.#posToIndex(row, col));
					enemy = true;
				}
			}
			row = this.#checkCyclic(row + in_dr, this.#edge.row);
			col = this.#checkCyclic(col + in_dc, this.#edge.col);
			if ((row === pos.row) && (col === pos.col)) {
				break;
			}
		}
		return false;
	}
	#flipTowards(in_player, in_ix, in_dr, in_dc) {
		this.#canFlipTowards(in_player, in_ix, in_dr, in_dc, true); 
	}
	#canChoose(in_player, in_ix) {
		if (this.#getAreaByIndex(in_ix) !== cReversi.#empty) {
			return false;
		}
		for (const {dr, dc} of cReversi.#directions) {
			if (this.#canFlipTowards(in_player, in_ix, dr, dc)) {
				return true;
			}
		}
		return false;
	}
	#chooseTentative(in_player, in_ix) {
		for (const {dr, dc} of cReversi.#directions) {
			this.#flipTowards(in_player, in_ix, dr, dc);
		}
	}
	#choose(in_player, in_ix) {
		if (!this.#canChoose(in_player, in_ix)) {
			return false;
		}
		this.#chooseTentative(in_player, in_ix);
		this.#areaCommit();
		this.#history.push(this.#indexToPos(in_ix));
		return true;
	}
	#phase() {
		const initEmpties = (this.#style.size ** 2) - this.#style.init.filter(in_el => in_el > 0).length;
		const currEmpties = this.#area.latest.filter(in_el => in_el === cReversi.#empty).length;
		return 1 - currEmpties / initEmpties;
	}
	#searchCandidates(in_player) {
		const candidates = [];
		for (let ix = 0; ix < this.#area.latest.length; ix++) {
			if (this.#canChoose(in_player, ix)) {
				candidates.push(ix);
			}
		}
		return candidates;
	}
	#countOwnedArea(in_player, in_ix, in_booster = null) {
		this.#chooseTentative(in_player, in_ix);
		let count = 0;
		for (let ix = 0; ix < this.#area.latest.length; ix++) {
			if (this.#area.latest[ix] === in_player) {
				count++;
				if (in_booster) {
					count = in_booster(in_player, in_ix);
				}
			}
		}
		this.#areaRestore();
		return count;
	}
	#countEnemyOption(in_player, in_ix) {
		this.#chooseTentative(in_player, in_ix);
		const next = (this.#players.indexOf(in_player) + 1) % this.#players.length;
		const candidates = this.#searchCandidates(this.#players[next]);
		this.#areaRestore();
		return candidates.length;
	}
	#nearestCornerIsOwned(in_player, in_ix) {
		const min = {
			value : Infinity,
			index : -1
		};
		const src = this.#indexToPos(in_ix);
		this.#labels.P1.forEach(in_corner_ix => {
			const dst = this.#indexToPos(in_corner_ix);
			const pow = (dst.row - src.row) ** 2 + (dst.col - src.col) ** 2;
			if (pow < min.value) {
				min.value = pow;
				min.index = in_corner_ix;
			}
		});
		return (this.#getAreaByIndex(min.index) === in_player);
	}
	#getModifier(in_player, in_ix) {
		const modifier2 = [5, -4, 3];
		const modifier4 = {
			'P1' : 100,
			'P2' : +2,
			'P3' : +1,
			'N1' : -10,
			'N2' : -5
		};
		if (this.#edge.row && this.#edge.col) {
			for (let label in modifier4) {
				if (this.#isLabel(in_ix, label)) {
					if (this.#nearestCornerIsOwned(in_player, in_ix)) {
						return +3;
					} else {
						return modifier4[label];
					}
				}
			}
		} else {
			const pos = this.#indexToPos(in_ix);
			let line = -1;
			if (this.#edge.row) {
				line = pos.row;
			}
			if (this.#edge.col) {
				line = pos.col;
			}
			for (let i = 0; i < modifier2.length; i++) {
				if ((line === i) || (line === this.#style.size - 1 - i)) {
					return modifier2[i];
				}
			}
		}
		return 0;
	}
	#npc_mixed(in_player) {
		// change tactics depending on the phase
		const progress = this.#phase();
		if (progress < 0.5) {
			return this.#npc_area_ex(in_player);
		} else {
			if (progress < 0.9) {
				return this.#npc_option_ex(in_player);
			} else {
				return this.#npc_greed_ex(in_player);
			}
		}
	}
	#npc_area_ex(in_player) {
		// minimize score of area which in_player will get + using additional rule
		const candidates1st = this.#searchCandidates(in_player);
		if (candidates1st.length === 0) {
			return false;
		}
		const eval1st = (in_player, in_ix) => {
			const booster = (...in_args) => {
				// for minimize
				return this.#getModifier(...in_args) * cReversi.#negative;
			};
			return this.#countOwnedArea(in_player, in_ix, booster);
		};
		const candidates2nd = cReversi.#minimize(eval1st, in_player, candidates1st);
		if (candidates2nd.length > 1) {
			const eval2nd = (in_player, in_ix) => {
				return this.#countEnemyOption(in_player, in_ix) - this.#getModifier(in_player, in_ix);
			};
			const candidates3rd = cReversi.#minimize(eval2nd, in_player, candidates2nd);
			this.#choose(in_player, candidates3rd[arrRand]());
		} else {
			this.#choose(in_player, candidates2nd[0]);
		}
		return true;
	}
	#npc_area(in_player) {
		// minimize score of area which in_player will get
		const candidates1st = this.#searchCandidates(in_player);
		if (candidates1st.length === 0) {
			return false;
		}
		const eval1st = (in_player, in_ix) => {
			return this.#countOwnedArea(in_player, in_ix);
		};
		const candidates2nd = cReversi.#minimize(eval1st, in_player, candidates1st);
		this.#choose(in_player, candidates2nd[arrRand]());
		return true;
	}
	#npc_option_ex(in_player) {
		// minimize options which enemy can take + using additional rule
		const candidates1st = this.#searchCandidates(in_player);
		if (candidates1st.length === 0) {
			return false;
		}
		const eval1st = (in_player, in_ix) => {
			return this.#countEnemyOption(in_player, in_ix) - this.#getModifier(in_player, in_ix);
		};
		const candidates2nd = cReversi.#minimize(eval1st, in_player, candidates1st);
		if (candidates2nd.length > 1) {
			const eval2nd = (in_player, in_ix) => {
				const booster = (...in_args) => {
					// for minimize
					return this.#getModifier(...in_args) * cReversi.#negative;
				};
				return this.#countOwnedArea(in_player, in_ix, booster);
			};
			const candidates3rd = cReversi.#minimize(eval2nd, in_player, candidates2nd);
			this.#choose(in_player, candidates3rd[arrRand]());
		} else {
			this.#choose(in_player, candidates2nd[0]);
		}
		return true;
	}
	#npc_option(in_player) {
		// minimize options which enemy can take
		const candidates1st = this.#searchCandidates(in_player);
		if (candidates1st.length === 0) {
			return false;
		}
		const eval1st = (in_player, in_ix) => {
			return this.#countEnemyOption(in_player, in_ix);
		};
		const candidates2nd = cReversi.#minimize(eval1st, in_player, candidates1st);
		this.#choose(in_player, candidates2nd[arrRand]());
		return true;
	}
	#npc_greed_ex(in_player) {
		// maximize area which in_player will get + using additional rule
		const candidates1st = this.#searchCandidates(in_player);
		if (candidates1st.length === 0) {
			return false;
		}
		const eval1st = (in_player, in_ix) => {
			const booster = (...in_args) => {
				// for maximize
				return this.#getModifier(...in_args) * cReversi.#positive;
			};
			return this.#countOwnedArea(in_player, in_ix, booster);
		};
		const candidates2nd = cReversi.#maximize(eval1st, in_player, candidates1st);
		this.#choose(in_player, candidates2nd[arrRand]());
		return true;
	}
	#npc_greed(in_player) {
		// maximize area which in_player will get
		const candidates1st = this.#searchCandidates(in_player);
		if (candidates1st.length === 0) {
			return false;
		}
		const eval1st = (in_player, in_ix) => {
			return this.#countOwnedArea(in_player, in_ix);
		};
		const candidates2nd = cReversi.#maximize(eval1st, in_player, candidates1st);
		this.#choose(in_player, candidates2nd[arrRand]());
		return true;
	}
	#npc_random(in_player) {
		const candidates1st = this.#searchCandidates(in_player);
		if (candidates1st.length === 0) {
			return false;
		}
		this.#choose(in_player, candidates1st[arrRand]());
		return true;
	}
	#npcSet = {
		mixed : this.#npc_mixed,
		area1 : this.#npc_area_ex,
		option1 : this.#npc_option_ex,
		greed1 : this.#npc_greed_ex,
		area2 : this.#npc_area,
		option2 : this.#npc_option,
		greed2 : this.#npc_greed,
		random : this.#npc_random
	};
	_simulation() {
		const npcs = {
			mixed : this.#npc_mixed,
			area1 : this.#npc_area_ex,
			option1 : this.#npc_option_ex,
			greed1 : this.#npc_greed_ex,
			area2 : this.#npc_area,
			option2 : this.#npc_option,
			greed2 : this.#npc_greed,
			random : this.#npc_random
		};
		const test = (in_p1, in_p2) => {
			let cnt = 100;
			while (true) {
				const enable1 = (this.#npcSet[in_p1].bind(this))(this.#players[0]);
				const enable2 = (this.#npcSet[in_p2].bind(this))(this.#players[1]);
				if (enable1 || enable2) {
					if (cnt-- === 0) {
						break;
					}
				} else {
					break;
				}
				// this.dp();
			}
			const point1 = this.#area.latest.filter(in_el => in_el === this.#players[0]).length;
			const point2 = this.#area.latest.filter(in_el => in_el === this.#players[1]).length;
			return (point1 > point2);
		};
		const table = [];
		table.push(['(vs)', ...Object.keys(this.#npcSet)]);
		Object.keys(this.#npcSet).forEach(p1 => {
			const row = [p1];
			Object.keys(this.#npcSet).forEach(p2 => {
				if (p1 === p2) {
					row.push('-');
				} else {
					if ((p1 === 'random') || (p2 === 'random')) {
						const repeat = 10;
						let cnt = repeat;
						let win = 0;
						while (true) {
							if (cnt-- > 0) {
								if (test(p1, p2)) {
									win++;
								}
								this.#areaInitialize();
							} else {
								break;
							}
						}
						row.push(win / repeat);
					} else {
						row.push(test(p1, p2));
					}
				}
				this.#areaInitialize();
			});
			table.push(row);
		});
		const elem = (in_table => {
			const ret = document.createElement('TABLE');
			in_table.forEach(in_row => {
				const row = document.createElement('TR');
				in_row.forEach(in_cell => {
					const cell = document.createElement('TD');
					cell.innerText = in_cell;
					let color = 'eeeeee';
					if (typeof in_cell === 'boolean') {
						if (in_cell) {
							color = 'ccccff';
						} else {
							color = 'ffcccc';
						}
					} else {
						if (typeof in_cell === 'number') {
							if (in_cell > 0.5) {
								color = 'ccccff';
							} else {
								color = 'ffcccc';
							}
						}
					}
					cell.style.backgroundColor = color;
					cell.style.textAlign = 'center';
					cell.style.border = '1px solid black';
					cell.style.padding = '3px';
					cell.style.width = '5em';
					row.appendChild(cell);
				});
				ret.appendChild(row);
			});
			ret.style.borderCollapse = 'collapse';
			return ret;
		})(table);
		const script = document.currentScript;
		script.parentNode.insertBefore(elem, script.nextSibling);
	}
	_debug() {
		for (let row = 0; row < this.#style.size; row++) {
			const arr = [];
			for (let col = 0; col < this.#style.size; col++) {
				arr.push(this.#getAreaByPos(row, col));
			}
			console.log(arr);
		}
	}
	pc(in_no, in_row, in_col) {
		return this.#choose(this.#players[in_no], this.#posToIndex(in_row, in_col));
	}
	npc(in_no, in_argo = 'mixed') {
		return (this.#npcSet[in_argo].bind(this))(this.#players[in_no]);
	}
	getHistory() {
		return this.#history;
	}
	getArea() {
		const table = [];
		for (let ix = 0; ix < this.#area.latest.length; ix++) {
			const pos = this.#indexToPos(ix);
			if (!table[pos.row]) {
				table[pos.row] = [];
			}
			table[pos.row][pos.col] = parseInt(this.#area.latest[ix].description);
		}
		return table;
	}
	setArea(in_table) {
	}
}

class cTurnController {
	#players = new cCyclicValues();
	#active = false;
	#turns = 0;
	get cycle() {
		return Math.floor(this.#turns / this.#players.length);
	}
	registerPlayer(in_turnHook, in_playerId = randomString()) {
		this.#players.push({
			turnHook : in_turnHook,
			playerId : in_playerId
		});
		return in_playerId;
	}
	#turnStart(in_player) {
		this.#turns++;
		in_player.turnHook(in_player.playerId);
	}
	turnEnd() {
		if (!this.#active) {
			return;
		}
		this.#turnStart(this.#players.incrementedValue());
	}
	gameStart() {
		this.#active = true;
		this.#turnStart(this.#players.currValue());
	}
	gameEnd() {
		this.#active = false;
	}
}

/*
	(5) ui & dom setting

	gWorld (cSphericalWorld)
	|
	+-- gCylinder (cCylinderPuzzle)
		|
		+-- meshes <--- gMeshLevelMap
*/

const WORLD_RADIUS = PUZZLE_SIZE * 10;
const WORLD_INIT_ZOOM = WORLD_RADIUS / 2;

const gWorld = new cSphericalWorld(WORLD_RADIUS);

const gCylinder = new cCylinderPuzzle();

gWorld.add(gCylinder);

gWorld.moveView(0.5, 0.5);
gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);

/*
	*** NOTE ***
	when you use AxesHelper,
	// gWorld.add(new THREE.AxesHelper(WORLD_RADIUS));
	gWorld.setZoom() can not work well.
*/

/*
	*** NOTE ***
	in Safari, using await to get audio will cause the process to fail.
	I'm not sure of the reason, but top-level await might be the cause.
	this time use then() to avoid the issue.
*/

let SE_BEEP = beep(2000);
let SE_DUMMY = beep(10);
let SE_MOVED = SE_BEEP;
let SE_ERROR = SE_BEEP;

SOUND.MOVED.then(in_decompress => {
	SE_MOVED = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

SOUND.ERROR.then(in_decompress => {
	SE_ERROR = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

function setTransition(in_elem, in_shorthand, in_val1, in_val2) {
	const components = in_shorthand.split(/\s+/);
	in_elem.style.transition = in_shorthand;
	in_elem.style[components[0]] = in_val1;
	window.setTimeout(() => {
		/*
			*** NOTE ***
			to fire the transition function,
			the final style should be set in the next event loop.
		*/
		in_elem.style[components[0]] = in_val2;
	}, 0);
}

function startDialog(in_element, in_callback = null) {
	const maxInt = 2 ** 31 - 1;
	const background = document.createElement('div');
	Object.assign(background.style, {
		position : 'fixed',
		left : '0px',
		top : '0px',
		width : '100%',
		height : '100%',
		zIndex : maxInt
	});
	background.appendChild(in_element);
	Object.assign(in_element.style, {
		position : 'absolute',
		left : '50%',
		top : '50%',
		transform : 'translate(-50%, -50%)'
	});
	document.body.appendChild(background);
	const closeDialog = () => {
		document.body.removeChild(background);
		if (in_callback) {
			(in_callback)();
		}
	};
	background.addEventListener('mousedown', closeDialog);
	background.addEventListener('touchstart', closeDialog);
}

function uiHelp() {
	const url = {
		ver : './version.txt',
		im1 : 'https://pj-corridor.net/images/cube-2-03.png',
		im2 : 'https://pj-corridor.net/images/diamond-2-4.png',
		im3 : 'https://pj-corridor.net/images/cube-6-03.png',
		im4 : 'https://pj-corridor.net/images/diamond-6-4.png',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div>';
	[url.im1, url.im2, url.im3, url.im4].forEach(in_img => {
		dialog.innerHTML += '<img width="100" src="' + in_img + '" />';
	});
	dialog.innerHTML += '</div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getVersion(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.log(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Rights</dt>',
		'<dd>This software is based on MIT License.</dd>',
		'<dd>The code can be freely modified and reused.</dd>',
		'<dd>For full license details, please refer to :</dd>',
		'<dd>https://opensource.org/licenses/MIT</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white')
	startDialog(dialog);
}

const ID_PREV_LEVEL = randomString();
const ID_NEXT_LEVEL = randomString();

(in_level => {
	if (in_level === false) {
		gMeshLevelMap.setOrder(0);
	} else {
		gMeshLevelMap.setOrder(in_level);
	}
})(getParam('level'));

async function updateLevel() {
	const color = 0x000000;
	await gWorld.motionFog(color, 0, 100);
	gCylinder.removePieces();
	const current = gMeshLevelMap.currItemByOrder();
	gCylinder.addPieces(current.v);
	await gWorld.motionFog(color, 100, 0);
	const prev = gMeshLevelMap.prevItemByOrder();
	const next = gMeshLevelMap.nextItemByOrder();
	document.getElementById(ID_PREV_LEVEL).innerText = prev.k;
	document.getElementById(ID_NEXT_LEVEL).innerText = next.k;
	initializeByLevel();
}

updateLevel();

function prevLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	gMeshLevelMap.shiftOrder(-1);
	updateLevel();
}

function nextLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	gMeshLevelMap.shiftOrder(+1);
	updateLevel();
}

(in_settings => {
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	in_settings.forEach(in_setting => {
		let button = document.createElement('button');
		if (in_setting.id) {
			button.id = in_setting.id;
		}
		if (in_setting.text) {
			button.innerText = in_setting.text;
		}
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})([
	{
		id : ID_PREV_LEVEL,
		text : '(Prev)',
		func : prevLevel
	},
	{
		id : ID_NEXT_LEVEL,
		text : '(Next)',
		func : nextLevel
	},
	{
		text : 'help',
		func : uiHelp
	},
	{
		text : 'rights',
		func : uiRights
	}
]);

function hex2rgb(in_hex) {
	const mask = 0xFF;
	const r = (in_hex >> 16) & mask;
	const g = (in_hex >> 8) & mask;
	const b = in_hex & mask;
	return [r, g, b];
}

function drawCosmicView(in_canvas, in_stars, in_nebulae_patterns, in_color = 0x000064) {
	const ctx = in_canvas.getContext('2d');
	const w = in_canvas.width;
	const h = in_canvas.height;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	for (let i = 0; i < in_nebulae_patterns; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 100 + 50;
		const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
		const rgb = hex2rgb(in_color);
		gradient.addColorStop(0, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0.5)');
		gradient.addColorStop(1, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0)');
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = gradient;
		ctx.fill();
	}
	for (let i = 0; i < in_stars; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 1;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = 'white';
		ctx.fill();
	}
}

const gBackgroundCanvas = document.createElement('CANVAS');

Object.assign(gBackgroundCanvas.style, {
	position : 'absolute',
	left : 0,
	top : 0,
	zIndex : -1
});

document.addEventListener('DOMContentLoaded', (() => {
	let resizeWorld = in_ev => {
		gWorld.resize(
			window.innerWidth,
			window.innerHeight);
		gBackgroundCanvas.width = window.innerWidth;
		gBackgroundCanvas.height = window.innerHeight;
		drawCosmicView(gBackgroundCanvas, 400, 50);
	};
	window.addEventListener('resize', debouncing(resizeWorld, 300));
	window.dispatchEvent(new Event('resize'));
	if (!document.body) {
		document.documentElement.appendChild(document.createElement('BODY'));
	}
	Object.assign(document.body.style, {
		margin : '0',
		overflow : 'hidden'
	});
	document.body.appendChild(gWorld.canvas);
	document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

/*
	(6) event handlers
*/

const knock = nonReentrantAsync(async () => {
	SE_ERROR.play();
	await gWorld.motionKnock();
});

const notifyDelta = (() => {
	const RC = cCylinderPuzzle.uiSetDeltaPositionRC;
	return in_ndc => {
		const intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			return;
		}
		const result = gCylinder.uiNotifyDeltaPosition(intersects[0].object, intersects[0].point, ndcToAbs(in_ndc));
		if (result === RC.UNMOVABLE) {
			knock();
		}
	}
})();

const focusHere = (() => {
	let prev = null;
	return in_ndc => {
		let intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			if (prev) {
				setShellColor(prev, prev.userData.original);
				/*
					*** NOTE ***
					as materials made by boxMaterials will be cached using cCache,
					you don't need to call dispose() when mouseout.
				*/
				delete prev.userData.original;
				prev = null;
			}
			return;
		}
		const curr = intersects[0].object;
		// assume that each face is composed of two faces
		if (prev) {
			if (prev === curr) {
				return;
			} else {
				setShellColor(prev, prev.userData.original);
			}
		}
		prev = curr;
		curr.userData.original = getShellColor(curr);
		if (curr.userData.original !== EMPTYCOLOR) {
			return;
		}
		const color = new THREE.Color(prev.userData.original);
		const highlight = 0.3;
		setShellColor(curr, color.lerp(new THREE.Color(0xFFFFFF), highlight).getHex());
	}
})();

const PLAYERS = {
	PC : 0,
	NPC1 : 1,
	NPC2 : 2,
	NPC3 : 3
};

const gContext = {
	riversi : null,
	mapping : (() => {
		const arr = new Array(10).fill(-1);
		arr[PLAYERS.PC] = BLUE;
		arr[PLAYERS.NPC1] = RED;
		arr[PLAYERS.NPC2] = YELLOW;
		arr[PLAYERS.NPC3] = GREEN;
		arr[8] = DMZCOLOR;
		arr[9] = EMPTYCOLOR;
		return arr;
	})(),
	controller : null,
	enableHandlers : false
};

async function choosePiece(in_no, in_piece) {
	const outOfRange = new THREE.Vector2(Infinity, Infinity);
	focusHere(outOfRange);
	setShellColor(in_piece, gContext.mapping[in_no]);
	if (in_no !== PLAYERS.PC) {
		const dst = in_piece.position.clone();
		dst.x *= 0.5;
		await gWorld.motionViewFrom(dst, 500);
	}
	const indexTable = gContext.riversi.getArea();
	const colorTable = indexTable.map(in_row => in_row.map(in_cell => gContext.mapping[in_cell]));
	const targets = gCylinder.setColorTable(colorTable, true);
	targets.forEach(in_target => in_target.initRotationX = in_target.piece.rotation.x);
	const ease = new cEase(0, Math.PI * 2, 500);
	const hook = () => {
		const angle = ease.currentEasingOut();
		if (angle > Math.PI) {
			if (angle === Math.PI * 2) {
				gWorld.removeAnimationHook(hook);
				targets.forEach(in_target => in_target.piece.rotation.x = in_target.initRotationX);
				return;
			} else {
				targets.forEach(({piece, color}) => setShellColor(piece, color));
			}
		}
		targets.forEach(in_target => in_target.piece.rotation.x = in_target.initRotationX + angle);
	};
	gWorld.addAnimationHook(hook);
}

function chooseHere(in_ev) {
	const ndc = ndcFromEvent(in_ev);
	let intersects = gWorld.intersectPositive(ndc);
	if (intersects.length === 0) {
		return;
	}
	const curr = intersects[0].object;
	if (curr.userData.original === EMPTYCOLOR) {
		const pos = gCylinder.pieceToIndex(intersects[0].object);
		const result = gContext.riversi.pc(PLAYERS.PC, pos.row, pos.col);
		if (result) {
			gContext.enableHandlers = false;
			choosePiece(PLAYERS.PC, intersects[0].object);
			gContext.controller.turnEnd();
			return;
		}
	}
	knock();
}

(() => {
	const closure = {
		x : -1,
		y : -1,
		once : false
	};
	const start = in_ev => {
		if (!closure.once) {
			/*
				*** NOTE ***
				Safari may restrict sound without user interaction.
				because of this, the sound does not work without this code.
			*/
			SE_DUMMY.play();
			closure.once = true;
		}
		const ndc = ndcFromEvent(in_ev);
		const intersects = gWorld.intersectPositive(ndc);
		if (intersects.length === 0) {
			return;
		}
		closure.x = in_ev.clientX;
		closure.y = in_ev.clientY;
		gCylinder.uiSetInitPosition(intersects[0].point, ndcToAbs(ndc));
	};
	const move = thresholding(in_ev => {
		closure.x = -1;
		closure.y = -1;
		const ndc = ndcFromEvent(in_ev);
		if (gCylinder.uiIsMoving()) {
			if (gCylinder.uiUpdatePosition(ndcToAbs(ndc))) {
				SE_MOVED.play();
			}
		} else {
			if (gCylinder.uiIsDragging()) {
				notifyDelta(ndc);
			} else {
				if (!in_ev[isEmulated]) {
					focusHere(ndc);
				}
			}
		}
	});
	const stop = in_ev => {
		const releaseProgress = gCylinder.uiRelease(() => {
			gWorld.removeAnimationHook(releaseProgress);
		});
		if (releaseProgress) {
			gWorld.addAnimationHook(releaseProgress);
		} else {
			if ((closure.x !== in_ev.clientX) || (closure.y !== in_ev.clientY)) {
				return;
			}
			chooseHere(in_ev);
		}
	};
	let handlers = {
		'mousedown' : start,
		'mousemove' : move,
		'mouseleave' : stop,
		'mouseout' : stop,
		'mouseup' : stop
	};
	for (let [name, func] of Object.entries(handlers)) {
		gWorld.canvas.addEventListener(name, in_ev => {
			if (gContext.enableHandlers) {
				(func.bind(this))(in_ev);
			}
		});
	}
})();

function initializeByLevel() {
	/*
		1. cReversi settings
	*/
	const players = (in_players => {
		const default_players = 2;
		if (in_players === false) {
			return default_players;
		} else {
			if ((in_players === 2) || (in_players === 4)) {
				return in_players;
			} else {
				return default_players;
			}
		}
	})(getParam('players'));
	const curr = gMeshLevelMap.currItemByOrder();
	const match = curr.k.match(new RegExp(LABEL_LV + '(\\d+)'));
	const mode = players + 'x' + parseInt(match[1], 10);
	gContext.riversi = new cReversi(mode);
	/*
		2. cTurnController settings
	*/
	gContext.controller = new cTurnController();
	gContext.controller.registerPlayer(() => {
		// PLAYERS.PC
		gContext.enableHandlers = true;
	});
	gContext.controller.registerPlayer(() => {
		// PLAYERS.NPC1
		const result = gContext.riversi.npc(PLAYERS.NPC1);
		if (result) {
			const history = gContext.riversi.getHistory();
			const pos = history[history.length - 1];
			const piece = gCylinder.indexToPiece(pos.row, pos.col);
			choosePiece(PLAYERS.NPC1, piece);
			gContext.controller.turnEnd();
			return;
		}
		// gContext.controller.gameEnd();
	});
	const indexTable = gContext.riversi.getArea();
	const colorTable = indexTable.map(in_row => in_row.map(in_cell => gContext.mapping[in_cell]));
	gCylinder.setColorTable(colorTable);
	gContext.controller.gameStart();
}

</script>
</body>
</html>
