<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports" : {
		"three" : "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.min.js",
		"utils" : "https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/utils/BufferGeometryUtils.js",
		"basic" : "./basic-functions.js",
		"side6" : "./side-six.js",
		"s6res" : "./side-six-reversi-res.js",
		"sound" : "./sound-effect.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';
import {
	getVersion,
	getParam,
	DEBUG,
	randomString,
	snapToNotch,
	snapToPI,
	snapTo05PI,
	createPeriodicSin,
	createPeriodicCos,
	pseudoMessageDigest1,
	pseudoMessageDigest2,
	beep,
	isEmulated,
	throttling,
	thresholding,
	debouncing,
	nonReentrantAsync,
	factoryBuilder,
	arrRand,
	arrTrim,
	cEase,
	cApproximateMap,
	cApproximateSet,
	cCyclicMap,
	cCyclicValues,
	forEachCombination,
	clipArea,
	clipClearArea,
	fillRoundRect,
	XYZ,
	VEC3,
	DIRECTION,
	ndcFromEvent,
	ndcToAbs,
	getWorldVec3,
	getWorldUp,
	instanceInAncestor,
	lookAtWithoutRotation,
	safeMergeGeometry,
	makeTrapezoidGeometryParts,
	trapezoidGeometryUtil,
	roundBoxGeometry,
	roundRegularBoxGeometry,
	roundTrapezoidGeometry,
	capsuleConfigure,
	customCapsuleGeometry,
	cSphericalWorld
} from 'basic';
import {
	cColony
} from 'side6';
import {
	RES
} from 's6res';
import * as SOUND from 'sound';

/*
	the cReversi class is designed to implement NPC algorithms for the game of reversi.
*/

class cLineEvaluater {
	static #empty = 9;
	static #makeSubset(in_items, in_player) {
		let index = 0;
		const subset = [];
		for (let i = 0; i < in_items.length; i++) {
			if (!subset[index]) {
				subset[index] = [];
			}
			if (in_items[i] === in_player) {
				if (subset[index].length > 0) {
					index++;
				}
			} else {
				subset[index].push(in_items[i]);
			}
		}
		const last = subset[subset.length - 1];
		if (last.length === 0) {
			// remove last
			subset.pop();
		}
		return subset;
	}
	static #checkSafe(in_items, in_player, in_edge) {
		if (in_items.indexOf(in_player) === -1) {
			return true;
		}
		let decrement = 1;
		if (!in_edge) {
			// if check first + last
			if (in_player === in_items[0]) {
				decrement = 0;
			}
			if (in_player === in_items[in_items.length - 1]) {
				decrement = 0;
			}
		}
		// search safe pattern : both sides of in_player are the same
		const subset = cLineEvaluater.#makeSubset(in_items, in_player);
		const safes = [];
		const risks = [];
		for (let currIx = 0; currIx < subset.length - decrement; currIx++) {
			const nextIx = (currIx + 1 + subset.length) % subset.length;
			const currArr = subset[currIx];
			const nextArr = subset[nextIx];
			if (currArr[currArr.length - 1] === nextArr[0]) {
				safes.push(currIx);
			} else {
				risks.push(currIx);
			}
		}
		if (in_edge) {
			const edgeRisk = ([0, subset.length - 1]).some(in_ix => {
				if (!risks.includes(in_ix)) {
					return false;
				}
				if (subset[in_ix].length > 1) {
					return false;
				}
				return (subset[in_ix][0] === cLineEvaluater.#empty);
			});
			if (edgeRisk) {
				return false;
			}
		}
		if (safes.length >= risks.length) {
			return true;
		} else {
			if (subset.length < 3) {
				return false;
			}
			const targets = [
				{
					edgeIx : 0,
					emptyIx : 0,
					neighbor : +1
				},
				{
					edgeIx : subset.length - 1,
					emptyIx : subset[subset.length - 1].length - 1,
					neighbor : -1
				}
			];
			return targets.some(in_target => {
				/*
					to find specific format ...
					1. |E, x, x, x, o, E, o --> [E, x, x, x], [E]
					2. o, E, o, x, x, x, E| --> [E], [x, x, x, E]
				*/
				const outerIx = in_target.edgeIx;
				const innerIx = in_target.edgeIx + in_target.neighbor;
				if ((subset[outerIx].length === 1) && (subset[innerIx].length !== 1)) {
					return false;
				}
				if (subset[innerIx][0] !== cLineEvaluater.#empty) {
					return false;
				}
				for (let i = 0; i < subset[outerIx].length; i++) {
					if (i === in_target.emptyIx) {
						if (subset[outerIx][i] !== cLineEvaluater.#empty) {
							return false;
						}
					} else {
						if (subset[outerIx][i] === cLineEvaluater.#empty) {
							return false;
						}
					}
				}
				return true;
			});
		}
	}
	static evaluate1(in_items1st, in_items2nd, in_player, in_noLoop) {
		let eval1st, eval2nd;
		if (in_noLoop) {
			eval1st = cLineEvaluater.#checkSafe(in_items1st, in_player, true);
			eval2nd = cLineEvaluater.#checkSafe(in_items2nd, in_player, true);
		} else {
			eval1st = cLineEvaluater.#checkSafe(in_items1st, in_player, false);
			eval2nd = cLineEvaluater.#checkSafe(in_items2nd, in_player, false);
		}
		if (eval1st) {
			if (eval2nd) {
				// safe ---> safe
				return 0;
			} else {
				// safe ---> unsafe
				return -1;
			}
		} else {
			if (eval2nd) {
				// unsafe ---> safe
				return +1;
			} else {
				// unsafe ---> unsafe
				return 0;
			}
		}

	}
	static evaluate2(in_items1st, in_ix, in_player, in_noLoop) {
		const items2nd = [...in_items1st];
		items2nd[in_ix] = in_player;
		// flip if needed
		([-1, +1]).forEach(in_direction => {
			let ix = in_ix;
			let enemyAppears = false;
			let canFlip = false;
			const indexes = [];
			while (true) {
				ix += in_direction;
				if (in_noLoop) {
					if ((ix < 0) || (items2nd.length - 1 < ix)) {
						break;
					}
				} else {
					ix = (ix + items2nd.length) % items2nd.length;
					if (ix === in_ix) {
						break;
					}
				}
				if (items2nd[ix] === in_player) {
					if (enemyAppears) {
						canFlip = true;
					}
					break;
				} else {
					if (items2nd[ix] === cLineEvaluater.#empty) {
						break;
					} else {
						indexes.push(ix);
						enemyAppears = true;
					}
				}
			}
			if (canFlip) {
				indexes.forEach(in_filp_ix => items2nd[in_filp_ix] = in_player);
			}
		});
		return this.evaluate1(in_items1st, items2nd, in_player, in_noLoop);
	}
	static test() {
		const p = 0;
		const x = 'x';
		const cases = [

			{line : [x,9,9,9,9,9,9,9], edge : true, expected : 0},
			{line : [x,9,9,9,9,9,9,9], edge : false, expected : 0},
			{line : [9,9,9,9,9,9,9,x], edge : true, expected : 0},
			{line : [9,9,9,9,9,9,9,x], edge : false, expected : 0},

			{line : [9,x,9,9,9,9,9,9], edge : true, expected : 0},
			{line : [9,x,9,9,9,9,9,9], edge : false, expected : 0},
			{line : [9,9,9,9,9,9,x,9], edge : true, expected : 0},
			{line : [9,9,9,9,9,9,x,9], edge : false, expected : 0},

			{line : [x,1,9,9,9,9,9,9], edge : true, expected : 0},
			{line : [x,1,9,9,9,9,9,9], edge : false, expected : -1},
			{line : [9,9,9,9,9,9,1,x], edge : true, expected : 0},
			{line : [9,9,9,9,9,9,1,x], edge : false, expected : -1},

			{line : [x,1,0,9,9,9,9,9], edge : true, expected : +1},
			{line : [x,1,0,9,9,9,9,9], edge : false, expected : +1},
			{line : [9,9,9,9,9,0,1,x], edge : true, expected : +1},
			{line : [9,9,9,9,9,0,1,x], edge : false, expected : +1},

			{line : [x,1,0,9,9,9,9,1], edge : true, expected : +1},
			{line : [x,1,0,9,9,9,9,1], edge : false, expected : 0},
			{line : [1,9,9,9,9,0,1,x], edge : true, expected : +1},
			{line : [1,9,9,9,9,0,1,x], edge : false, expected : 0},

			{line : [9,9,0,1,x,1,9,9], edge : true, expected : 0},
			{line : [9,9,0,1,x,1,9,9], edge : false, expected : 0},
			{line : [9,9,1,x,1,0,9,9], edge : true, expected : 0},
			{line : [9,9,1,x,1,0,9,9], edge : false, expected : 0},

			{line : [9,9,1,0,x,1,9,9], edge : true, expected : +1},
			{line : [9,9,1,0,x,1,9,9], edge : false, expected : +1},
			{line : [9,9,1,x,0,1,9,9], edge : true, expected : +1},
			{line : [9,9,1,x,0,1,9,9], edge : false, expected : +1},

		];
		cases.forEach(in_case => {
			const ix = in_case.line.indexOf(x);
			const text = in_case.line.toString() + (in_case.edge ? ' |' : ' -') + ' : ';
			const line = in_case.line.map(in_item => in_item === x ? 9 : in_item);
			const evaluated = cLineEvaluater.evaluate2(line, ix, p, in_case.edge);
			console.log(text, (evaluated === in_case.expected));
		});
	}
}

class cReversi {
	static #maximize(in_evaluator, in_player, in_candArr) {
		const evaluated = new Map();
		in_candArr.forEach(in_ix => evaluated.set(in_ix, (in_evaluator)(in_player, in_ix)));
		const max = {
			value : -Infinity,
			indexes : []
		};
		for (const [index, value] of evaluated.entries()) {
			if (value > max.value) {
				max.value = value;
				max.indexes = [index];
			} else {
				if (value === max.value) {
					max.indexes.push(index);
				}
			}
		}
		if (max.indexes.length === 0) {
			console.log(evaluated);
			throw new Error();
		}
		return max.indexes;
	}
	static #rotateArray(in_array, in_delta) {
		const len = in_array.length;
		const delta = ((in_delta % len) + len) % len;
		return in_array.slice(delta * -1).concat(in_array.slice(0, delta * -1));
	}
	static #dmz = 8;
	static #empty = 9;
	static #maxPlayers = 4;
	static #validData = (() => {
		const arr = [cReversi.#dmz, cReversi.#empty];
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			arr.push(player);
		}
		return arr;
	})();
	static #directions = [
		[-1, -1],
		[-1,  0],
		[-1, +1],
		[ 0, -1],
		[ 0, +1],
		[+1, -1],
		[+1,  0],
		[+1, +1]
	];
	static #priorityTop = +99;
	static #priorityLast = -99;
	static #ignore = Symbol();
	#areaData = [];
	#areaScores = {
		default : [],
		current : []
	};
	#npcArgoPriority = [];
	#history = [];
	#conf = null;
	#rotations = null;
	constructor(in_table, in_rowEdge, in_colEdge) {
		const sizeRow = in_table.length;
		const sizeCol = in_table.reduce((in_maxLen, in_row) => {
			return Math.max(in_maxLen, in_row.length);
		}, 0);
		this.#conf = {
			row : {
				size : sizeRow,
				edge : in_rowEdge
			},
			col : {
				size : sizeCol,
				edge : in_colEdge
			},
			corners : {
				angle000 : {
					pos : {
						row : 0,
						col : 0
					},
					dirRow : +1,
					dirCol : +1
				},
				angle090 : {
					pos : {
						row : 0,
						col : sizeCol - 1
					},
					dirRow : +1,
					dirCol : -1
				},
				angle180 : {
					pos : {
						row : sizeRow - 1,
						col : sizeCol - 1
					},
					dirRow : -1,
					dirCol : -1
				},
				angle270 : {
					pos : {
						row : sizeRow - 1,
						col : 0
					},
					dirRow : -1,
					dirCol : +1
				}
			},
			indexes : {
				corner : [],
				xSquare : [],
				sameRow : [],
				sameCol : [],
				radiating : []
			}
		};
		this.setTable(in_table);
		this.#initAreaScores();
		Object.keys(this.#conf.corners).forEach(in_angleKey => {
			const angle = this.#conf.corners[in_angleKey];
			this.#conf.indexes.corner.push(this.#posToIndex(
				angle.pos.row,
				angle.pos.col
			));
			// xSquare is neighbor to the corner on the diagonal
			this.#conf.indexes.xSquare.push(this.#posToIndex(
				angle.pos.row + angle.dirRow,
				angle.pos.col + angle.dirCol
			));
		});
		for (let row = 0; row < sizeRow; row++) {
			this.#conf.indexes.sameRow[row] = [];
			for (let col = 0; col < sizeCol; col++) {
				this.#conf.indexes.sameRow[row].push(this.#posToIndex(row, col));
			}
		}
		for (let col = 0; col < sizeCol; col++) {
			this.#conf.indexes.sameCol[col] = [];
			for (let row = 0; row < sizeRow; row++) {
				this.#conf.indexes.sameCol[col].push(this.#posToIndex(row, col));
			}
		}
		for (let ix = 0; ix < this.#areaData.length; ix++) {
			const {row : initRow, col : initCol} = this.#indexToPos(ix);
			const radiating = this.#conf.indexes.radiating[ix] = [];
			for (let dir = 0; dir < cReversi.#directions.length; dir++) {
				const [dr, dc] = cReversi.#directions[dir];
				const towards = [];
				let currRow = initRow;
				let currCol = initCol;
				while (true) {
					currRow += dr;
					if (in_rowEdge) {
						if ((currRow < 0) || (sizeRow - 1 < currRow)) {
							// out of range
							break;
						}
					} else {
						currRow = (currRow + sizeRow) % sizeRow;
						if ((currRow === initRow) && (dr !== 0)) {
							// cyclic
							break;
						}
					}
					currCol += dc;
					if (in_colEdge) {
						if ((currCol < 0) || (sizeCol - 1 < currCol)) {
							// out of range
							break;
						}
					} else {
						currCol = (currCol + sizeCol) % sizeCol;
						if ((currCol === initCol) && (dc !== 0)) {
							// cyclic
							break;
						}
					}
					towards.push(this.#posToIndex(currRow, currCol));
				}
				if (towards.length > 0) {
					radiating.push(towards);
				}
			}
		}
		const argoArr = ['balance', 'spiteful', 'greedy', 'learner', 'classic', 'beginner', 'monkey'];
		for (let i = 0; i < argoArr.length; i++) {
			this.#npcArgoPriority.push((argoArr.slice(0, i + 1))[arrRand]());
		}
	}
	#indexToPos(in_ix) {
		return {
			row : Math.floor(in_ix / this.#conf.col.size),
			col : in_ix % this.#conf.col.size
		};
	}
	#posToIndex(in_row, in_col) {
		return in_row * this.#conf.col.size + in_col;
	}
	#copyAreaData() {
		return [...this.#areaData];
	}
	#restoreAreaData(in_array) {
		this.#areaData = [...in_array];
	}
	#setItemByIndex(in_ix, in_item) {
		this.#areaData[in_ix] = in_item;
	}
	#setItemByPos(in_row, in_col, in_item) {
		this.#setItemByIndex(this.#posToIndex(in_row, in_col), in_item);
	}
	#getItemByIndex(in_ix) {
		return this.#areaData[in_ix];
	}
	#getItemByPos(in_row, in_col) {
		return this.#getItemByIndex(this.#posToIndex(in_row, in_col));
	}
	#items(in_indexes) {
		const items = [];
		in_indexes.forEach(in_ix => {
			items.push(this.#getItemByIndex(in_ix));
		});
		return items;
	}
	#rotateItems(in_indexes, in_delta) {
		const shifted = cReversi.#rotateArray(in_indexes, in_delta);
		const copy = this.#copyAreaData();
		for (let i = 0; i < in_indexes.length; i++) {
			/*
				for example ...
				src = 5, 6, 7, 8
				dst = 8, 5, 6, 7
			*/
			this.#setItemByIndex(in_indexes[i], copy[shifted[i]]);
		}
	}
	#rotateSameRowItems(in_targetRow, in_deltaCol) {
		const sameRowIndexes = this.#conf.indexes.sameRow[in_targetRow];
		this.#rotateItems(sameRowIndexes, in_deltaCol);
	}
	#rotateSameColItems(in_targetCol, in_deltaRow) {
		const sameColIndexes = this.#conf.indexes.sameCol[in_targetCol];
		this.#rotateItems(sameColIndexes, in_deltaRow);
	}
	#flip(in_player, in_ix, in_test = false) {
		const radiating = this.#conf.indexes.radiating[in_ix];
		let choosable = false;
		for (let i = 0; i < radiating.length; i++) {
			const towards = radiating[i];
			const ixArr = [];
			let enemyAppears = false;
			for (let j = 0; j < towards.length; j++) {
				const ix = towards[j];
				const item = this.#getItemByIndex(ix);
				if (item === in_player) {
					if (enemyAppears) {
						if (in_test) {
							return true;
						} else {
							choosable = true;
							ixArr.forEach(in_flipped_ix => this.#setItemByIndex(in_flipped_ix, in_player));
						}
					}
					break;
				} else {
					if ((item === cReversi.#dmz) || (item === cReversi.#empty)) {
						break;
					} else {
						ixArr.push(ix);
						enemyAppears = true;
					}
				}
			}
		}
		if (choosable) {
			this.#setItemByIndex(in_ix, in_player);
			return true;
		} else {
			return false;
		}
	}
	#flippable(in_player, in_ix) {
		const isTest = true;
		return this.#flip(in_player, in_ix, isTest);
	}
	#choose(in_player, in_ix) {
		// in_ix must be choosable
		this.#flip(in_player, in_ix);
		const pos = this.#indexToPos(in_ix);
		this.#history.push({
			who : in_player,
			action : 'choose-item',
			row : pos.row,
			col : pos.col,
			target : -1,
			delta : -1
		});
		if (this.#conf.row.edge && this.#conf.col.edge) {
			// in case edge x2
			const angleKey = Object.keys(this.#conf.corners).find(in_angleKey => {
				const corner = this.#conf.corners[in_angleKey].pos;
				return ((corner.row === pos.row) && (corner.col === pos.col));
			});
			if (angleKey) {
				this.#updateCurrentScoresEdge2(in_player, angleKey);
			}
		} else {
			// in case edge x1
			let edge, repl;
			const indexes = this.#conf.indexes;
			if (this.#conf.row.edge) {
				if (pos.row === 0) {
					edge = indexes.sameRow[0];
					repl = indexes.sameRow[1];
				} else if (pos.row === this.#conf.row.size - 1) {
					edge = indexes.sameRow[pos.row];
					repl = indexes.sameRow[pos.row - 1];
				}
			} else if (this.#conf.col.edge) {
				if (pos.col === 0) {
					edge = indexes.sameCol[0];
					repl = indexes.sameCol[1];
				} else if (pos.col === this.#conf.col.size - 1) {
					edge = indexes.sameCol[pos.col];
					repl = indexes.sameCol[pos.col - 1];
				}
			}
			if (edge && repl) {
				for (let i = 0; i < edge.length; i++) {
					const index = repl[i];
					const newScore = +3;
					const owner = this.#getItemByIndex(edge[i]);
					// 1. rollback to default
					for (let player = 0; player < cReversi.#maxPlayers; player++) {
						this.#areaScores.current[player][index] = this.#areaScores.default[index];
					}
					// 2. update for owner
					if (owner < cReversi.#maxPlayers) {
						this.#areaScores.current[owner][index] = newScore;
					}
				}
			}
		}
		// this._debug();
	}
	#npcTryRotate(in_player, in_dir) {
		const rowSet = new Set();
		const colSet = new Set();
		for (let ix = 0; ix < this.#areaData.length; ix++) {
			if (this.#getItemByIndex(ix) !== in_player) {
				continue;
			}
			const col = ix % this.#conf.col.size;
			const row = (ix - col) / this.#conf.col.size;
			rowSet.add(row);
			colSet.add(col);
		}
		const backup = this.#copyAreaData();
		const setting = {
			row : {
				action : 'npc-col-wise-rotate',
				targetArr : Array.from(rowSet),
				rotateFunc : this.#rotateSameRowItems.bind(this),
				maxCnt : this.#conf.col.size
			},
			col : {
				action : 'npc-row-wise-rotate',
				targetArr : Array.from(colSet),
				rotateFunc : this.#rotateSameColItems.bind(this),
				maxCnt : this.#conf.row.size
			}
		}
		// this algorithm can be improved
		const {action, targetArr, rotateFunc, maxCnt} = setting[in_dir];
		let target, delta;
		let rotated = targetArr.some(in_target => {
			target = in_target;
			let rest = maxCnt;
			while (--rest > 0) {
				// rotate +1 (maxCnt - 1) times
				(rotateFunc)(in_target, 1);
				const cand = this.#searchCandidates(in_player);
				if (cand.length > 0) {
					delta = maxCnt - rest;
					return true;
				}
			}
			this.#restoreAreaData(backup);
			return false;
		});
		if (rotated) {
			this.#history.push({
				who : in_player,
				action : action,
				row : -1,
				col : -1,
				target : target,
				delta : delta
			});
		}
		return rotated;
	}
	#phase() {
		const total = this.#conf.row.size * this.#conf.col.size;
		const remaining = this.#areaData.filter(in_el => in_el === cReversi.#empty).length;
		// from 0.0x (!= 0) to 1
		return 1 - remaining / total;
	}
	#searchCandidates(in_player) {
		const candidates = [];
		for (let ix = 0; ix < this.#areaData.length; ix++) {
			if (this.#getItemByIndex(ix) !== cReversi.#empty) {
				continue;
			}
			if (this.#flippable(in_player, ix)) {
				candidates.push(ix);
			}
		}
		return candidates;
	}
	#getAreaScore(in_player, in_ix) {
		return this.#areaScores.current[in_player][in_ix];
	}
	#updateScoresByAngle(io_areaScores, in_format, in_angleKey) {
		const angle = this.#conf.corners[in_angleKey];
		for (let i = 0; i < in_format.length; i++) {
			for (let j = 0; j < in_format[i].length; j++) {
				if (in_format[i][j] === cReversi.#ignore) {
					continue;
				}
				const row = angle.pos.row + i * angle.dirRow;
				const col = angle.pos.col + j * angle.dirCol;
				io_areaScores[this.#posToIndex(row, col)] = in_format[i][j];
			}
		}
	}
	#updateCurrentScoresEdge2(in_player, in_angleKey) {
		const newScore = +4;
		const format = [];
		const size = Math.min(this.#conf.row.size, this.#conf.col.size);
		for (let row = 0; row < size; row++) {
			format[row] = new Array(size).fill(cReversi.#ignore);
			for (let col = 0; col < size; col++) {
				if ((row !== 0) && (col !== 0)) {
					continue;
				}
				const score = this.#areaScores.current[in_player][this.#posToIndex(row, col)];
				if (newScore > score) {
					format[row][col] = newScore;
				}
			}
		}
		format[1][1] = newScore;
		this.#updateScoresByAngle(this.#areaScores.current[in_player], format, in_angleKey);
	}
	#initAreaScores() {
		this.#areaScores.default = new Array(this.#conf.row.size * this.#conf.col.size).fill(-1);
		if (this.#conf.row.edge && this.#conf.col.edge) {
			this.#initDefaultAreaScoresEdge2();
		} else if (this.#conf.row.edge || this.#conf.col.edge) {
			this.#initDefaultAreaScoresEdge1();
		}
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			this.#areaScores.current[player] = [...this.#areaScores.default];
		}
	}
	#initDefaultAreaScoresEdge2() {
		/*
			asume this.#conf.row.size >= 6
			asume this.#conf.col.size >= 6
		*/
		const cornerScore = [];
		const format = [
			[+35,  -4, +2],
			[ -4, -10, -2],
			[ +2,  -2,  0]
		];
		Object.keys(this.#conf.corners).forEach(in_angleKey => {
			this.#updateScoresByAngle(this.#areaScores.default, format, in_angleKey);
		});
	}
	#initDefaultAreaScoresEdge1() {
		const format = [+4, -3, +2];
		if (this.#conf.row.edge) {
			for (let delta = 0; delta < format.length; delta++) {
				const edge1 = delta;
				const edge2 = this.#conf.row.size - 1 - delta;
				for (let col = 0; col < this.#conf.col.size; col++) {
					this.#areaScores.default[this.#posToIndex(edge1, col)] = format[delta];
					this.#areaScores.default[this.#posToIndex(edge2, col)] = format[delta];
				}
			}
		} else {
			// this.#conf.col.edge
			for (let delta = 0; delta < format.length; delta++) {
				const edge1 = delta;
				const edge2 = this.#conf.col.size - 1 - delta;
				for (let row = 0; row < this.#conf.row.size; row++) {
					this.#areaScores.default[this.#posToIndex(row, edge1)] = format[delta];
					this.#areaScores.default[this.#posToIndex(row, edge2)] = format[delta];
				}
			}
		}
	}
	#evaluate(in_player, in_ix) {
		const pos = this.#indexToPos(in_ix);
		const corner_x4 = this.#conf.row.edge && this.#conf.col.edge;
		const ixIsEdge = in_dir => ((this.#conf[in_dir].edge) && ((pos[in_dir] === this.#conf[in_dir].size - 1) || (pos[in_dir] === 0)));
		const ixIsRowEdge = ixIsEdge('row');
		const ixIsColEdge = ixIsEdge('col');
		/*
			1. e (= edge) : check if area of edge is safe
			2. x (= xSquare) : check if xSquare positions will be not changed
		*/
		const would = {
			e : {
				indexes : null,
				currItems : [],
				nextItems : [],
				evaluated : 0
			},
			x : {
				indexes : null,
				currItems : [],
				nextItems : [],
				evaluated : 0
			}
		};
		const indexes = this.#conf.indexes;
		if (ixIsRowEdge) {
			if (ixIsColEdge) {
				// on the corner
				return +1;
			} else {
				would.e.indexes = indexes.sameRow[pos.row];
			}
		} else {
			if (ixIsColEdge) {
				would.e.indexes = indexes.sameCol[pos.col];
			} else {
				// inside
				if (!corner_x4) {
					return 0;
				}
			}
		}
		if (corner_x4) {
			would.x.indexes = [];
			for (let i = 0; i < indexes.corner.length; i++) {
				if (indexes.corner[i] === in_player) {
					// does not need to check x
					continue;
				} else {
					would.x.indexes.push(indexes.xSquare[i]);
				}
			}
		}
		if (would.e.indexes) {
			would.e.currItems = this.#items(would.e.indexes);
		}
		if (would.x.indexes) {
			would.x.currItems = this.#items(would.x.indexes);
		}
		const backup = this.#copyAreaData();
		this.#flip(in_player, in_ix);
		if (would.e.indexes) {
			would.e.nextItems = this.#items(would.e.indexes);
			would.e.evaluated = cLineEvaluater.evaluate1(would.e.currItems, would.e.nextItems, in_player, corner_x4);
		}
		if (would.x.indexes) {
			would.x.nextItems = this.#items(would.x.indexes);
			would.x.evaluated = would.x.nextItems.every((in_item, in_ix) => in_item === would.x.currItems[in_ix]);
			if (!would.x.nextItems.every((in_item, in_ix) => in_item === would.x.currItems[in_ix])) {
				would.x.evaluated = -1;
			}
		}
		this.#restoreAreaData(backup);
		if (would.x.evaluated < 0) {
			return -1;
		} else {
			return would.e.evaluated;
		}
	}
	#countNextEnemyOption(in_player, in_ix) {
		const backup = this.#copyAreaData();
		this.#flip(in_player, in_ix);
		const player = (in_player + 1 + cReversi.#maxPlayers) % cReversi.#maxPlayers;
		const count = this.#searchCandidates(player).length;
		this.#restoreAreaData(backup);
		return count;
	}
	#countNextOwnedArea(in_player, in_ix) {
		const backup = this.#copyAreaData();
		this.#flip(in_player, in_ix);
		const count = this.#areaData.filter(in_item => in_item === in_player).length;
		this.#restoreAreaData(backup);
		return count;
	}
	#calculateNextScore(in_player, in_ix) {
		const backup = this.#copyAreaData();
		this.#flip(in_player, in_ix);
		let score = 0;
		for (let ix = 0; ix < this.#areaData.length; ix++) {
			if (this.#getItemByIndex(ix) === in_player) {
				score += this.#getAreaScore(in_player, ix);
			}
		}
		this.#restoreAreaData(backup);
		return score;
	}
	#npc_phased_tactics(in_player, in_candArr) {
		if (this.#phase() < 0.7) {
			this.#npc_min_enemy_option(in_player, in_candArr);
		} else {
			this.#npc_max_owned_area(in_player, in_candArr);
		}
	}
	#npc_min_enemy_option(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			const score = this.#getAreaScore(in_player, in_ix);
			switch (this.#evaluate(in_player, in_ix)) {
			case +1 :
				return score + cReversi.#priorityTop;
			case -1 :
				return score + cReversi.#priorityLast;
			case 0 :
			default :
				return score + this.#countNextEnemyOption(in_player, in_ix) * -1;
			}
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		if (candArr_2nd.length > 1) {
			const eval2nd = (in_player, in_ix) => {
				return this.#calculateNextScore(in_player, in_ix);
			};
			const candArr_3rd = cReversi.#maximize(eval2nd, in_player, candArr_2nd);
			this.#choose(in_player, candArr_3rd[arrRand]());
		} else {
			this.#choose(in_player, candArr_2nd[0]);
		}
	}
	#npc_max_owned_area(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			const score = this.#getAreaScore(in_player, in_ix);
			switch (this.#evaluate(in_player, in_ix)) {
			case +1 :
				return score + cReversi.#priorityTop;
			case -1 :
				return score + cReversi.#priorityLast;
			case 0 :
			default :
				return score + this.#countNextOwnedArea(in_player, in_ix);
			}
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		if (candArr_2nd.length > 1) {
			const eval2nd = (in_player, in_ix) => {
				return this.#calculateNextScore(in_player, in_ix);
			};
			const candArr_3rd = cReversi.#maximize(eval2nd, in_player, candArr_2nd);
			this.#choose(in_player, candArr_3rd[arrRand]());
		} else {
			this.#choose(in_player, candArr_2nd[0]);
		}
	}
	#npc_score_spot_smart(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			const score = this.#getAreaScore(in_player, in_ix);
			switch (this.#evaluate(in_player, in_ix)) {
			case +1 :
				return score + cReversi.#priorityTop;
			case -1 :
				return score + cReversi.#priorityLast;
			case 0 :
			default :
				return score;
			}
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		this.#choose(in_player, candArr_2nd[arrRand]());
	}
	#npc_score_total(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			return this.#calculateNextScore(in_player, in_ix);
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		this.#choose(in_player, candArr_2nd[arrRand]());
	}
	#npc_score_spot(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			return this.#getAreaScore(in_player, in_ix);
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		this.#choose(in_player, candArr_2nd[arrRand]());
	}
	#npc_random(in_player, in_candArr) {
		const eval1st = (in_player, in_ix) => {
			return 0;
		};
		const candArr_2nd = cReversi.#maximize(eval1st, in_player, in_candArr);
		this.#choose(in_player, candArr_2nd[arrRand]());
	}
	#npcSet = {
		balance : this.#npc_phased_tactics,
		spiteful : this.#npc_min_enemy_option,
		greedy : this.#npc_max_owned_area,
		learner : this.#npc_score_spot_smart,
		classic : this.#npc_score_total,
		beginner : this.#npc_score_spot,
		monkey : this.#npc_random
	}
	_simulation(in_repeat = 100) {
		const test = (in_argoArr) => {
			let cnt = 100;
			while (true) {
				const resultArr = [];
				for (let i = 0; i < in_argoArr.length; i++) {
					resultArr[i] = this.npc(i, in_argoArr[i]);
				}
				if (resultArr.some(in_result => in_result)) {
					if (cnt-- === 0) {
						break;
					}
				} else {
					break;
				}
				// this.dp();
			}
			let max = -Infinity;
			let winner = -1;
			const cond = this.getCurrentCondition();
			for (let i = 0; i < cond.players.length; i++) {
				if (cond.players[i].score > max) {
					max = cond.players[i].score;
					winner = i;
				}
			}
			return winner;
		};
		const backup = this.#copyAreaData();
		// start simulation
		const table = [];
		table.push(['(vs)', ...Object.keys(this.#npcSet)]);
		Object.keys(this.#npcSet).forEach(p1 => {
			const row = [p1];
			Object.keys(this.#npcSet).forEach(p2 => {
				const players = [p1, p2];
				if (p1 === p2) {
					row.push('-');
					return;
				}
				let cnt = in_repeat;
				let win = 0;
				while (true) {
					if (cnt-- > 0) {
						if (test(players) === 0) {
							win++;
						}
						this.#initAreaScores();
						this.#restoreAreaData(backup);
					} else {
						break;
					}
				}
				const digit = 2;
				const order = 10 ** digit;
				row.push(Math.floor(win / in_repeat * order) / order);
				this.#initAreaScores();
				this.#restoreAreaData(backup);
			});
			table.push(row);
		});
		const elem = (in_table => {
			const ret = document.createElement('TABLE');
			in_table.forEach(in_row => {
				const row = document.createElement('TR');
				in_row.forEach(in_cell => {
					const cell = document.createElement('TD');
					cell.innerText = in_cell;
					let color = 'eeeeee';
					if (typeof in_cell === 'boolean') {
						if (in_cell) {
							color = 'ccccff';
						} else {
							color = 'ffcccc';
						}
					} else {
						if (typeof in_cell === 'number') {
							if (in_cell > 0.5) {
								color = 'ccccff';
							} else {
								color = 'ffcccc';
							}
						}
					}
					cell.style.backgroundColor = color;
					cell.style.textAlign = 'center';
					cell.style.border = '1px solid black';
					cell.style.padding = '3px';
					cell.style.width = '5em';
					row.appendChild(cell);
				});
				ret.appendChild(row);
			});
			ret.style.borderCollapse = 'collapse';
			return ret;
		})(table);
		const script = document.currentScript;
		script.parentNode.insertBefore(elem, script.nextSibling);
	}
	_debug() {
		const sources = {area : this.#areaData};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			sources['p-' + player] = this.#areaScores.current[player];
		}
		Object.keys(sources).forEach(in_key => {
			console.log('*** ' + in_key + ' ***');
			const data = sources[in_key];
			for (let row = 0; row < this.#conf.row.size; row++) {
				const items = [];
				for (let col = 0; col < this.#conf.col.size; col++) {
					const ix = this.#posToIndex(row, col);
					items.push(data[ix]);
				}
				console.log(items);
			}
		});
	}
	pc(in_player, in_row, in_col) {
		const index = this.#posToIndex(in_row, in_col);
		if (this.#getItemByIndex(index) !== cReversi.#empty) {
			return false;
		}
		if (this.#flippable(in_player, index)) {
			this.#choose(in_player, index);
			return true;
		} else {
			return false;
		}
	}
	npc(in_player, in_argo = null) {
		let npcAlive = false;
		let playerCnt = 0;
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			if (this.#areaData.indexOf(player) >= 0) {
				playerCnt++;
				if (player === in_player) {
					npcAlive = true;
				}
			}
		}
		if (npcAlive) {
			if (playerCnt === 1) {
				// only in_player
				return false;
			}
		} else {
			// in_player is died
			return false;
		}
		if (this.#areaData.indexOf(cReversi.#empty) === -1) {
			// fulfilled
			return false;
		}
		let npcArgo;
		if (in_argo) {
			npcArgo = in_argo;
		} else {
			npcArgo = this.#npcArgoPriority[in_player];
		}
		// console.log(in_player, npcAlive, playerCnt, npcArgo);
		const candidates = this.#searchCandidates(in_player);
		if (candidates.length > 0) {
			(this.#npcSet[npcArgo].bind(this))(in_player, candidates);
			return true;
		} else {
			if (this.#conf.row.edge) {
				if (this.#conf.col.edge) {
					// can not do anything
					return false;
				} else {
					// try col-wise rotation
					return this.#npcTryRotate(in_player, 'row');
				}
			} else {
				// try row-wise rotation
				return this.#npcTryRotate(in_player, 'col');
			}
		}
	}
	canRowWiseLoop() {
		return !this.#conf.row.edge;
	}
	canColWiseLoop() {
		return !this.#conf.col.edge;
	}
	getLast(in_conditions = {}) {
		// in_conditions : {who, action, row, col, target, delta}
		for (let i = this.#history.length - 1; i >= 0; i--) {
			const last = this.#history[i];
			if (Object.keys(in_conditions).some(in_key => in_conditions[in_key] !== last[in_key])) {
				continue;
			} else {
				return last;
			}
		}
		return null;
	}
	getTable() {
		const table = [];
		for (let ix = 0; ix < this.#areaData.length; ix++) {
			const pos = this.#indexToPos(ix);
			if (!table[pos.row]) {
				table[pos.row] = [];
			}
			table[pos.row][pos.col] = parseInt(this.#getItemByIndex(ix));
		}
		return table;
	}
	setTable(in_table) {
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const item = in_table[row][col];
				if (cReversi.#validData.indexOf(item) < 0) {
					throw new Error('invalid input');
				} else {
					this.#setItemByPos(row, col, item);
				}
			}
		}
	}
	setActionResult(in_player, in_action, in_table) {
		this.setTable(in_table);
		this.#history.push({
			who : in_player,
			action : in_action,
			row : -1,
			col : -1,
			target : -1,
			delta : -1
		});
	}
	getCurrentCondition() {
		const condition = {
			finished : false,
			players : []
		};
		const canRotate = !(this.#conf.row.edge && this.#conf.col.edge);
		const cnt = {
			activePlayer : 0,
			frozenPlayer : 0
		};
		for (let player = 0; player < cReversi.#maxPlayers; player++) {
			let score, dead, frozen;
			score = (this.#areaData.filter(in_el => in_el === player)).length;
			dead = (score === 0);
			if (dead) {
				frozen = true;
			} else {
				const candidates = (this.#searchCandidates(player)).length;
				if ((candidates > 0) || canRotate) {
					cnt.activePlayer++;
					frozen = false;
				} else {
					cnt.frozenPlayer++;
					frozen = true;
				}
			}
			condition.players[player] = {score : score, dead : dead, frozen : frozen};
		}
		condition.finished =
			// only 1 player is active
			(cnt.activePlayer + cnt.frozenPlayer === 1) ||
			// all players are frozen
			(cnt.activePlayer === 0) ||
			// there is no emply
			(this.#phase() === 1);
		return condition;
	}
}

/*
	the cTurnController class is designed to manage turns in turn-based games like reversi.
*/

class cTurnController {
	#players = new cCyclicValues();
	#active = false;
	#turns = 0;
	registerPlayer(in_turnHook, in_playerId = randomString()) {
		this.#players.push({
			turnHook : in_turnHook,
			playerId : in_playerId
		});
		return in_playerId;
	}
	#turnStart(in_player) {
		this.#turns++;
		in_player.turnHook(in_player.playerId);
	}
	turnEnd() {
		if (!this.#active) {
			return;
		}
		this.#turnStart(this.#players.incrementedValue());
	}
	gameStart() {
		this.#active = true;
		this.#turnStart(this.#players.currValue());
	}
	gameEnd() {
		this.#active = false;
	}
}

/*
	the cColony class related functions provide the ability to create cylinder-shaped threejs objects.
*/

const textureFactory = factoryBuilder((in_w, in_h, in_dmz = false) => {
	const gradationCnt = 4
	// gradationCnt (from black to white)
	const maxDepth = 255;
	const rgbArr = [];
	for (let i = 0; i < gradationCnt; i++) {
		const depth = Math.ceil(maxDepth / gradationCnt * (i + 1));
		rgbArr[i] = 'rgb(' + depth + ',' + depth + ',' + depth + ')';
	}
	// draw and convert using toDataUR
	const canvas = document.createElement('CANVAS');
	canvas.width = in_w;
	canvas.height = in_h;
	const ctx = canvas.getContext('2d');
	for (let i = 0; i < gradationCnt; i++) {
		if (in_dmz) {
			ctx.strokeStyle = rgbArr[gradationCnt - i - 1];
			ctx.fillStyle = rgbArr[gradationCnt - i - 1];
			if (i > 0) {
				ctx.lineWidth = (gradationCnt - i) * 2 - 1;
				ctx.beginPath();
				ctx.moveTo(0, 0);
				ctx.lineTo(in_w, in_h);
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo(in_w, 0);
				ctx.lineTo(0, in_h);
				ctx.stroke();
			} else {
				ctx.fillRect(0, 0, in_w, in_h);
			}
		} else {
			/*
				Rect           RoundRect      RoundRect

				##########     ##########     ##########
				##########     ##******##     ##******##
				##########     #********#     #**++++**#
				##########     #********#     #*++++++*#
				########## --> #********# --> #*++++++*# --> ...
				##########     #********#     #*++++++*#
				##########     #********#     #**++++**#
				##########     ##******##     ##******##
				##########     ##########     ##########
			*/
			const radius = gradationCnt + 2;
			ctx.fillStyle = rgbArr[i];
			if (i > 0) {
				ctx[fillRoundRect](i, i, in_w - i * 2, in_h - i * 2, radius - i);
			} else {
				ctx.fillRect(i, i, in_w - i * 2, in_h - i * 2);
			}
		}
	}
	return (new THREE.TextureLoader()).load(canvas.toDataURL());
});

const surfaceFactory = factoryBuilder((in_color, in_size, in_type) => {
	const material = new THREE.MeshLambertMaterial();
	material.color = new THREE.Color(in_color);
	switch (in_type) {
	case 'normal-texture' :
		material.map = textureFactory.create(in_size, in_size, false);
		break;
	case 'dmz-texture' :
		material.map = textureFactory.create(in_size, in_size, true);
		break;
	case 'no-texture' :
	default :
		break;
	}
	return material;
});

const SHELL_COLOR_INDEX = 2;

function shellMaterials(in_size, in_color_main, in_color_back, in_dmz) {
	const materials = [];
	for (let i = 0; i < Object.keys(DIRECTION).length; i++) {
		if (i === SHELL_COLOR_INDEX) {
			const texture = in_dmz ? 'dmz-texture' : 'normal-texture';
			materials.push(surfaceFactory.create(in_color_main, in_size, texture));
		} else {
			materials.push(surfaceFactory.create(in_color_back, in_size, 'no-texture'));
		}
	}
	return materials;
}

function getShellColor(in_object) {
	return in_object.material[SHELL_COLOR_INDEX].color.getHex();
}

function setShellColor(in_object, in_color) {
	const setting = in_object.geometry.parameters;
	return in_object.material[SHELL_COLOR_INDEX] = surfaceFactory.create(in_color, setting.size);
}

const shellGeometryFactory = factoryBuilder((in_size, in_innerRatio, in_thickness) => {
	const radian = 6;
	const outerLen = in_size - radian * 2;
	const innerLen = outerLen * in_innerRatio;
	const thickness = in_thickness - radian * 2;
	const geometry = trapezoidGeometryUtil(outerLen, outerLen, outerLen, innerLen, thickness, radian);
	geometry.parameters = {
		size : in_size,
		innerRatio : in_innerRatio,
		thickness : in_thickness
	};
	return geometry;
});

const GRAY1 = 0x222222;
const GRAY2 = 0x444444;
const GRAY3 = 0x666666;

const BGCOLOR = GRAY1;
const DMZCOLOR = GRAY2;
const EMPTYCOLOR = GRAY3;

const ORANGE = 0xFFAA00;
const RED = 0xFF0000;
const WHITE = 0xFFFFFF;
const YELLOW = 0xFFFF00;
const BLUE = 0x3333FF;
const GREEN = 0x118811;
const LIGHTBLUE = 0x5588FF;
const LIGHTGREEN = 0x55CC55;

const edgeMaterial = new THREE.MeshLambertMaterial({color : BGCOLOR});

const COLONY_SIZE = 400;

const gMeshLevelMap = ((in_diameter) => {
	const map = new cCyclicMap();
	const B = BLUE;
	const R = RED;
	const Y = YELLOW;
	const G = GREEN;
	const D = DMZCOLOR;
	const E = EMPTYCOLOR;
	let shellInfo;
	switch (getParam('type')) {
	case '4-loop' :
		shellInfo = [
			{
				name : '12x6x4-loop',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,R,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,Y,G,E,E],
					[E,E,G,Y,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '18x6x4-loop',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,G,E,E],
					[E,Y,B,R,E,E],
					[E,E,G,Y,B,E],

					[E,E,R,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,Y,E,E],

					[E,R,G,B,E,E],
					[E,E,Y,R,G,E],
					[E,E,B,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '16x8x4-loop',
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,Y,G,E,E,E],
					[E,E,E,G,Y,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				name : '20x10x4-loop',
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,B,E,E,R,E,E,E],
					[E,E,E,E,B,R,E,E,E,E],
					[E,E,E,E,G,Y,E,E,E,E],
					[E,E,E,G,E,E,Y,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,B,E,E,R,E,E,E],
					[E,E,E,E,B,R,E,E,E,E],
					[E,E,E,E,G,Y,E,E,E,E],
					[E,E,E,G,E,E,Y,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E]
				]
			}
		];
		break;
	case '2-loop' :
		shellInfo = [
			{
				name : '12x6x2-loop',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,R,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '18x6x2-loop',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,D,E,E],
					[E,E,B,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,R,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,R,E,E],
					[E,E,D,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E]
				]
			},
			{
				name : '16x8x2-loop',
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E]
				]
			},
			{
				name : '20x10x2-loop',
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,B,E,E,R,E,E,E],
					[E,E,E,E,B,R,E,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,R,E,E,B,E,E,E],
					[E,E,E,E,R,B,E,E,E,E],
					[E,E,E,E,B,R,E,E,E,E],
					[E,E,E,B,E,E,R,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E]
				]
			}
		];
		break;
	case '4-non-loop' :
		shellInfo = [
			{
				name : '6x6x4',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,G,E,E],
					[E,Y,B,R,E,E],
					[E,E,G,Y,B,E],
					[E,E,R,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '12x6x4',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,G,Y,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,G,Y,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '8x8x4',
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,R,E,G,Y,E,E],
					[E,E,Y,B,R,E,E,E],
					[E,E,E,G,Y,B,E,E],
					[E,E,B,R,E,G,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				name : '10x10x4',
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,G,E,E,E,E],
					[E,E,E,Y,B,R,E,E,E,E],
					[E,E,E,E,G,Y,B,E,E,E],
					[E,E,E,E,R,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D]
				]
			}
		];
		break;
	case '2-non-loop' :
	default :
		shellInfo = [
			{
				name : '6x6x2',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,B,R,E,E],
					[E,E,R,B,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '12x6x2',
				table : [
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,R,B,E,E],
					[E,E,B,R,E,E],

					[E,E,R,B,E,E],
					[E,E,B,R,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],
					[E,E,E,E,E,E],

					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D],
					[D,D,D,D,D,D]
				]
			},
			{
				name : '8x8x2',
				table : [
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,B,R,E,E,E],
					[E,E,E,R,B,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D]
				]
			},
			{
				name : '10x10x2',
				table : [
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,B,E,D,R,E,E,E],
					[E,E,E,D,B,R,E,E,E,E],
					[E,E,E,E,R,B,D,E,E,E],
					[E,E,E,R,D,E,B,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],
					[E,E,E,E,E,E,E,E,E,E],

					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D],
					[D,D,D,D,D,D,D,D,D,D]
				]
			}
		];
		break;
	}
	shellInfo.forEach(in_shell => {
		const radius = in_diameter / 2;
		const circumf = in_diameter * Math.PI;
		const unitSize = circumf / in_shell.table.length;
		const unitThick = unitSize * 0.3;
		const unitAngle = Math.PI * 2 / in_shell.table.length;
		const geometry = shellGeometryFactory.create(unitSize, ((radius - unitThick) / radius), unitThick);
		const pieces = [];
		const cols = in_shell.table.reduce((in_maxLen, in_row) => {
			return Math.max(in_maxLen, in_row.length);
		}, 0);
		for (let col = 0; col < cols; col++) {
			let x = unitSize * col - unitSize * (cols - 1) / 2;
			let y = (in_diameter / 2 - unitThick) * 1.2;
			for (let row = 0; row < in_shell.table.length; row++) {
				const color = in_shell.table[row][col];
				const materials = shellMaterials(unitSize, color, BGCOLOR, (color === D));
				materials.push(edgeMaterial);
				const piece = new THREE.Mesh(geometry, materials);
				const pivot = new THREE.Object3D();
				pivot.add(piece);
				piece.position.copy(VEC3(x, y, 0));
				pivot.rotateX(unitAngle * row);
				/*
					*** NOTE ***
					you can use matrix,
					to apply rotated position before adding to scene
				*/
				pivot.updateMatrixWorld();
				piece.applyMatrix4(pivot.matrix);
				pivot.remove(piece);
				pieces.push(piece);
			}
		}
		map.set(in_shell.name, pieces);
	});
	return map;
})(COLONY_SIZE);

/*
	the cBoard is designed to represent a reversi board.
*/

class cColonyBoard extends cColony {
	#makeRotationX(in_rad) {
		return this.settingVal.origin.clone().applyMatrix4((new THREE.Matrix4()).makeRotationX(in_rad));
	}
	indexToPiece(in_row, in_col) {
		const vec3 = this.#makeRotationX(this.settingVal.unitAngle * in_row);
		vec3.x += this.settingVal.unitDelta * in_col;
		const piece = this.children.find(in_child => XYZ.every(in_xyz => Math.abs(in_child.position[in_xyz] - vec3[in_xyz]) < cColony.error));
		if (!piece) {
			console.log('indexToPiece failed : ', in_row, in_col);
			throw new Error('');
		}
		return piece;
	}
	pieceToIndex(in_piece) {
		const pos = in_piece.position;
		const ret = {
			row : -1,
			col : -1
		};
		for (ret.row = 0; ret.row < this.settingVal.rowsForCircle; ret.row++) {
			const vec3 = this.#makeRotationX(this.settingVal.unitAngle * ret.row);
			if (Math.abs(vec3.y - pos.y) > cColony.error) {
				continue;
			}
			if (Math.abs(vec3.z - pos.z) > cColony.error) {
				continue;
			}
			ret.col = Math.round((pos.x - vec3.x) / this.settingVal.unitDelta);
			break;
		}
		const max = {
			row : this.settingVal.rowsForCircle - 1,
			col : this.settingVal.colsForLength - 1
		};
		if ((ret.row < 0) || (max.row < ret.row) || (ret.col < 0) || (max.col < ret.col)) {
			console.log('pieceToIndex failed : ', in_piece, ret);
			throw new Error('');
		}
		return ret;
	}
	getColorTable() {
		const table = [];
		for (let row = 0; row <  this.settingVal.rowsForCircle; row++) {
			table[row] = [];
			for (let col = 0; col < this.settingVal.colsForLength; col++) {
				const piece = this.indexToPiece(row, col);
				table[row].push(getShellColor(piece));
			}
		}
		return table;
	}
	changedPieces(in_table) {
		const changedArr = [];
		for (let row = 0; row < in_table.length; row++) {
			for (let col = 0; col < in_table[row].length; col++) {
				const piece = this.indexToPiece(row, col);
				const currColor = getShellColor(piece);
				const nextColor = in_table[row][col];
				if (currColor !== nextColor) {
					changedArr.push({
						piece : piece,
						curr : currColor,
						next : nextColor
					});
				}
			}
		}
		return changedArr;
	}
	makeRotateProgress(in_col, in_delta, in_ending_callback) {
		this.uiDisable();
		const last = this.settingVal.unitAngle * in_delta;
		const x = this.settingVal.origin.x + this.settingVal.unitDelta * in_col;
		const pieces = this.children.filter(in_child => Math.abs(in_child.position.x - x) < cColony.error);
		const group = this.setupGroup(pieces);
		return this.makeAnimationProgress(group, cColony.axes.x, 0, last, in_ratio => {
			if (in_ratio < 1) {
				return;
			}
			this.uiEnable();
			(in_ending_callback)();
		});
	}
}

/*
	gWorld (cSphericalWorld)
		|
		+-- gColony (cColonyBoard)
			|
			+-- gColony.children <--- gMeshLevelMap

	gController (cGameController) : knows the internal structure of the following instances
		|
		+-- gReversi (cReversi) : used for npc algorithm
		|
		+-- gColony : used for user interface
		|
		+-- gWorld : used for animation
*/

const gColony = new cColonyBoard();

const WORLD_RADIUS = COLONY_SIZE * 10;
const WORLD_INIT_ZOOM = WORLD_RADIUS / 2;

const gWorld = new cSphericalWorld(WORLD_RADIUS);
gWorld.add(gColony);
gWorld.moveView(0.5, 0.5);
gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);

let gController = null;
let gReversi = null;

class cGameController {
	static #UNUSED = -1;
	static PC = BLUE;
	static #NPC = [
		RED,
		YELLOW,
		GREEN,
		ORANGE,
		LIGHTBLUE,
		LIGHTGREEN
	];
	#mapping = new Array(10).fill(cGameController.#UNUSED);
	#turnHook = () => {};
	#curIndex = 0;
	#tableSize;
	enableHandler = false;
	// cGameController knows the internal structure of cColonyBoard, cReversi and cSphericalWorld
	constructor(in_playerCnt, in_pc = 0) {
		const colors = Array.from(cGameController.#NPC);
		for (let i = 0; i < in_playerCnt; i++) {
			let color;
			if (i === in_pc) {
				color = cGameController.PC;
			} else {
				color = colors.shift();
			}
			this.#mapping[i] = color;
		}
		// 8, 9 are declared as follows in cReversi
		this.#mapping[8] = DMZCOLOR;
		this.#mapping[9] = EMPTYCOLOR;
		this.setTableSize(-1, -1);
	}
	setTableSize(in_rows, in_cols) {
		// as cColonyBoard and cReversi may not have the same rows and cols, in_rows and in_cols are needed.
		this.#tableSize = {
			rows : in_rows,
			cols : in_cols
		};
	}
	setTurnHook(in_hook) {
		this.#turnHook = in_hook;
	}
	#execTurnHook() {
		const color = this.#mapping[this.#curIndex];
		this.enableHandler = (color === cGameController.PC);
		(this.#turnHook)(this.#curIndex, color, this.enableHandler);
	}
	#incrementIndex() {
		this.#curIndex++;
		if (this.#mapping[this.#curIndex] === cGameController.#UNUSED) {
			this.#curIndex = 0;
		}
	}
	endTurn(in_reversi = null) {
		this.#incrementIndex();
		const cond = in_reversi.getCurrentCondition();
		if (cond.finished) {
			// all players can not do anything
			const winner = cond.players.reduce((in_accum, in_curVal, in_curIndex, in_arr) => {
				return in_curVal.score > in_arr[in_accum].score ? in_curIndex : in_accum;
			}, 0);
			return this.#mapping[winner];
		} else {
			while (true) {
				const {dead, frozen, score} = cond.players[this.#curIndex];
				if (dead || (frozen && !in_reversi.canRowWiseLoop())) {
					// curIndex can not do anything
					this.#incrementIndex();
				} else {
					break;
				}
			}
			// to prevent stack overflow
			window.setTimeout(() => {
				this.#execTurnHook();
			}, 0);
			// in this context, no winner
			return -1;
		}
	}
	start() {
		this.#execTurnHook();
	}
	end() {
		this.setTurnHook(() => {});
		this.#mapping.fill(cGameController.#UNUSED);
	}
	static #update(in_changedArr) {
		in_changedArr.forEach(in_changed => {
			setShellColor(in_changed.piece, in_changed.next);
		});
	}
	static #updateDynamic(in_changedArr, in_world) {
		// in_changedArr : see cColonyBoard.changedPieces()
		in_changedArr.forEach(in_changed => {
			// backup initial value
			in_changed.initRotationX = in_changed.piece.rotation.x;
		});
		const ease = new cEase(0, Math.PI * 2, 500);
		return new Promise(in_resolved => {
			let updated = false;
			const hook = () => {
				const angle = ease.currentEasingOut();
				if (angle === Math.PI * 2) {
					in_world.removeAnimationHook(hook);
					in_changedArr.forEach(in_changed => {
						// restore initial value
						in_changed.piece.rotation.x = in_changed.initRotationX;
					});
					/*
						execute the process that follows the await (or callback defined in then),
						which corresponds to the then block of a promise
					*/
					(in_resolved)();
					return;
				}
				if ((angle > Math.PI) && (!updated)) {
					SE_MOVED.play();
					cGameController.#update(in_changedArr);
					updated = true;
				}
				in_changedArr.forEach(in_changed => {
					in_changed.piece.rotation.x = in_changed.initRotationX + angle;
				});
			};
			in_world.addAnimationHook(hook);
		});
	}
	#makeChangedArr(in_reversi, in_colony) {
		const indexTable = in_reversi.getTable();
		const colorTable = indexTable.map(in_row => in_row.map(in_cell => this.#mapping[in_cell]));
		// this can handle smaller table than colony
		return in_colony.changedPieces(colorTable);
	}
	reversiToColony(in_reversi, in_colony) {
		const changedArr = this.#makeChangedArr(in_reversi, in_colony);
		cGameController.#update(changedArr);
	}
	async reversiToColonyDynamic(in_reversi, in_colony, in_world) {
		const changedArr = this.#makeChangedArr(in_reversi, in_colony);
		await cGameController.#updateDynamic(changedArr, in_world);
	}
	convertColonyTable(in_colony) {
		const reverse = {};
		this.#mapping.forEach((in_value, in_ix) => {
			reverse[in_value] = in_ix;
		});
		let table = in_colony.getColorTable();
		if ((this.#tableSize.rows > 0) && (this.#tableSize.cols > 0)) {
			// resize to #tableSize
			table = table.slice(0, this.#tableSize.rows).map(in_row => in_row.slice(0, this.#tableSize.cols));
		}
		return table.map(in_row => in_row.map(in_cell => reverse[in_cell]));
	}
	async moveViewTo(in_piece, in_world) {
		const cameraPos = in_world.getCameraPos();
		const angleX = Math.atan2(cameraPos.y, cameraPos.z) - Math.atan2(in_piece.position.y, in_piece.position.z);
		const vec3 = cameraPos.applyMatrix4((new THREE.Matrix4()).makeRotationX(angleX));
		await in_world.motionViewFrom(vec3, 500);
	}
	async #playLastAction(in_reversi, in_colony, in_world) {
		const last = in_reversi.getLast();
		switch (last.action) {
		case 'choose-item' :
			const piece = in_colony.indexToPiece(last.row, last.col);
			await this.moveViewTo(piece, in_world);
			// choose
			setShellColor(piece, this.#mapping[last.who]);
			await this.reversiToColonyDynamic(in_reversi, in_colony, in_world);
			break;
		case 'npc-row-wise-rotate' :
			console.log('rotating', last);
			await (async ()=> {
				return new Promise(in_resolve => {
					const hook = in_colony.makeRotateProgress(last.target, last.delta, () => {
						in_world.removeAnimationHook(hook);
						(in_resolve)();
					});
					in_world.addAnimationHook(hook);
				});
			})();
			break;
		default :
			break;
		}
	}
	async npc(in_reversi, in_colony, in_world) {
		if (in_reversi.npc(this.#curIndex)) {
			await this.#playLastAction(in_reversi, in_colony, in_world);
			return true;
		} else {
			// can't do anything
			return false;
		}
	}
	async pc(in_piece, in_reversi, in_colony, in_world) {
		const resume = this.enableHandler;
		this.enableHandler = false;
		const pos = in_colony.pieceToIndex(in_piece);
		const result = in_reversi.pc(this.#curIndex, pos.row, pos.col);
		if (result) {
			SE_BEEP.play();
			await this.#playLastAction(in_reversi, in_colony, in_world);
		}
		this.enableHandler = resume;
		return result;
	}
	pcRotate(in_reversi, in_colony) {
		const table = this.convertColonyTable(in_colony);
		in_reversi.setActionResult(this.#curIndex, 'pc-row-wise-rotate', table);
	}
}

class cWarpLine {
	static #speed = 10;
	static #gradation = 10;
	constructor(in_canvas) {
		const w = in_canvas.width;
		const h = in_canvas.height;
		this.ctx = in_canvas.getContext('2d');
		this.box = new THREE.Box2(
			new THREE.Vector2(0, 0),
			new THREE.Vector2(w, h)
		);
		this.from = new THREE.Vector2(w / 2, h / 2);
		this.#reset();
	}
	#reset() {
		const angle = Math.random() * Math.PI * 2;
		this.direction = new THREE.Vector2(Math.cos(angle), Math.sin(angle));
		this.speed = Math.random() * cWarpLine.#speed + 5;
		this.length = 0;
	}
	#curVec(in_scalar) {
		return this.from.clone().add(this.direction.clone().multiplyScalar(in_scalar));
	}
	#drawGrayLine(in_from, in_to, in_grayScale) {
		const gray = (in_grayScale << 16) | (in_grayScale << 8) | in_grayScale;
		this.ctx.strokeStyle = '#' + gray.toString(16).padStart(6, '0');
		this.ctx.beginPath();
		this.ctx.moveTo(in_from.x, in_from.y);
		this.ctx.lineTo(in_to.x, in_to.y);
		this.ctx.stroke();
	}
	update() {
		this.length += this.speed;
		const to = this.#curVec(this.length);
		if (this.box.containsPoint(to)) {
			const notch = this.length / cWarpLine.#gradation;
			for (let i = 0; i < cWarpLine.#gradation; i++) {
				this.#drawGrayLine(
					this.#curVec(notch * i),
					this.#curVec(notch * (i + 1)),
					255 / cWarpLine.#gradation * (i + 1)
				);
			}
		} else {
			/*
				*** NOTE ***
				even if overwritung using black,
				this.#drawGrayLine(this.from, to, 0x00);
				smudge of white line will remain.
			*/
			this.#reset();
		}
	}
}

function warpViewProgress(in_canvas, in_lineCount) {
	const warpLines = [];
	for (let i = 0; i < in_lineCount; i++) {
		warpLines.push(new cWarpLine(in_canvas));
	}
	return () => {
		warpLines.forEach(in_line => {
			in_line.update();
		});
	}
}

function complete(in_player) {
	gController.end();
	gOrderChar.style.visibility = 'hidden';
	const progress = warpViewProgress(gBackgroundCanvas, 50);
	gWorld.addAnimationHook(progress);
	const duration = 2000;
	gWorld.motionZoom2(WORLD_RADIUS * 1.5, duration * 0.9);
	window.setTimeout(() => {
		gWorld.removeAnimationHook(progress);
		const dialog = document.createElement('div');
		Object.assign(dialog.style, {
			width : 'auto',
			height : 'auto',
			background : 'black',
			borderRadius : '1em',
			padding : '1.5em'
		});
		([
			'<div>Winner is ...</div>',
			'<div style="text-align:center"><img src="' + RES.get(in_player) + '" /></div>',
			'<div>Thanks to your wisdom, peace in the universe has been preserved.</div>',
			'<div>Click to go next stage.</div>',
		]).forEach(in_fragment => {
			dialog.innerHTML += in_fragment;
		});
		setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white');
		startDialog(dialog, async () => {
			drawCosmicView(gBackgroundCanvas, 400, 50);
			await nextLevel(false);
			gWorld.motionZoom2(WORLD_INIT_ZOOM, 1000);
		});
	}, duration);
}

const gOrderChar = (() => {
	const elem = document.createElement('IMG');
	const maxInt = 2 ** 31 - 1;
	Object.assign(elem.style, {
		position : 'absolute',
		bottom : '20px',
		right : '20px',
		width : '100px',
		height : 'auto',
		zIndex : maxInt
	});
	document.body.appendChild(elem);
	return elem;
})();

function initializeByLevel() {
	const curr = gMeshLevelMap.currItemByOrder();
	const [level, loop] = curr.k.split('-');
	const rowEdge = !loop;
	const [rows, cols, players] = level.split('x');
	const pc = 0;
	gController = new cGameController(players, pc);
	gController.setTableSize(rows, cols);
	const table = gController.convertColonyTable(gColony);
	gReversi = new cReversi(table, rowEdge, true);
	gController.setTurnHook(async (in_player, in_color, in_pc) => {
		gOrderChar.style.visibility = 'visible';
		gOrderChar.src = RES.get(in_color);
		if (in_pc) {
			const last = gReversi.getLast({who : pc, action : 'choose-item'});
			if (last) {
				const piece = gColony.indexToPiece(last.row, last.col);
				await gController.moveViewTo(piece, gWorld);
			}
			return;
		}
		const acted = await gController.npc(gReversi, gColony, gWorld);
		const winner = gController.endTurn(gReversi);
		if (winner < 0) {
			return;
		}
		complete(winner);
	});
	gController.reversiToColony(gReversi, gColony);
	gController.start();
}

(in_level => {
	if (in_level === false) {
		gMeshLevelMap.setOrder(2);
	} else {
		gMeshLevelMap.setOrder(in_level);
	}
})(getParam('level'));

const ID_PREV_LEVEL = randomString();
const ID_NEXT_LEVEL = randomString();

async function updateLevel() {
	const color = 0x000000;
	await gWorld.motionFog(color, 0, 100);
	gColony.removePieces();
	const current = gMeshLevelMap.currItemByOrder();
	gColony.addPieces(current.v);
	await gWorld.motionFog(color, 100, 0);
	const prev = gMeshLevelMap.prevItemByOrder();
	const next = gMeshLevelMap.nextItemByOrder();
	document.getElementById(ID_PREV_LEVEL).innerText = prev.k;
	document.getElementById(ID_NEXT_LEVEL).innerText = next.k;
	resetFocus();
	initializeByLevel();
}

updateLevel();

/*
	*** NOTE ***
	in Safari, using await to get audio will cause the process to fail.
	I'm not sure of the reason, but top-level await might be the cause.
	this time use then() to avoid the issue.
*/

let SE_BEEP = beep(2000);
let SE_DUMMY = beep(10);
let SE_MOVED = SE_BEEP;
let SE_ERROR = SE_BEEP;

SOUND.MOVED.then(in_decompress => {
	SE_MOVED = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

SOUND.ERROR.then(in_decompress => {
	SE_ERROR = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

function setTransition(in_elem, in_shorthand, in_val1, in_val2) {
	const components = in_shorthand.split(/\s+/);
	in_elem.style.transition = in_shorthand;
	in_elem.style[components[0]] = in_val1;
	window.setTimeout(() => {
		/*
			*** NOTE ***
			to fire the transition function,
			the final style should be set in the next event loop.
		*/
		in_elem.style[components[0]] = in_val2;
	}, 0);
}

function startDialog(in_element, in_callback = null) {
	const maxInt = 2 ** 31 - 1;
	const background = document.createElement('div');
	Object.assign(background.style, {
		position : 'fixed',
		left : '0px',
		top : '0px',
		width : '100%',
		height : '100%',
		zIndex : maxInt
	});
	background.appendChild(in_element);
	Object.assign(in_element.style, {
		position : 'absolute',
		left : '50%',
		top : '50%',
		transform : 'translate(-50%, -50%)'
	});
	document.body.appendChild(background);
	const closeDialog = () => {
		document.body.removeChild(background);
		if (in_callback) {
			(in_callback)();
		}
	};
	background.addEventListener('mousedown', closeDialog);
	background.addEventListener('touchstart', closeDialog);
}

function uiHelp() {
	const url = {
		ver : './version.txt',
		im1 : 'https://pj-corridor.net/images/cube-2-03.png',
		im2 : 'https://pj-corridor.net/images/diamond-2-4.png',
		im3 : 'https://pj-corridor.net/images/cube-6-03.png',
		im4 : 'https://pj-corridor.net/images/diamond-6-4.png',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div>';
	[url.im1, url.im2, url.im3, url.im4].forEach(in_img => {
		dialog.innerHTML += '<img width="100" src="' + in_img + '" />';
	});
	dialog.innerHTML += '</div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getVersion(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.log(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Rights</dt>',
		'<dd>This software is based on MIT License.</dd>',
		'<dd>The code can be freely modified and reused.</dd>',
		'<dd>For full license details, please refer to :</dd>',
		'<dd>https://opensource.org/licenses/MIT</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white')
	startDialog(dialog);
}

async function prevLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	gMeshLevelMap.shiftOrder(-1);
	await updateLevel();
}

async function nextLevel(in_sound = true) {
	if (in_sound) {
		SE_BEEP.play();
	}
	gMeshLevelMap.shiftOrder(+1);
	await updateLevel();
}

(in_settings => {
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	in_settings.forEach(in_setting => {
		let button = document.createElement('button');
		if (in_setting.id) {
			button.id = in_setting.id;
		}
		if (in_setting.text) {
			button.innerText = in_setting.text;
		}
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})([
	{
		id : ID_PREV_LEVEL,
		text : '(Prev)',
		func : prevLevel
	},
	{
		id : ID_NEXT_LEVEL,
		text : '(Next)',
		func : nextLevel
	},
	{
		text : 'help',
		func : uiHelp
	},
	{
		text : 'rights',
		func : uiRights
	}
]);

function hex2rgb(in_hex) {
	const mask = 0xFF;
	const r = (in_hex >> 16) & mask;
	const g = (in_hex >> 8) & mask;
	const b = in_hex & mask;
	return [r, g, b];
}

function drawCosmicView(in_canvas, in_stars, in_nebulae_patterns, in_color = 0x000064) {
	const ctx = in_canvas.getContext('2d');
	const w = in_canvas.width;
	const h = in_canvas.height;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	for (let i = 0; i < in_nebulae_patterns; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 100 + 50;
		const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
		const rgb = hex2rgb(in_color);
		gradient.addColorStop(0, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0.5)');
		gradient.addColorStop(1, 'rgba('+ rgb[0] +', '+ rgb[1] +', '+ rgb[2] +', 0)');
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = gradient;
		ctx.fill();
	}
	for (let i = 0; i < in_stars; i++) {
		const x = Math.random() * w;
		const y = Math.random() * h;
		const radius = Math.random() * 1;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, false);
		ctx.fillStyle = 'white';
		ctx.fill();
	}
}

/*
	event handlers
*/

const gBackgroundCanvas = document.createElement('CANVAS');

Object.assign(gBackgroundCanvas.style, {
	position : 'absolute',
	left : 0,
	top : 0,
	zIndex : -1
});

document.addEventListener('DOMContentLoaded', (() => {
	let resizeWorld = in_ev => {
		gWorld.resize(
			window.innerWidth,
			window.innerHeight);
		gBackgroundCanvas.width = window.innerWidth;
		gBackgroundCanvas.height = window.innerHeight;
		drawCosmicView(gBackgroundCanvas, 400, 50);
	};
	window.addEventListener('resize', debouncing(resizeWorld, 300));
	window.dispatchEvent(new Event('resize'));
	if (!document.body) {
		document.documentElement.appendChild(document.createElement('BODY'));
	}
	Object.assign(document.body.style, {
		margin : '0',
		overflow : 'hidden'
	});
	document.body.appendChild(gWorld.canvas);
	document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

const knock = nonReentrantAsync(async () => {
	SE_ERROR.play();
	await gWorld.motionKnock();
});

const notifyDelta = (() => {
	const RC = cColony.uiSetDeltaPositionRC;
	return in_ndc => {
		const intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length === 0) {
			return;
		}
		const result = gColony.uiNotifyDeltaPosition(intersects[0].object, intersects[0].point, ndcToAbs(in_ndc));
		if (result === RC.UNMOVABLE) {
			knock();
		}
	}
})();

const focusHere = (() => {
	let focusedEmpty = null;
	const HIGHLIGHT = (new THREE.Color(EMPTYCOLOR)).lerp(new THREE.Color(0xFFFFFF), 0.3).getHex();
	return in_ndc => {
		let current, color;
		let intersects = gWorld.intersectPositive(in_ndc);
		if (intersects.length > 0) {
			current = intersects[0].object;
			color = getShellColor(current);
		} else {
			current = null;
			color = -1;
		}
		if ((color === EMPTYCOLOR) || (color === HIGHLIGHT)) {
			if (current === focusedEmpty) {
				return;
			}
			setShellColor(current, HIGHLIGHT);
			if (focusedEmpty) {
				setShellColor(focusedEmpty, EMPTYCOLOR);
			}
			focusedEmpty = current;
		} else {
			if (focusedEmpty) {
				setShellColor(focusedEmpty, EMPTYCOLOR);
			}
			focusedEmpty = null;
		}
	}
})();

function resetFocus() {
	const outOfRange = new THREE.Vector2(Infinity, Infinity);
	focusHere(outOfRange);
}

function rotateDone() {
	resetFocus();
	gController.pcRotate(gReversi, gColony);
	gController.endTurn(gReversi);
}

async function chooseHere(in_ev) {
	const ndc = ndcFromEvent(in_ev);
	let intersects = gWorld.intersectPositive(ndc);
	if (intersects.length === 0) {
		return;
	}
	resetFocus();
	const curr = intersects[0].object;
	if (getShellColor(curr) !== EMPTYCOLOR) {
		knock();
	} else {
		if (await gController.pc(curr, gReversi, gColony, gWorld)) {
			const winner = gController.endTurn(gReversi);
			if (winner < 0) {
				return;
			}
			complete(winner);
		} else {
			knock();
		}
	}
}

(() => {
	const closure = {
		x : -1,
		y : -1,
		once : false
	};
	const start = in_ev => {
		if (!closure.once) {
			/*
				*** NOTE ***
				Safari may restrict sound without user interaction.
				because of this, the sound does not work without this code.
			*/
			SE_DUMMY.play();
			closure.once = true;
		}
		const ndc = ndcFromEvent(in_ev);
		const intersects = gWorld.intersectPositive(ndc);
		if (intersects.length === 0) {
			return;
		}
		resetFocus();
		closure.x = in_ev.clientX;
		closure.y = in_ev.clientY;
		// can drag only cGameController.PC
		const drag = intersects[0].object
		if (gReversi.canRowWiseLoop() && (getShellColor(drag) === cGameController.PC)) {
			gColony.uiSetInitPosition(intersects[0].point, ndcToAbs(ndc));
		}
	};
	const move = thresholding(in_ev => {
		closure.x = -1;
		closure.y = -1;
		const ndc = ndcFromEvent(in_ev);
		if (gColony.uiIsMoving()) {
			if (gColony.uiUpdatePosition(ndcToAbs(ndc))) {
				SE_MOVED.play();
			}
		} else {
			if (gColony.uiIsDragging()) {
				notifyDelta(ndc);
			} else {
				if (!in_ev[isEmulated]) {
					focusHere(ndc);
				}
			}
		}
	});
	const stop = in_ev => {
		const releaseProgress = gColony.uiRelease(in_changed => {
			gWorld.removeAnimationHook(releaseProgress);
			if (in_changed) {
				rotateDone();
			}
		});
		if (releaseProgress) {
			gWorld.addAnimationHook(releaseProgress);
		} else {
			if ((closure.x !== in_ev.clientX) || (closure.y !== in_ev.clientY)) {
				return;
			}
			chooseHere(in_ev);
		}
	};
	let handlers = {
		'mousedown' : start,
		'mousemove' : move,
		'mouseleave' : stop,
		'mouseout' : stop,
		'mouseup' : stop
	};
	for (let [name, func] of Object.entries(handlers)) {
		gWorld.canvas.addEventListener(name, in_ev => {
			if (gController && gController.enableHandler) {
				(func.bind(this))(in_ev);
			}
		});
	}
})();

</script>
</body>
</html>
