<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports" : {
		"three" : "https://cdn.jsdelivr.net/npm/three@0.181.2/build/three.module.min.js",
		"utils" : "https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/utils/BufferGeometryUtils.js",
		"modif" : "https://cdn.jsdelivr.net/npm/three-subdivide@1.1.5/build/index.module.min.js",
		"basic" : "./basic-functions.js",
		"sound" : "./sound-effect.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';
import {
	LoopSubdivision
} from 'modif';
import {
	getResource,
	postResource,
	getParam,
	DEBUG,
	COLOR,
	randomString,
	snapToNotch,
	snapToPI,
	snapTo05PI,
	createPeriodicSin,
	createPeriodicCos,
	pseudoMessageDigest1,
	pseudoMessageDigest2,
	beep,
	isEmulated,
	throttling,
	thresholding,
	debouncing,
	nonReentrantAsync,
	autoTransition,
	makeSpeaker,
	startDialog,
	factoryBuilder,
	arrRand,
	arrTrim,
	cEase,
	cApproximateMap,
	cApproximateSet,
	cCyclicMap,
	cCyclicValues,
	forEachCombination,
	cChart,
	clipArea,
	clipClearArea,
	fillRoundRect,
	XYZ,
	VEC3,
	DIRECTION,
	ndcFromEvent,
	ndcToAbs,
	getWorldVec3,
	getWorldUp,
	instanceInAncestor,
	lookAtWithoutRotation,
	safeMergeGeometry,
	makeTrapezoidGeometryParts,
	trapezoidGeometryUtil,
	roundBoxGeometry,
	roundRegularBoxGeometry,
	roundTrapezoidGeometry,
	capsuleConfigure,
	customCapsuleGeometry,
	cSphericalWorld
} from 'basic';
import * as SOUND from 'sound';

/*
	(1) cAbstractPart

	SkinnedMesh
	|
	+-- in_geometry
	|
	+-- receiver to get raycast after bent ( not visible )
	|	|
	|	+-- ExtrudeGeometry
	|
	+-- receiver to bend ( not visible )
		|
		+-- SphereGeometry
		|
		+-- CircleGeometry for positive side
		|
		+-- CircleGeometry doe negative side
*/

class cAbstractPart extends THREE.SkinnedMesh {
	static #debug = false;
	static #materialVisible = new THREE.MeshNormalMaterial();
	static #materialOpacity = new THREE.MeshNormalMaterial({transparent : true, opacity : 0.3});
	static #cacheKeys = {
		BOUNDING_BOX : Symbol(),
		DRAGGING_POS : Symbol(),
		RCV_DRAGGING : Symbol(),
		RCV_RELEASED : Symbol(),
		INTERLOCKING : Symbol()
	};
	static operatingLayer = 1;
	static #activateReceiver(in_receiver, in_activate) {
		if (in_activate) {
			in_receiver.raycast = THREE.Mesh.prototype.raycast;
			if (cAbstractPart.#debug) {
				in_receiver.visible = true;
			}
		} else {
			in_receiver.raycast = () => {};
			if (cAbstractPart.#debug) {
				in_receiver.visible = false;
			}
		}
	}
	static #getLength(in_box) {
		return in_box.max.y - in_box.min.y;
	}
	static #getCircumfRect(in_box) {
		return {
			w : in_box.max.x - in_box.min.x,
			h : in_box.max.z - in_box.min.z
		};
	}
	get #length() {
		return cAbstractPart.#getLength(this.#getCache('BOUNDING_BOX'));
	}
	get #circumfRect() {
		return cAbstractPart.#getCircumfRect(this.#getCache('BOUNDING_BOX'));
	}
	#getCache(in_key) {
		return this.userData[cAbstractPart.#cacheKeys[in_key]];
	}
	#setCache(in_key, in_value) {
		this.userData[cAbstractPart.#cacheKeys[in_key]] = in_value;
	}
	static #makeSkeleton(in_boneCnt, in_notch) {
		const bones = [];
		for (let i = 0; i < in_boneCnt; i++) {
			bones[i] = new THREE.Bone();
			if (i > 0) {
				bones[i].position.z = in_notch;
				bones[i - 1].add(bones[i]);
			}
		}
		return new THREE.Skeleton(bones);
	}
	static #setSkin(in_geometry, in_notch) {
		const skin = {
			indices : [],
			weights : []
		};
		for (let i = 0; i < in_geometry.attributes.position.count; i++) {
			const posV3 = (new THREE.Vector3()).fromBufferAttribute(in_geometry.attributes.position, i);
			const boneIndex = Math.round(posV3.z / in_notch);
			skin.indices.push(boneIndex, -1, -1, -1);
			skin.weights.push(1, 0, 0, 0);
		}
		in_geometry.setAttribute('skinIndex', new THREE.Uint16BufferAttribute(skin.indices, 4));
		in_geometry.setAttribute('skinWeight', new THREE.Float32BufferAttribute(skin.weights, 4));
	}
	#configureDraggingRcv() {
		const parts = [];
		const receivingRatio = 3;
		parts.push(new THREE.CircleGeometry(this.#length * receivingRatio));
		/*
			*** NOTE ***
			as CircleGeometry can't catch raycast from opposite side,
			use rotated CircleGeometry in addition.
		*/
		parts.push((new THREE.CircleGeometry(this.#length * receivingRatio)).rotateX(Math.PI));
		parts.push(new THREE.SphereGeometry(this.#length));
		const mesh = new THREE.Mesh(safeMergeGeometry(parts), cAbstractPart.#materialOpacity);
		mesh.visible = false;
		mesh.layers.set(cAbstractPart.operatingLayer);
		this.#setCache('RCV_DRAGGING', mesh);
		this.add(mesh);
	}
	#configureReleasedRcv() {
		const geometry = this.#makeRoughGeometry();
		const mesh = new THREE.Mesh(geometry, cAbstractPart.#materialVisible);
		mesh.visible = false;
		this.#setCache('RCV_RELEASED', mesh);
		this.add(mesh);
	}
	#configureReceiver() {
		this.#configureDraggingRcv();
		this.#configureReleasedRcv();
	}
	resetDraggingRcv() {
		/*
			*** NOTE ***
			cached DRAGGING_POS should be cloned.
			it should not be changed during dragging.
		*/
		const dragging = this.#getCache('RCV_DRAGGING');
		dragging.lookAt(this.#getCache('DRAGGING_POS'));
	}
	activateDraggingRcv(in_vec3) {
		// RCV_DRAGGING : ON
		const dragging = this.#getCache('RCV_DRAGGING');
		cAbstractPart.#activateReceiver(dragging, true);
		this.#setCache('DRAGGING_POS', in_vec3.clone());
		this.resetDraggingRcv();
		// RCV_RELEASED : OFF
		const released = this.#getCache('RCV_RELEASED');
		cAbstractPart.#activateReceiver(released, false);
	}
	activateReleasedRcv() {
		// RCV_DRAGGING : OFF
		const dragging = this.#getCache('RCV_DRAGGING');
		cAbstractPart.#activateReceiver(dragging, false);
		// RCV_RELEASED : ON
		const released = this.#getCache('RCV_RELEASED');
		cAbstractPart.#activateReceiver(released, true);
		/*
			*** NOTE ***
			vertices of SkinnedMesh.geometry will not be changed after moving bones.
			because of it, SkinnedMesh.geometry can't catch raycasting properly.
			so, to catch raycasting, rough formed geometry is attached.
		*/
		released.geometry.dispose();
		released.geometry = this.#makeRoughGeometry();
	}
	constructor(in_geometry, in_boneCnt) {
		/*
			*** NOTE ***
			as in_geometry may not have parameters.height, boundingBox is needed.
			in addition, without clone(), boundingBox will be changed after rotateX().
			to #makeRoughGeometry(), and to moreShrink(), boundingBox will be used.
		*/
		in_geometry.computeBoundingBox();
		const box = in_geometry.boundingBox.clone();
		const length = cAbstractPart.#getLength(box);
		/*
			when using lookAt() / bendAt(),
			make the direction of bones be afected.
			as a default, object is set as lookAt(0, 0, 1) of local coordinate

			object (before) :

			     y    
			     |   /
			     |  /
			     | /
			    ###
			 ---#*#---x
			    /##
			   / |
			  /  |
			 /
			z : lookAt(0, 0, 1)

			object (after) :

			     y
			     |  /
			     | /
			     |/
			 ---#*#---x
			   ###
			  ###|
			  /  |
			 /
			z : lookAt(0, 0, 1)
		*/
		in_geometry.translate(0, length / 2, 0);
		in_geometry.rotateX(Math.PI / 2);
		/*
			as bone does not have length, but it is a point, ...
			+---+---+---+---+ : in_boneCnt = 5 ( segument count = 4 )
		*/
		const notch = length / (in_boneCnt - 1);
		const skeleton = cAbstractPart.#makeSkeleton(in_boneCnt, notch);
		cAbstractPart.#setSkin(in_geometry, notch);
		if (cAbstractPart.#debug) {
			super(in_geometry, cAbstractPart.#materialOpacity);
		} else {
			super(in_geometry, cAbstractPart.#materialVisible);
		}
		this.#setCache('BOUNDING_BOX', box);
		this.#setCache('INTERLOCKING', Symbol());
		this.add(skeleton.bones[0]);
		this.bind(skeleton);
		this.#configureReceiver();
		this.activateReleasedRcv();
	}
	get #interlockings() {
		const objects = [this];
		this.skeleton.bones.forEach(in_bone => {
			in_bone.children.forEach(in_child => {
				if (in_child.userData.group === this.#getCache('INTERLOCKING')) {
					objects.push(in_child);
				}
			});
		});
		return objects;
	}
	cloneGeometry(in_local = true) {
		const parts = [];
		this.#interlockings.forEach(in_obj => {
			let part;
			if ((in_obj instanceof cAbstractPart) && in_obj.isBent()) {
				part = in_obj.makeBentGeometry();
			} else {
				part = in_obj.geometry.clone();
			}
			const keep = ['position', 'normal'];
			for (const attribute in part.attributes) {
				if (!keep.includes(attribute)) {
					part.deleteAttribute(attribute);
				}
			}
			part.applyMatrix4(in_obj.matrixWorld);
			parts.push(part);
		});
		const merged = safeMergeGeometry(parts);
		if (in_local) {
			merged.applyMatrix4(new THREE.Matrix4().copy(this.matrixWorld).invert());
		}
		return merged;
	}
	resetMaterial(in_material) {
		this.#interlockings.forEach(in_obj => {
			in_obj.material = in_material;
		});
	}
	get #boneCnt() {
		return this.skeleton.bones.length;
	}
	#boneWorldPosition(in_index) {
		const bones = this.skeleton.bones;
		return bones[in_index].getWorldPosition(VEC3());
	}
	#boneAnchorWorldPosition() {
		return this.#boneWorldPosition(0);
	}
	#boneMovingWorldPosition() {
		return this.#boneWorldPosition(this.#boneCnt - 1);
	}
	#updatedBentBones(in_dstV3) {
		const updated = in_dstV3 ? true : false;
		const anchor = this.#boneAnchorWorldPosition();
		const moving = this.#boneMovingWorldPosition();
		let delta = VEC3();
		if (updated) {
			delta = delta.subVectors(in_dstV3, moving);
		}
		const bent = {
			posArr : [],
			dirArr : []
		};
		for (let i = 0; i < this.#boneCnt; i++) {
			const boneSrcV3 = this.#boneWorldPosition(i);
			if (updated) {
				const factor = i / (this.#boneCnt - 1);
				const boneDelta = (VEC3()).lerp(delta, factor ** 2);
				bent.posArr[i] = boneSrcV3.add(boneDelta);
			} else {
				bent.posArr[i] = boneSrcV3;
			}
			if (i === 0) {
				bent.dirArr[i] = (VEC3()).subVectors(moving, anchor).normalize();
			} else {
				bent.dirArr[i] = (VEC3()).subVectors(bent.posArr[i], bent.posArr[i - 1]).normalize();
			}
		}
		return bent;
	}
	#currentBentBones() {
		return this.#updatedBentBones(null);
	}
	#makeRoughGeometry() {
		const thickness = 0.5;
		// shape
		const w = this.#circumfRect.w * thickness;
		const h = this.#circumfRect.w * thickness;
		const shape = new THREE.Shape();
		shape.moveTo(w / 2 * -1, h / 2 * -1);
		shape.lineTo(w / 2 * +1, h / 2 * -1);
		shape.lineTo(w / 2 * +1, h / 2 * +1);
		shape.lineTo(w / 2 * -1, h / 2 * +1);
		shape.lineTo(w / 2 * -1, h / 2 * -1);
		// path
		const bent = this.#currentBentBones();
		const inverse = new THREE.Matrix4();
		inverse.copy(this.matrixWorld).invert();
		bent.posArr.map(in_pos => {
			return in_pos.applyMatrix4(inverse);
		});
		const path = new THREE.CatmullRomCurve3(bent.posArr);
		// extrude
		const extrudeSettings = {
			steps : Math.max(5, Math.ceil((this.#boneCnt - 1) / 5)),
			bevelEnabled : false,
			extrudePath : path
		};
		return new THREE.ExtrudeGeometry(shape, extrudeSettings);
	}
	makeBentGeometry() {
		const attr = this.geometry.attributes;
		const toLocalPos = new THREE.Matrix4().copy(this.matrixWorld).invert();
		const toLocalNrm = new THREE.Matrix3().getNormalMatrix(this.matrixWorld).invert();
		const dstPosArr = new Float32Array(attr.position.count * 3);
		const dstNrmArr = new Float32Array(attr.normal.count * 3);
		for (let i = 0; i < attr.position.count; i++) {
			const dstPos = VEC3();
			const dstNrm = VEC3();
			const tmpPos = VEC3().fromBufferAttribute(attr.position, i);
			const tmpNrm = VEC3().fromBufferAttribute(attr.normal, i);
			const indices = new THREE.Vector4().fromBufferAttribute(attr.skinIndex, i);
			const weights = new THREE.Vector4().fromBufferAttribute(attr.skinWeight, i);
			for (let j = 0; j < 4; j++) {
				const weight = weights.getComponent(j);
				if (weight === 0) {
					continue;
				}
				const boneMatrix = new THREE.Matrix4().fromArray(this.skeleton.boneMatrices, indices.getComponent(j) * 16);
				dstPos.addScaledVector(tmpPos.applyMatrix4(boneMatrix), weight);
				const transformed = tmpNrm.applyMatrix3(new THREE.Matrix3().getNormalMatrix(boneMatrix)).normalize();
				dstNrm.addScaledVector(transformed, weight);
			}
			dstPos.applyMatrix4(toLocalPos);
			dstPosArr[i * 3 + 0] = dstPos.x;
			dstPosArr[i * 3 + 1] = dstPos.y;
			dstPosArr[i * 3 + 2] = dstPos.z;
			dstNrm.applyMatrix3(toLocalNrm);
			dstNrmArr[i * 3 + 0] = dstNrm.x;
			dstNrmArr[i * 3 + 1] = dstNrm.y;
			dstNrmArr[i * 3 + 2] = dstNrm.z;
		}
		const bentGeometry = new THREE.BufferGeometry();
		bentGeometry.setAttribute('position', new THREE.BufferAttribute(dstPosArr, 3));
		bentGeometry.setAttribute('normal', new THREE.BufferAttribute(dstNrmArr, 3));
		bentGeometry.setIndex(this.geometry.index);
		return bentGeometry;
	}
	isBent() {
		const bones = this.skeleton.bones;
		const anchor = bones[0];
		const moving = bones[bones.length - 1];
		return (anchor.position.x != moving.position.x) || (anchor.position.y != moving.position.y);
	}
	bendAt(in_dstV3) {
		const bones = this.skeleton.bones;
		const updated = this.#updatedBentBones(in_dstV3);
		for (let i = 1; i < bones.length; i++) {
			const destV3 = updated.posArr[i].clone().add(updated.dirArr[i].multiplyScalar(this.#length));
			bones[i][lookAtWithoutRotation](destV3);
			bones[i].position.copy(bones[i].parent.worldToLocal(updated.posArr[i]));
		}
	}
	moreShrink() {
		const anchor = this.#boneAnchorWorldPosition();
		const moving = this.#boneMovingWorldPosition();
		const curLen = anchor.distanceTo(moving);
		const orgLen = this.#length;
		if (Math.abs(curLen - orgLen) > 10) {
			const factor = ((curLen - orgLen) / orgLen) * 0.1;
			const vec3 = moving.lerp(anchor, factor);
			this.bendAt(vec3);
			return true;
		} else {
			return false;
		}
	}
	#addMeshToBone(in_ix, in_mesh, in_interlocking) {
		if (in_interlocking) {
			// in_mesh should be a part of this
			in_mesh.userData.group = this.#getCache('INTERLOCKING');
		}
		this.skeleton.bones[in_ix].add(in_mesh);
	}
	addToAnchor(in_mesh, in_interlocking = false) {
		this.#addMeshToBone(0, in_mesh, in_interlocking);
	}
	addToMoving(in_mesh, in_interlocking = false) {
		this.#addMeshToBone(this.skeleton.bones.length - 1, in_mesh, in_interlocking);
	}
	addGeometryToAnchor(in_geometry) {
		this.addToAnchor(new THREE.Mesh(in_geometry, this.material), true);
	}
	addGeometryToMoving(in_geometry) {
		this.addToMoving(new THREE.Mesh(in_geometry, this.material), true);
	}
	helper() {
		return new THREE.SkeletonHelper(this);
	}
	copyPoseData() {
		return this.skeleton.bones.map(in_bone => {
			return {
				position : in_bone.position.toArray(),
				quaternion : in_bone.quaternion.toArray() 
			};
		});
	}
	restorePoseData(in_poseData) {
		in_poseData.forEach((in_boneData, in_ix) => {
			const bone = this.skeleton.bones[in_ix];
			bone.position.fromArray(in_boneData.position);
			bone.quaternion.fromArray(in_boneData.quaternion);
		});
	}
}

class cSoftBoxPart extends cAbstractPart {
	constructor(in_w, in_h, in_d, in_boneCnt) {
		const wSeg = 1;
		const hSeg = in_boneCnt - 1;
		const dSeg = 1;
		const geometry = new THREE.BoxGeometry(in_w, in_h, in_d, wSeg, hSeg, dSeg);
		super(geometry, in_boneCnt);
	}
}

class cSoftCylinderPart extends cAbstractPart {
	constructor(in_rad_t, in_rad_b, in_h, in_boneCnt) {
		const rSeg = 32;
		const hSeg = in_boneCnt - 1;
		const geometry = new THREE.CylinderGeometry(in_rad_t, in_rad_b, in_h, rSeg, hSeg);
		super(geometry, in_boneCnt);
	}
}

class cSoftCapsulePart extends cSoftCylinderPart {
	constructor(in_rad_t, in_rad_b, in_h, in_boneCnt) {
		super(in_rad_t, in_rad_b, in_h, in_boneCnt);
		const conf = capsuleConfigure(in_rad_t, in_rad_b, in_h);
		const sphereParams = [32, 16, 0, Math.PI * 2];
		const geo = new THREE.SphereGeometry(conf.radius.t, ...sphereParams, 0, conf.theta);
		const sign = in_rad_t > in_rad_b ? +1 : -1;
		geo.translate(0, conf.delta.t * sign, 0);
		geo.rotateX(Math.PI / 2);
		this.addGeometryToMoving(geo);
	}
}

class cSoftConePart extends cAbstractPart {
	constructor(in_rad, in_h, in_boneCnt) {
		const rSeg = 32;
		const hSeg = in_boneCnt - 1;
		const geometry = new THREE.ConeGeometry(in_rad, in_h, rSeg, hSeg)
		super(geometry, in_boneCnt);
	}
}

class cSoftRoundBoxPart extends cAbstractPart {
	constructor(in_w, in_h, in_d, in_boneCnt) {
		const wSeg = 1;
		const hSeg = in_boneCnt - 1;
		const rSeg = 32;
		const zp = new THREE.PlaneGeometry(in_w, in_h, wSeg, hSeg);
		zp.rotateY(Math.PI * 0);
		zp.translate(0, 0, in_d / 2 * +1);
		const zn = new THREE.PlaneGeometry(in_w, in_h, wSeg, hSeg);
		zn.rotateY(Math.PI * 1);
		zn.translate(0, 0, in_d / 2 * -1);
		const xp = new THREE.CylinderGeometry(in_d / 2, in_d / 2, in_h, rSeg, hSeg, true, 0, Math.PI);
		xp.rotateY(Math.PI * 0);
		xp.translate(in_w / 2 * +1, 0, 0);
		const xn = new THREE.CylinderGeometry(in_d / 2, in_d / 2, in_h, rSeg, hSeg, true, 0, Math.PI);
		xn.rotateY(Math.PI * 1);
		xn.translate(in_w / 2 * -1, 0, 0);
		super(safeMergeGeometry([zp, zn, xp, xn]), in_boneCnt);
		// decoration (top, bottom)
		const makeDecoGeometry = (in_r, in_len) => {
			const wSeg = 32;
			const hSeg = 16;
			const geo1 = new THREE.SphereGeometry(in_r, wSeg, hSeg, 0, Math.PI * 0.5);
			geo1.translate(in_len / 2 * -1, 0, 0);
			const geo2 = new THREE.CylinderGeometry(in_r, in_r, in_len, wSeg, 1, true, 0, Math.PI);
			geo2.rotateY(Math.PI * 0.5 * -1);
			geo2.rotateZ(Math.PI * 0.5 * +1);
			const geo3 = new THREE.SphereGeometry(in_r, wSeg, hSeg, 0, Math.PI * 0.5);
			geo3.rotateY(Math.PI * 0.5 * +1);
			geo3.translate(in_len / 2 * +1, 0, 0);
			return safeMergeGeometry([geo1, geo2, geo3]);
		};
		const mDeco = makeDecoGeometry(in_d / 2, in_w);
		this.addGeometryToMoving(mDeco);
		const aDeco = makeDecoGeometry(in_d / 2, in_w);
		aDeco.rotateY(Math.PI);
		this.addGeometryToAnchor(aDeco);
	}
}

class cSolidPart extends cAbstractPart {
	constructor(in_geometry, in_restricted = false) {
		const boneCnt = 2;
		super(in_geometry, boneCnt);
		/*
			true  : can lookAt() toward all direction
			false : can't lookAt() toward direction of local x-coordinate
		*/
		this.plane_1_0_0 = in_restricted;
	}
	bendAt(in_dstV3, in_byUserInteraction = true) {
		let projection;
		if (this.plane_1_0_0) {
			projection = this[getWorldVec3](DIRECTION.XP);
		} else {
			projection = null;
		}
		this[lookAtWithoutRotation](in_dstV3, projection);
		if (in_byUserInteraction) {
			this.resetDraggingRcv();
		}
	}
	moreShrink() {
		return false;
	}
	copyPoseData() {
		const poseData = {};
		poseData.bone = super.copyPoseData();
		poseData.quaternion = this.quaternion.clone().toArray();
		poseData.plane_1_0_0 = this.plane_1_0_0;
		return poseData;
	}
	restorePoseData(in_poseData) {
		super.restorePoseData(in_poseData.bone);
		this.quaternion.fromArray(in_poseData.quaternion);
		this.plane_1_0_0 = in_poseData.plane_1_0_0;
	}
}

class cHead extends cSolidPart {
	constructor(in_radius) {
		const geometry = new THREE.SphereGeometry(in_radius);
		super(geometry, false);
	}
}

class cSmartPhone extends cSolidPart {
	constructor(in_width, in_height, in_radius) {
		const geometry = roundTrapezoidGeometry(in_width, in_width, in_height, in_radius);
		super(geometry, false);
	}
}

class cLightSaber extends cSolidPart {
	constructor(in_length, in_radius) {
		const parts = [];
		parts.push(customCapsuleGeometry(in_radius, in_radius, in_length));
		const radius = in_radius * 1.5;
		const length = in_length * 0.2;
		const pos = (in_length - length) / 2;
		parts.push(customCapsuleGeometry(radius, radius, length).translate(0, pos * -1, 0));
		const merged = safeMergeGeometry(parts)
		merged.translate(0, length * -0.5, 0);
		super(merged, false);
		this.position.z += length * 0.3;
	}
}

class cJointedSolidPart extends cSolidPart {
	/*
		cJointedSolidPart
		|
		+-- userData.jointed
		|
		+-- cSolidPart
			|
			+-- cSolidPart ...
	*/
	static createUtil1(in_geoArm, in_geoJoint, in_armCnt, in_restricted) {
		const geoArr = [];
		for (let i = 0; i < in_armCnt; i++) {
			geoArr[i] = {
				segment : in_geoArm.clone(),
				joint : in_geoJoint.clone()
			};
		}
		/*
			*** NOTE ***
			as a API policy, object itself (not clone) should be user for this.
			if not, without disposing by caller, memory leak will happen.
		*/
		geoArr[0].segment = in_geoArm;
		geoArr[0].joint = in_geoJoint;
		return new cJointedSolidPart(geoArr, in_restricted);
	}
	static createUtil2(in_geoArm, in_armCnt, in_restricted) {
		return cJointedSolidPart.createUtil1(in_geoArm, null, in_armCnt, in_restricted);
	}
	static #jointedFrom(in_startObj, in_direction) {
		const ancestor = in_startObj[instanceInAncestor](cJointedSolidPart);
		if (!ancestor) {
			return [];
		}
		const buff = [ancestor, ...ancestor.userData.jointed];
		if (in_direction) {
			buff.reverse();
		}
		return buff.slice(buff.indexOf(in_startObj));
	}
	static ancestors(in_obj) {
		// in_startObj + ancestors
		return cJointedSolidPart.#jointedFrom(in_obj, true);
	}
	static descendants(in_obj) {
		// in_startObj + descendants
		return cJointedSolidPart.#jointedFrom(in_obj, false);
	}
	static stretchAt(in_obj, in_dstV3) {
		const ancestors = cJointedSolidPart.ancestors(in_obj);
		if (ancestors.length === 0) {
			// not cJointedSolidPart
			return false;
		}
		/*
			[0] > threshold : using normal bendAt
			[0] < threshold : 
			  [1] > threshold : affect [1] + bendAt [0]
			  [1] < threshold : i++
			    [2] > threshold : affect [2] + bendAt [1] ([0] is the same angle with [1])
			    [2] < threshold : i++
		*/
		const threshold = 0.02;
		const vectorToStretch = in_targetObj => {
			return VEC3().subVectors(in_dstV3, in_targetObj.getWorldPosition(VEC3()));
		};
		const angleToStretch = in_targetObj => {
			return vectorToStretch(in_targetObj).angleTo(in_targetObj.getWorldDirection(VEC3()));
		};
		if (angleToStretch(ancestors[0]) < threshold) {
			let target = 0;
			for (let i = 1; i < ancestors.length; i++) {
				if (angleToStretch(ancestors[i]) < threshold) {
					continue;
				} else {
					target = i;
					break;
				}
			}
			if (target > 0) {
				// affect [n]
				const parent = ancestors[target];
				const srcDir = parent.getWorldDirection(VEC3());
				const dstDir = vectorToStretch(parent);
				const adhocScale = 1000; // how can I decide this ?
				const delta = in_dstV3.distanceTo(parent.getWorldPosition(VEC3())) / adhocScale;
				const angle = Math.min(srcDir.angleTo(dstDir), delta);
				const axis = VEC3().crossVectors(srcDir, dstDir).normalize();
				const quat = new THREE.Quaternion().setFromAxisAngle(axis, angle);
				srcDir.applyQuaternion(quat).multiplyScalar(WORLD_RADIUS);
				parent[lookAtWithoutRotation](parent.position.clone().add(srcDir));
				// bendAt [n - 1]
				const child = ancestors[target - 1];
				child[lookAtWithoutRotation](in_dstV3);
			}
			// streched
			return true;
		}
		// can bendAt
		return false;
	}
	constructor(in_geoArr, in_restricted) {
		let prev = null;
		in_geoArr.forEach(({segment, joint}) => {
			if (!prev) {
				// once
				super(segment, in_restricted);
				this.userData.jointed = [];
				prev = this;
			} else {
				const next = new cSolidPart(segment, in_restricted);
				prev.addToMoving(next, true);
				this.userData.jointed.push(next);
				prev = next;
			}
			if (joint) {
				prev.addGeometryToMoving(joint);
			}
		});
		// userData.jointed will not be updated.
		Object.freeze(this.userData.jointed);
	}
	get #jointed() {
		return [this, ...this.userData.jointed];
	}
	cloneGeometry(in_local = true) {
		const parts = [];
		this.#jointed.forEach(in_obj => {
			// call cloneGeometry@cAbstractPart
			const part = super.cloneGeometry.call(in_obj, in_local);
			if (in_local) {
				part.applyMatrix4(in_obj.matrixWorld);
			}
			parts.push(part);
		});
		const merged = safeMergeGeometry(parts);
		if (in_local) {
			merged.applyMatrix4(new THREE.Matrix4().copy(this.matrixWorld).invert());
		}
		return merged;
	}
	addToMoving(in_obj, in_interlocking = false) {
		// call addToMoving@cAbstractPart
		super.addToMoving.call(this.#jointed[this.#jointed.length - 1], in_obj, in_interlocking);
	}
	resetMaterial(in_material) {
		this.#jointed.forEach(in_obj => {
			// call resetMaterial@cAbstractPart
			super.resetMaterial.call(in_obj, in_material);
		});
	}
	copyPoseData() {
		return {
			self : super.copyPoseData(),
			// without this
			jointed : this.userData.jointed.map(in_obj => in_obj.copyPoseData())
		};
	}
	restorePoseData(in_poseData) {
		super.restorePoseData(in_poseData.self);
		in_poseData.jointed.forEach((in_partData, in_ix) => {
			this.userData.jointed[in_ix].restorePoseData(in_partData);
		});
	}
}

function createCapsuleArm1(in_movingRad, in_anchorRad, in_totalLen, in_armCnt) {
	// in_totalLen includes radius
	const wSeg = 32;
	const hSeg = 16;
	const sphereParams = [wSeg, hSeg, 0, Math.PI * 2];
	const length = (in_totalLen - (in_movingRad + in_anchorRad)) / in_armCnt;
	const deltaRad = (in_anchorRad - in_movingRad) / in_armCnt;
	const geoArr = [];
	let mDeco, solid, aDeco;
	let anchorDelta = 0;
	for (let i = 0; i < in_armCnt; i++) {
		const anchorRad = in_anchorRad - deltaRad * i;
		const movingRad = anchorRad - deltaRad;
		const conf = capsuleConfigure(movingRad, anchorRad, length);
		const top2theta = [0, conf.theta];
		mDeco = new THREE.SphereGeometry(conf.radius.t, ...sphereParams, ...top2theta);
		mDeco.rotateX(Math.PI * 0.5);
		if (i == 0) {
			const theta2bottom = [conf.theta, Math.PI - conf.theta];
			aDeco = new THREE.SphereGeometry(conf.radius.b, ...sphereParams, ...theta2bottom);
			aDeco.rotateX(Math.PI * 0.5);
			anchorDelta = conf.delta.b;
		}
		solid = new THREE.CylinderGeometry(movingRad, anchorRad, length, wSeg, 1, true);
		solid.translate(0, conf.delta.b, 0);
		geoArr[i] = {
			segment : solid,
			joint : mDeco
		};
	}
	const capsuleArm = new cJointedSolidPart(geoArr, false);
	capsuleArm.addGeometryToAnchor(aDeco);
	return {
		object : capsuleArm,
		delta : anchorDelta
	}
}

function createCapsuleArm2(in_rad, in_totalLen, in_armCnt) {
	return createCapsuleArm1(in_rad, in_rad, in_totalLen, in_armCnt);
}

function roundedBoxBody(in_movingLen, in_anchorLen, in_lenArr, in_rad) {
	// each length includes radius
	in_lenArr[0] -= in_rad;
	in_lenArr[in_lenArr.length - 1] -= in_rad;
	const totalLen = in_lenArr.reduce((acc, val) => acc + val, 0);
	const delta = in_movingLen - in_anchorLen;
	let toCurMoving = 0;
	let toCurAnchor = 0;
	const geoArr = [];
	let mDeco, solid, aDeco;
	for (let i = 0; i < in_lenArr.length; i++) {
		toCurAnchor += in_lenArr[i];
		const movingLen = in_anchorLen - in_rad * 2 + delta * toCurMoving / totalLen;
		const anchorLen = in_anchorLen - in_rad * 2 + delta * toCurAnchor / totalLen;
		const parts = makeTrapezoidGeometryParts(anchorLen, 0, movingLen, 0, in_lenArr[i], in_rad);
		const mDecoArr = [];
		const solidArr = [];
		const aDecoArr = [];
		parts.forEach(in_part => {
			if (in_part.userData.isSurface) {
				solidArr.push(in_part);
			} else {
				if (in_part.userData.groupName === 'bottom') {
					if (i === 0) {
						aDecoArr.push(in_part);
					} else {
						in_part.dispose();
					}
				} else {
					mDecoArr.push(in_part);
				}
			}
		});
		solid = safeMergeGeometry(solidArr)
		mDeco = safeMergeGeometry(mDecoArr)
		mDeco.translate(0, in_lenArr[i] * 0.5 * -1, 0);
		mDeco.rotateX(Math.PI * 0.5);
		// equals to i === 0
		if (aDecoArr.length > 0) {
			aDeco = safeMergeGeometry(aDecoArr)
			aDeco.translate(0, in_lenArr[i] * 0.5 * +1, 0);
			aDeco.rotateX(Math.PI * 0.5);
		}
		geoArr[i] = {
			segment : solid,
			joint : mDeco
		};
		toCurMoving += in_lenArr[i];
	}
	const body = new cJointedSolidPart(geoArr, true);
	body.addGeometryToAnchor(aDeco);
	return body;
}

class cFigure extends THREE.Object3D {
	static #cacheKeys = {
		PALM : Symbol(),
		THUMB : Symbol(),
		INDEX : Symbol(),
		MIDDLE : Symbol(),
		RING : Symbol(),
		LITTLE : Symbol(),
		ITEM : Symbol()
	};
	#getCache(in_key) {
		return this.userData[cFigure.#cacheKeys[in_key]];
	}
	#setCache(in_key, in_value) {
		this.userData[cFigure.#cacheKeys[in_key]] = in_value;
	}
	constructor(
		in_palm,
		in_thumb,
		in_index,
		in_middle,
		in_ring,
		in_little,
		in_item = null
	) {
		super();
		this.add(in_palm);
		// cache parts
		this.#setCache('PALM', in_palm);
		this.#setCache('THUMB', in_thumb);
		this.#setCache('INDEX', in_index);
		this.#setCache('MIDDLE', in_middle);
		this.#setCache('RING', in_ring);
		this.#setCache('LITTLE', in_little);
		this.#setCache('ITEM', in_item);
	}
	get #cached() {
		const arr = [];
		Object.keys(cFigure.#cacheKeys).forEach(in_key => {
			arr.push(this.#getCache(in_key));
		});
		return arr;
	}
	get #mergedGeometry() {
		const parts = [];
		this.#cached.forEach(in_cache => {
			if (!in_cache) {
				return;
			}
			const part = in_cache.cloneGeometry(false);
			parts.push(part);
		});
		return safeMergeGeometry(parts);
	}
	resetMaterial(in_material) {
		this.#cached.forEach(in_part => {
			if (!in_part) {
				return;
			}
			in_part.resetMaterial(in_material);
		});
		if (this.#detailed) {
			this.#detailed.material = in_material;
		}
	}
	#detailed = null;
	toStandard() {
		if (!this.#detailed) {
			return;
		}
		this.remove(this.#detailed);
		this.#detailed.geometry.dispose();
		this.#detailed = null;
		const standard = this.#getCache('PALM');
		this.add(standard);
	}
	toDetailed() {
		if (this.#detailed) {
			return;
		}
		// see : https://www.jsdelivr.com/package/npm/three-subdivide
		const iterations = 1;
		const params = {
			split : true,
			uvSmooth : false,
			preserveEdges : false,
			flatOnly : false,
			maxTriangles : Infinity
		};
		const standard = this.#getCache('PALM');
		this.remove(standard);
		const merged = this.#mergedGeometry;
		const modified = LoopSubdivision.modify(merged, iterations, params);
		merged.dispose();
		this.#detailed = new THREE.Mesh(modified, standard.material);
		this.add(this.#detailed);
	}
	static isDetailed(in_obj) {
		return in_obj.parent?.#detailed === in_obj || false;
	}
	copyPoseData() {
		const poseData = {};
		Object.keys(cFigure.#cacheKeys).forEach(in_key => {
			const part = this.#getCache(in_key);
			if (part && part.copyPoseData) {
				poseData[in_key] = part.copyPoseData();
			}
		});
		return poseData;
	}
	restorePoseData(in_poseData) {
		Object.keys(cFigure.#cacheKeys).forEach(in_key => {
			const part = this.#getCache(in_key);
			if (part && part.restorePoseData && in_poseData[in_key]) {
				part.restorePoseData(in_poseData[in_key]);
			}
		});
	}
}

/*
	(2) figure setting : color, material, items, and figure
*/

const gCyclicColors = new cCyclicValues(
	// dodgerblue
	0x1E90FF,
	// gold
	0xFFD700,
	// orangered
	0xFF4500,
	// pink
	0xEEBEC9,
	// green
	0x008000,
	// royalblue
	0x4169E1,
	// darkgoldenrod
	0xB8860B,
	// lightgray
	0xD3D3D3,
	// gray
	0x808080,
	// black
	0x000000
);

function createToonTexture() {
	const canvas = document.createElement('canvas');
	canvas.width = 128;
	canvas.height = 128;
	const context = canvas.getContext('2d');
	const gradient = context.createLinearGradient(0, 0, canvas.width, 0);
	const stops = [
		{to : 0.75, color : '#aaaaaa'},
		{to : 0.95, color : '#cccccc'},
		{to : 1.00, color : '#eeeeee'}
	];
	let from = 0.00;
	stops.forEach(in_stop => {
	    gradient.addColorStop(from, in_stop.color);
	    gradient.addColorStop(in_stop.to, in_stop.color);
		from = in_stop.to;
	});
	context.fillStyle = gradient;
	context.fillRect(0, 0, canvas.width, canvas.height);
	const texture = new THREE.CanvasTexture(canvas);
	texture.minFilter = THREE.NearestFilter;
	texture.magFilter = THREE.NearestFilter;
	return texture;
}

const gCyclicMaterials = (in_color => {
	const cyclic = new cCyclicValues();
	cyclic.push(new THREE.MeshStandardMaterial({
		color : in_color,
		metalness : 0.3,
		roughness : 0.3
	}));
	cyclic.push(new THREE.MeshStandardMaterial({
		color : in_color,
		roughness : 1.0
	}));
	cyclic.push(new THREE.MeshToonMaterial({
		color : in_color,
		gradientMap : createToonTexture()
	}));
	cyclic.push(new THREE.MeshBasicMaterial({
		color : in_color
	}));
	return cyclic;
})(gCyclicColors.currValue());

function incrementColor() {
	// gCyclicColors --> gCyclicMaterials
	const incremented = gCyclicColors.incrementedValue();
	gCyclicMaterials.forEach(in_materials => {
		in_materials.color.set(incremented); 
	});
}

function softHand() {
	const setting = {
		CIRCUMF : 50,
		PALMHEIGHT : 200,
		FINGER : {
			THUMBANGLE : Math.PI / 3,
			THUMBLENGTH : 130,
			LENGTH : [
				[0, 180],
				[20, 180],
				[10, 170],
				[0, 150]
			],
			MARGIN : [10, 10, 10]
		}
	};
	const overlap = 0;
	const bentCnt = 10;
	const circumf = setting.CIRCUMF;
	const palmh = setting.PALMHEIGHT - circumf;
	const palmw = circumf * 4 + setting.FINGER.MARGIN.reduce((in_acc, in_cur) => in_acc + in_cur, 0);
	// palm
	const palm = new cSoftBoxPart(palmw, palmh, circumf, bentCnt);
	palm.rotateX(Math.PI);
	// bottom of palm
	const theta = Math.PI / 2 - setting.FINGER.THUMBANGLE;
	const bottomPoint = [
		[0, 0],
		[palmw, 0],
		[palmw + circumf * Math.sin(theta), circumf * Math.cos(theta) * -1],
		[palmw, circumf * -1],
		[palmw / 3, circumf * -1]
	];
	const shape = new THREE.Shape();
	shape.moveTo(...bottomPoint.shift());
	bottomPoint.forEach(in_point => shape.lineTo(...in_point));
	/*
		*** NOTE ***
		an instance does not necessarily have an index.
		so to merge with indexed geometry, mergeVertices should be called.
		https://discourse.threejs.org/t/how-to-get-extrudegeometrys-index/35921
	*/
	const bottom = UTILS.mergeVertices(new THREE.ExtrudeGeometry(shape, {
		steps : 1,
		depth : circumf,
		bevelEnabled : false
	}));
	bottom.rotateX(Math.PI / 2 * -1);
	bottom.translate(palmw / 2 * -1, circumf / 2 * -1, 0);
	palm.addGeometryToMoving(bottom);
	// thumb
	const thumb = new cSoftBoxPart(circumf, setting.FINGER.THUMBLENGTH, circumf, bentCnt);
	thumb.geometry.translate(circumf / 2 * -1, 0, 0);
	palm.addToMoving(thumb);
	thumb.rotateY(Math.PI - setting.FINGER.THUMBANGLE);
	thumb.position.x = palmw / 2;
	// other fingers
	const fingers = [];
	fingers.push(thumb);
	let shiftNegative = 0;
	for (let i = 0; i < setting.FINGER.LENGTH.length; i++) {
		const fingerAnchor = setting.FINGER.LENGTH[i][0];
		const fingerLength = setting.FINGER.LENGTH[i][1];
		const finger = new cSoftBoxPart(circumf, fingerLength, circumf, bentCnt);
		finger.rotateX(Math.PI);
		palm.addToAnchor(finger);
		shiftNegative += circumf / 2;
		finger.position.x = palmw / 2 - shiftNegative;
		finger.position.z = fingerAnchor * -1 + overlap;
		if (fingerAnchor > 0) {
			const geometry = new THREE.BoxGeometry(circumf, circumf, fingerAnchor + overlap);
			geometry.translate(palmw / 2 - shiftNegative, 0, fingerAnchor / 2 * -1 + overlap);
			palm.addGeometryToAnchor(geometry);
		}
		shiftNegative += circumf / 2 + setting.FINGER.MARGIN[i];
		fingers.push(finger);
	}
	return new cFigure(palm, ...fingers);
}

const gFigure = softHand();
gFigure.resetMaterial(gCyclicMaterials.currValue());

function incrementMaterial() {
	gFigure.resetMaterial(gCyclicMaterials.incrementedValue());
}

/*
	(3) ui & dom setting
*/

const WORLD_RADIUS = 1000;

const gWorld = new cSphericalWorld(WORLD_RADIUS);

gWorld.add(gFigure);
gWorld.moveView(100, 250);

function uiChangeColor() {
	const currColor = new THREE.Color(gCyclicColors.currValue());
	const nextColor = new THREE.Color(gCyclicColors.nextValue());
	let delta = 0.05;
	let interpolation = 0;
	const hook = () => {
		interpolation += delta;
		if (interpolation < 1) {
			let tempColor = currColor.clone().lerp(nextColor, interpolation);
			(gCyclicMaterials.currValue()).color.setHex(tempColor.getHex());
		} else {
			gWorld.removeAnimationHook(hook);
			incrementColor();
		}
	};
	gWorld.addAnimationHook(hook);
}

function uiChangeMaterial() {
	const flashEffect = 0xEEEEEE;
	gWorld.motionFog(flashEffect, 0, 100, 200).then(() => {
		incrementMaterial();
		return gWorld.motionFog(flashEffect, 100, 50, 200);
	});
}

let gDetail = true;

function uiIncrementDetail(in_elem) {
	const curr = gCyclicLevel.currValue();
	const next = gCyclicLevel.incrementedValue();
	in_elem.innerText = next.text;
	in_elem.removeEventListener('click', curr.func);
	in_elem.addEventListener('click', next.func);
}

function uiEnableDetail(in_ev) {
	uiIncrementDetail(in_ev.target);
	gDetail = true;
	gFigure.toDetailed();
}

function uiDisableDetail(in_ev) {
	uiIncrementDetail(in_ev.target);
	gDetail = false;
	gFigure.toStandard();
}

const gCyclicLevel = new cCyclicValues(
	{
		text : 'detail off (now on)',
		func : uiDisableDetail
	},
	{
		text : 'detail on (now off)',
		func : uiEnableDetail
	}
);

function uiDefaultView() {
	gWorld.motionViewFrom(VEC3(0, 0, 1));
}

/*
	*** NOTE ***
	in Safari, using await to get audio will cause the process to fail.
	I'm not sure of the reason, but top-level await might be the cause.
	this time use then() to avoid the issue.
*/

let SE_BEEP = beep(2000);
let SE_DUMMY = beep(10);
let SE_SHUTTER = SE_BEEP;
let SE_RELEASE = SE_BEEP;

SOUND.SHUTTER.then(in_decompress => {
	SE_SHUTTER = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

SOUND.RELEASE.then(in_decompress => {
	SE_RELEASE = new Audio('data:audio/mpeg;base64,' + in_decompress);
});

function takeShotSound() {
	SE_SHUTTER.play();
}

function takeShotFlash() {
	const flash = document.createElement('div');
	Object.assign(flash.style, {
		position : 'fixed',
		left : '0px',
		top : '0px',
		width : '100%',
		height : '100%',
		background : 'white',
		zIndex : 2 ** 31 - 1,
	});
	document.body.appendChild(flash);
	autoTransition(flash, 'opacity 0.2s ease-out', 1, 0);
	flash.addEventListener('transitionend', () => {
		document.body.removeChild(flash);
	});
}

const CLIPMARGIN = 10;

function uiGetScreenShot() {
	takeShotSound();
	takeShotFlash();
	/*
		*** NOTE ***
		before getting betmap, you need re-render.
		without it, for example, you can't use canvas.toDataURL('image/png') etc. 
	*/
	gWorld.render();
	const box = gWorld.canvas[clipClearArea](CLIPMARGIN);
	const tmpElem = document.createElement('canvas');
	tmpElem.width = box.w;
	tmpElem.height = box.h;
	const ctx = tmpElem.getContext('2d');
	ctx.drawImage(gWorld.canvas, box.l, box.t, box.w, box.h, 0, 0, box.w, box.h);
	(async () => {
		/*
			*** NOTE ***
			the browser treats the data URL as a resource when using fetch.
			the fetch function retrieves the data and allows us to convert it into a Blob.
		*/
		const response = await fetch(tmpElem.toDataURL('image/png'));
		const blob = await response.blob();
		try {
			await navigator.clipboard.write([
				new ClipboardItem({'image/png': blob})
			]);
		} catch (err) {
			alert(err);
		}
	})();
}

function uiHelp() {
	const url = {
		ver : './version.txt',
		img : './stick-figure-help.gif',
		src : 'https://github.com/nakayama-kazuki/202x/commit/'
	};
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<div><img src="' + url.img + '" /></div>';
	const verLabel = document.createElement('div');
	Object.assign(verLabel.style, {
		textAlign : 'right'
	});
	dialog.appendChild(verLabel);
	getResource(url.ver).then(in_hash => {
		verLabel.innerHTML = 'version : <a href="' + url.src + in_hash + '">' + in_hash.substring(0, 7) + '</a>';
		verLabel.addEventListener('mousedown', in_e => in_e.stopPropagation());
		verLabel.addEventListener('touchstart', in_e => in_e.stopPropagation());
	}).catch(in_err => {
	    console.error(in_err);
		verLabel.innerHTML = 'version : unknown';
	});
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		color : 'white',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Image Usage Rights</dt>',
		'<dd>All images generated using this software are free for users to use as they see fit.</dd>',
		'<dd>This includes the rights to modify, distribute, and use the images for both personal and commercial purposes without any restrictions.</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	startDialog(dialog);
}

(in_settings => {
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	in_settings.forEach(in_setting => {
		let button = document.createElement('button');
		button.innerText = in_setting.text;
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
})([
	{
		text : 'next color',
		func : uiChangeColor
	},
	{
		text : 'next material',
		func : uiChangeMaterial
	},
	{
		text : gCyclicLevel.currValue().text,
		func : gCyclicLevel.currValue().func
	},
	{
		text : 'default position',
		func : uiDefaultView
	},
	{
		text : 'screenshot',
		func : uiGetScreenShot
	},
	{
		text : 'help',
		func : uiHelp
	},
	{
		text : 'rights',
		func : uiRights
	},
	{
		text : 'corridor',
		func : () => location.href = 'https://pj-corridor.net/'
	}
]);

const TRANSPARENT_IMAGE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADBJREFUOE9jTEtL+8+ABxgbG+OTZmAcNWBYhMHMmTPxpoOzZ8/iTwejBjAwDv0wAADSgj/p4jinSwAAAABJRU5ErkJggg==';

function drawBackground(in_canvas) {
	Object.assign(in_canvas.style, {
		backgroundImage : 'url(' + TRANSPARENT_IMAGE + ')',
		backgroundRepeat : 'repeat',
		backgroundSize : 'auto',
		position : 'absolute',
		left : 0,
		top : 0,
		zIndex : -1
	});
}

const gBackgroundCanvas = document.createElement('CANVAS');

function setupBody(in_document) {
	if (!in_document.body) {
		in_document.documentElement.appendChild(in_document.createElement('BODY'));
	}
	Object.assign(in_document.body.style, {
		margin : '0',
		overflow : 'hidden'
	});
}

function createChildWindow(in_document) {
	return new Promise(in_callback => {
		setupBody(in_document);
		const iframe = in_document.createElement('iframe');
		in_document.body.appendChild(iframe);
		Object.assign(iframe.style, {
			width: '100%',
			height: '100%',
			border: 'none'
		});
		/*
			*** NOTE ***
			although Chrome can use iframe.contentDocument right after createElement,
			Firefox can not use it ant needs to use asynchronous process.
			by the way, if you use not timer but load event,
			your code will not work for Chrome.
		*/
		setTimeout(() => {
			setupBody(iframe.contentDocument);
			(in_callback)(iframe.contentWindow);
		}, 0);
	});
}

document.addEventListener('DOMContentLoaded', (async () => {
	/*
		*** NOTE ***
		without iframe (outer window),
		geometry in event will be wrong because of google ads
	*/
	const outer = await createChildWindow(document);
	let resizeWorld = in_ev => {
		gWorld.resize(outer.innerWidth, outer.innerHeight);
		gBackgroundCanvas.width = outer.innerWidth;
		gBackgroundCanvas.height = outer.innerHeight;
		drawBackground(gBackgroundCanvas);
	};
	outer.addEventListener('resize', debouncing(resizeWorld, 300));
	outer.dispatchEvent(new Event('resize'));
	outer.document.body.appendChild(gWorld.canvas);
	outer.document.body.appendChild(gBackgroundCanvas);
	gWorld.start();
}));

/*
	(4) event handlers
*/

const gHandlers = (() => {
	const c = {
		obj : null,
		far : false,
		animating : false,
		once : false
	};
	const start = in_ev => {
		if (!c.once) {
			/*
				*** NOTE ***
				Safari may restrict sound without user interaction.
				because of this, the sound does not work without this code.
			*/
			SE_DUMMY.play();
			c.once = true;
		}
		if (c.obj) {
			return;
		}
		const ndc = ndcFromEvent(in_ev);
		const intersects = gWorld.intersectPositive(ndc);
		if (intersects.length === 0) {
			return;
		}
		const rayHit = intersects[0];
		// for #makeRoughGeometry(), and addMeshToBone()
		const target = rayHit.object[instanceInAncestor](cAbstractPart);
		if (!target) {
			// uncontrollable object
			if (cFigure.isDetailed(rayHit.object)) {
				gFigure.toStandard();
				start(in_ev);
			}
			return;
		}
		const cameraPos = gWorld.getCameraPos();
		const objectPos = target.getWorldPosition(VEC3());
		const fineAdjustment = 0.9;
		c.far = (rayHit.distance * fineAdjustment > cameraPos.distanceTo(objectPos));
		c.obj = target;
		// not lookAt(cameraPos), but lookAt(raycaster.ray.direction.negate())
		c.obj.activateDraggingRcv(objectPos.add(cameraPos));
	};
	const move = in_ev => {
		if (!c.obj) {
			return;
		}
		const ndc = ndcFromEvent(in_ev);
		let intersects;
		if (c.far) {
			intersects = gWorld.intersectNegative(ndc, cAbstractPart.operatingLayer);
		} else {
			intersects = gWorld.intersectPositive(ndc, cAbstractPart.operatingLayer);
		}
		if (intersects.length > 0) {
			// receiver (CircleGeometry or SphereGeometry)
			if (intersects.length === 1) {
				// receiver (only CircleGeometry)
				if (cJointedSolidPart.stretchAt(c.obj, intersects[0].point)) {
					// (1) bendAt() may be applied to ancestor
					return;
				}
			}
			// (2) bendAt() is applied to c.obj
			c.obj.bendAt(intersects[0].point);
		} else {
			// (3) c.obj is released
			if (c.animating) {
				return;
			} else {
				SE_RELEASE.play();
				c.animating = true;
			}
			const hook = (in_obj => {
				return () => {
					/*
						when stop will be called during animation,
						c.obj will be set to null.
						so bind c.obj to callback.
					*/
					if (in_obj.moreShrink()) {
						return;
					}
					gWorld.removeAnimationHook(hook);
					stop(new Event('mouseout'));
				}
			})(c.obj);
			gWorld.addAnimationHook(hook);
		}
	};
	const DEBOUNCING_GROUP = Symbol();
	const updateToDetailed = () => {
		if (!gDetail) {
			return;
		}
		(debouncing(() => {
			if (c.obj) {
				return;
			} else {
				gFigure.toDetailed();
			}
		}, 500, DEBOUNCING_GROUP))(new Event('dummy'));
	}
	updateToDetailed();
	const stop = in_ev => {
		if (!c.obj) {
			return;
		}
		c.obj.activateReleasedRcv();
		c.obj = null;
		c.far = false;
		c.animating = false;
		updateToDetailed();
	};
	return {
		'mousedown' : start,
		'mousemove' : move,
		'mouseleave' : stop,
		'mouseout' : stop,
		'mouseup' : stop
	};
})();

for (let [eventName, handler] of Object.entries(gHandlers)) {
	gWorld.canvas.addEventListener(eventName, handler);
}

</script>
</body>
</html>
