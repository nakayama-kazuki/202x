<html>
<head>
<!-- MIT License Copyright (c) 2024 pj-corridor.net -->
<meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1' />
<meta charset='utf-8' />
<script async src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7863584801355594' crossorigin='anonymous'></script>
<script type='importmap'>
{
	"imports": {
		"three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.min.js",
		"utils": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/utils/BufferGeometryUtils.js"
	}
}
</script>
</head>
<body>
<script type='module'>

import * as THREE from 'three';
import * as UTILS from 'utils';

//const DEBUG = true;
const DEBUG = false;

function randomString(in_length = 5)
{
	return Math.floor(Math.random() * (10 ** in_length)).toString(16).padStart(in_length, '0');
}

function convertUnit(in_u1_value, in_u1_from, in_u1_to, in_u2_from, in_u2_to) {
	return in_u2_from + ((in_u1_value - in_u1_from) / (in_u1_to - in_u1_from)) * (in_u2_to - in_u2_from);
}

/*

const testSets = [
	[+0.1,  0, +1,   0, +10, +1],
	[+0.1, +1,  0,   0, +10, +9],
	[+0.1,  0, +1, +10,   0, +9],
	[+0.1, +1,  0, +10,   0, +1],
	[-0.1,  0, -1,   0, +10, +1],
	[-0.1, -1,  0,   0, +10, +9],
	[-0.1,  0, -1, +10,   0, +9],
	[-0.1, -1,  0, +10,   0, +1],
	[+0.1,  0, +1,   0, -10, -1],
	[+0.1, +1,  0,   0, -10, -9],
	[+0.1,  0, +1, -10,   0, -9],
	[+0.1, +1,  0, -10,   0, -1],
	[-0.1,  0, -1,   0, -10, -1],
	[-0.1, -1,  0,   0, -10, -9],
	[-0.1,  0, -1, -10,   0, -9],
	[-0.1, -1,  0, -10,   0, -1]
];

testSets.forEach(test => {
	if (convertUnit(test[0], test[1], test[2], test[3], test[4]) !== test[5]) {
		console.log('failed');
	}
});

*/

function convertUnitRect(in_src_x, in_src_y, in_src_rect, in_dst_rect)
{
	return (new THREE.Vector2(
		convertUnit(in_src_x, in_src_rect.l, in_src_rect.r, in_dst_rect.l, in_dst_rect.r),
		convertUnit(in_src_y, in_src_rect.t, in_src_rect.b, in_dst_rect.t, in_dst_rect.b)
	));
}

function convertRaycasterUnit(in_src_x, in_src_y, in_src_w, in_src_h)
{
	const src_rect = {
		l : 0,
		t : 0,
		r : in_src_w,
		b : in_src_h
	};
	const dst_rect = {
		l : -1,
		t : -1,
		r : 1,
		b : 1
	};
	const vec2 = convertUnitRect(in_src_x, in_src_y, src_rect, dst_rect);
	// finally, dst_rect.t and dst_rect.b should be inverted
	vec2.y *= -1;
	return vec2;
}

function eventPos2RaycasterPos(in_ev)
{
	const elem = in_ev.currentTarget
	return convertRaycasterUnit(
		in_ev.clientX - elem.offsetLeft,
		in_ev.clientY - elem.offsetTop,
		elem.offsetWidth,
		elem.offsetHeight);
}

const EVPOS_MULTIPLY_PARAM = 3;

function snapToNotch(in_value, in_notch)
{
	let notch = in_notch / 2;
	let abs = Math.abs(in_value);
	let cnt = Math.floor(abs / notch);
	if (cnt % 2 === 1) {
		cnt += 1;
	}
	if (abs === 0) {
		return 0;
	} else {
		return notch * cnt * (in_value / abs);
	}
}

function snapTo05PI(in_value)
{
	/*
		{in : Math.PI / 4 - delta, expected : 0},
		{in : Math.PI / 4 + delta, expected : Math.PI / 2}
	*/
	return snapToNotch(in_value, Math.PI / 2);
}

function nearlyEqual(in_a, in_b, in_error = 0.01) {
	const diff = Math.abs(in_a - in_b);
	const comp = Math.max(Math.abs(in_a), Math.abs(in_b));
	return diff < comp * in_error;
}

const arrRand = Symbol();

Array.prototype[arrRand] = function() {
	return this[Math.floor(Math.random() * this.length)];
};

const forEachCombination = Symbol();

Array.prototype[forEachCombination] = function(in_n, in_callback) {
	const combine = (in_args, in_start, in_decrement) => {
		if (in_decrement === 0) {
			return (in_callback)(...in_args);
		} else {
			for (let i = in_start; i <= this.length - in_decrement; i++) {
				in_args.push(this[i]);
				if (combine(in_args, i + 1, in_decrement - 1)) {
					return true;
				} else {
					in_args.pop();
				}
			}
		}
		return false;
	}
	return (combine)([], 0, in_n);
};

class cEase {
	constructor(in_from, in_to, in_duration) {
		this.from = in_from;
		this.to = in_to;
		this.duration = in_duration;
		this.start = Date.now();
	}
	#currentEasing(in_quad) {
		const elapsed = Date.now() - this.start;
		if (elapsed > this.duration) {
			return this.to;
		} else {
			return this.from + (this.to - this.from) * (in_quad)(elapsed / this.duration);
		}
	}
	currentEasingLinear() {
		return this.#currentEasing(t => t);
	}
	currentEasingIn() {
		return this.#currentEasing(t => t * t);
	}
	currentEasingOut() {
		return this.#currentEasing(t => t * (2 - t));
	}
}

const XYZ = ['x', 'y', 'z'];

const VEC3 = (x = 0, y = 0, z = 0) => new THREE.Vector3(x, y, z);

const DIRECTION = {
	XP : VEC3(+1, 0, 0),
	XN : VEC3(-1, 0, 0),
	YP : VEC3(0, +1, 0),
	YN : VEC3(0, -1, 0),
	ZP : VEC3(0, 0, +1),
	ZN : VEC3(0, 0, -1)
}

/*
	(1) cSphericalWorld

	|
	+-- Scene
	|
	+-- WebGLRenderer
	|
	+-- Object3D ( to control camera )
		|
		+- PerspectiveCamera
*/

const DEVICE_PIXEL_RATIO = window.devicePixelRatio;

class cSphericalWorld {
	static #defaultCameraSetting = 2;
	static #view = [
		{
			cameraFrom : DIRECTION.ZN,
			cameraUp : DIRECTION.YP,
			dxDir : -1,
			dyDir : -1
		},
		{
			cameraFrom : DIRECTION.ZN,
			cameraUp : DIRECTION.YN,
			dxDir : 1,
			dyDir : 1
		},
		{
			cameraFrom : DIRECTION.ZP,
			cameraUp : DIRECTION.YP,
			dxDir : -1,
			dyDir : 1
		},
		{
			cameraFrom : DIRECTION.ZP,
			cameraUp : DIRECTION.YN,
			dxDir : 1,
			dyDir : -1
		}
	][cSphericalWorld.#defaultCameraSetting];
	static #rotationCallbackName = Symbol();
	#scene = null;
	#renderer = null;
	#cameraCtrl = null;
	#cameraName = randomString();
	#anchorPosV2 = null;
	zoomMin = Number.NEGATIVE_INFINITY;
	zoomMax = Number.POSITIVE_INFINITY;
	#userObjects = new Set();
	#animationHooks = new Set();
	static #deltaThreshold = 0.05;
	constructor(in_radius) {
		// scene
		this.#scene = new THREE.Scene();
		// renderer
		this.#renderer = new THREE.WebGLRenderer({alpha : true, antialias : true});
		this.#renderer.setPixelRatio(DEVICE_PIXEL_RATIO);
		if (false) {
			this.#renderer.shadowMap.enabled = true;
		}
		// camera
		const camera = new THREE.PerspectiveCamera();
		camera.name = this.#cameraName;
		camera.fov = 45;
		camera.near = 1;
		camera.far = in_radius * 2;
		camera.position.set(
			0,
			0,
			in_radius * cSphericalWorld.#view.cameraFrom.z);
		camera.up.set(
			cSphericalWorld.#view.cameraUp.x,
			cSphericalWorld.#view.cameraUp.y,
			cSphericalWorld.#view.cameraUp.z
		);
		camera.lookAt(new THREE.Vector3(0, 0, 0));
		this.#cameraCtrl = new THREE.Object3D();
		this.#cameraCtrl.add(camera);
		// light
		const lightColor = 0xFFFFFF;
		const light = new THREE.DirectionalLight(lightColor);
		light.position.set(
			0,
			in_radius * cSphericalWorld.#view.cameraUp.y,
			in_radius * cSphericalWorld.#view.cameraFrom.z);
		if (false) {
			light.castShadow = true;
		}
		this.#cameraCtrl.add(light);
		this.add(new THREE.AmbientLight(lightColor), true);
		// other
		this.resize(this.canvas.width, this.canvas.height);
		this.canvas.addEventListener('mousedown', this.#evMoveStart.bind(this));
		this.canvas.addEventListener('mousemove', this.#evMoveUpdate.bind(this));
		this.canvas.addEventListener('mouseleave', this.#evMoveStop.bind(this));
		this.canvas.addEventListener('mouseout', this.#evMoveStop.bind(this));
		this.canvas.addEventListener('mouseup', this.#evMoveStop.bind(this));
		this.canvas.addEventListener('wheel', this.#evZoom.bind(this));
	}
	get canvas() {
		return this.#renderer.domElement;
	}
	get #camera() {
		return this.#cameraCtrl.getObjectByName(this.#cameraName);
	}
	getLookAt() {
		return this.#camera.position.clone().negate();
	}
	#moveCameraCtrl(in_world_dx, in_world_dy) {
		this.#cameraCtrl.rotateY(in_world_dx * cSphericalWorld.#view.dxDir);
		this.#cameraCtrl.rotateX(in_world_dy * cSphericalWorld.#view.dyDir);
	}
	moveView(in_world_dx, in_world_dy) {
		this.#moveCameraCtrl(in_world_dx * -1, in_world_dy * -1);
	}
	#setZoom(in_distance) {
		this.#camera.position.normalize().multiplyScalar(in_distance);
	}
	#evMoveStart(in_ev) {
		const vec2 = eventPos2RaycasterPos(in_ev);
		if (this.intersectPositive(vec2).length > 0) {
			return;
		}
		this.#anchorPosV2 = vec2;
	}
	#evMoveUpdate(in_ev) {
		if (!this.#anchorPosV2) {
			return;
		}
		const vec2 = eventPos2RaycasterPos(in_ev);
		let delta = vec2.clone().sub(this.#anchorPosV2);
		if (delta.length() < cSphericalWorld.#deltaThreshold) {
			return;
		}
		delta.multiplyScalar(EVPOS_MULTIPLY_PARAM);
		this.#moveCameraCtrl(delta.x, delta.y);
		this.#anchorPosV2 = vec2;
	}
	#evMoveStop(in_ev) {
		if (!this.#anchorPosV2) {
			return;
		}
		this.#anchorPosV2 = null;
	}
	#evZoom(in_ev) {
		const distance = this.#camera.position.length() + in_ev.deltaY;
		if ((this.zoomMax < distance) && (distance < this.zoomMin)) {
			this.#setZoom(distance);
		}
	}
	#intersectObjects(in_vec2, in_direction, in_layer) {
		const raycaster = new THREE.Raycaster();
		raycaster.layers.set(in_layer);
		// camera ---[ raycast ]---> object
		raycaster.setFromCamera(in_vec2, this.#camera);
		const intersects = raycaster.intersectObjects(this.#scene.children);
		if (in_direction || (intersects.length === 0)) {
			return intersects;
		}
		// camera ---> object ( intersects[0].point ) ---[ raycaster.ray.direction ]---> opposit
		const opposit = (intersects[0].point.clone()).add(raycaster.ray.direction.multiplyScalar(this.#camera.far));
		// camera ---> object <---[ raycast again ]--- opposit
		raycaster.set(opposit, (raycaster.ray.direction.clone()).negate());
		return raycaster.intersectObjects(this.#scene.children);
	}
	intersectPositive(in_vec2, in_layer = 0) {
		return this.#intersectObjects(in_vec2, true, in_layer);
	}
	intersectNegative(in_vec2, in_layer = 0) {
		return this.#intersectObjects(in_vec2, false, in_layer);
	}
	copyCameraPosition() {
		return this.#camera.getWorldPosition(new THREE.Vector3());
	}
	#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, in_method) {
		return new Promise(resolve => {
			if (nearlyEqual(in_initValue, in_stopValue)) {
				(in_progressCallback)(in_stopValue);
				// to the next then in the chain
				(resolve)();
				return;
			}
			const ease = new cEase(in_initValue, in_stopValue, in_duration);
			const hook = () => {
				let currValue;
				switch (in_method) {
				case 10 :
					currValue = ease.currentEasingIn();
					break;
				case 20 :
					currValue = ease.currentEasingOut();
					break;
				case 30 :
				default :
					currValue = ease.currentEasingLinear();
					break;
				}
				if (currValue === in_stopValue) {
					this.removeAnimationHook(hook);
					(in_progressCallback)(in_stopValue);
					// to the next then in the chain
					(resolve)();
				} else {
					(in_progressCallback)(currValue);
				}
			};
			this.addAnimationHook(hook);
		});
	}
	easeIn(in_initValue, in_stopValue, in_duration, in_progressCallback) {
		return this.#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, 10);
	}
	easeOut(in_initValue, in_stopValue, in_duration, in_progressCallback) {
		return this.#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, 20);
	}
	easeLinear(in_initValue, in_stopValue, in_duration, in_progressCallback) {
		return this.#easing(in_initValue, in_stopValue, in_duration, in_progressCallback, 30);
	}
	addAnimationHook(in_hook) {
		this.#animationHooks.add(in_hook);
	}
	removeAnimationHook(in_hook) {
		this.#animationHooks.delete(in_hook);
	}
	motionZoom1(in_initDistance, in_stopDistance, in_duration) {
		return this.easeOut(in_initDistance, in_stopDistance, in_duration, in_currDistance => {
			this.#setZoom(in_currDistance);
		});
	}
	motionZoom2(in_stopDistance, in_duration) {
		return this.motionZoom1(this.#camera.position.length(), in_stopDistance, in_duration);
	}
	motionKnock(in_duration = 100) {
		const currentDistance = this.#camera.position.length();
		return this.motionZoom1(currentDistance * 1.1, currentDistance, in_duration);
	}
	motionDefaultView(in_duration = 2000) {
		const targetQuat = new THREE.Quaternion();
		const targetRad = this.#cameraCtrl.quaternion.angleTo(targetQuat);
		return this.easeIn(0, targetRad, in_duration, in_currRad => {
			this.#cameraCtrl.quaternion.rotateTowards(targetQuat, in_currRad);
		});
	}
	motionFog(in_color, in_initFogged, in_stopFogged, in_duration = 500) {
		return new Promise(resolve => {
			if (this.#scene.fog) {
				// to the next then in the chain
				(resolve)();
				return;
			}
			const distance = this.#camera.position.length();
			const margin = 100;
			const radius = this.#getUserObjectRadius() + margin;
			const initNear = convertUnit(in_initFogged, 0, 100, distance + radius, distance - radius * 3);
			const stopNear = convertUnit(in_stopFogged, 0, 100, distance + radius, distance - radius * 3);
			this.#scene.fog = new THREE.Fog(in_color, initNear, initNear + radius * 2);
			this.easeLinear(initNear, stopNear, in_duration, in_currNear => {
				this.#scene.fog.near = in_currNear;
				this.#scene.fog.far = in_currNear + radius * 2;
			}).then(() => {
				this.#scene.fog = null;
				// to the next then in the chain
				(resolve)();
			});
		});
	}
	startRotation(in_vec3) {
		this[cSphericalWorld.#rotationCallbackName] = () => {
			this.#cameraCtrl.rotateX(in_vec3.x);
			this.#cameraCtrl.rotateY(in_vec3.y);
			this.#cameraCtrl.rotateZ(in_vec3.z);
		};
		this.addAnimationHook(this[cSphericalWorld.#rotationCallbackName]);
	}
	stopRotation() {
		this.removeAnimationHook(this[cSphericalWorld.#rotationCallbackName]);
		delete this[cSphericalWorld.#rotationCallbackName];
	}
	resize(in_w, in_h) {
		this.#renderer.setSize(in_w, in_h);
		this.#camera.aspect = in_w / in_h;
		this.#camera.updateProjectionMatrix();
	}
	#getUserObjectRadius() {
		let max = Number.NEGATIVE_INFINITY;
		this.#userObjects.forEach(in_obj => {
			const box = (new THREE.Box3()).setFromObject(in_obj);
			const sphere = new THREE.Sphere();
			box.getBoundingSphere(sphere);
			max = Math.max(max, sphere.radius);
		});
		return max;
	}
	#updateZoomParams() {
		let delayed = 1000;
		const update = () => {
			const radius = this.#getUserObjectRadius();
			if (radius < 0) {
				// don't have visible object
				delayed *= 2;
				window.setTimeout(update, delayed);
			} else {
				this.zoomMin = this.#camera.far - radius;
				this.zoomMax = radius
			}
		};
		(update)();
	}
	add(in_added, in_isSystemObject = false) {
		this.#scene.add(in_added);
		if (in_isSystemObject) {
			return;
		}
		this.#userObjects.add(in_added);
		this.#updateZoomParams();
	}
	remove(in_removed, in_isSystemObject = false) {
		/*
			*** NOTE #1 ***
			As remove is idempotent,
			children will be removed safety.
		*/
		this.#scene.remove(in_removed);
		if (in_isSystemObject) {
			return;
		}
		this.#userObjects.delete(in_removed);
		this.#updateZoomParams();
	}
	render() {
		this.#renderer.render(this.#scene, this.#camera);
	}
	start() {
		this.add(this.#cameraCtrl, true);
		this.#renderer.setAnimationLoop(() => {
			this.render();
			this.#animationHooks.forEach(in_hook => {
				(in_hook)();
			});
		});
	}
}

/*
	(2) factory function controls segments of geometry (depends on debug setting).
*/

function getSegments(in_className) {
	const IX_ROUGH = 0;
	const IX_SMOOTH = 1;
	const settings = {
		SphereGeometry : {
			width : [16, 64],
			height : [16, 64]
		},
		CylinderGeometry : {
			radial : [16, 64],
			height : [1, 4]
		},
		CapsuleGeometry : {
			cap : [8, 32],
			radial : [16, 64]
		}
	}[in_className];
	const segments = [];
	for (let prop in settings) {
		segments.push(settings[prop][(DEBUG ? IX_ROUGH : IX_SMOOTH)]);
	}
	return segments;
}

class CustomSphere extends THREE.SphereGeometry {
	constructor(in_radius) {
		const segments = getSegments('SphereGeometry');
		super(in_radius, ...segments);
	}
}

class CustomCylinder extends THREE.CylinderGeometry {
	constructor(in_radiusTop, in_radiusBottom, in_height) {
		const segments = getSegments('CylinderGeometry');
		super(in_radiusTop, in_radiusBottom, in_height, ...segments);
	}
}

class CustomCapsule extends THREE.CapsuleGeometry {
	constructor(in_radius, in_height) {
		const segments = getSegments('CapsuleGeometry');
		super(in_radius, in_height, ...segments);
	}
}

/*
	(3) cPart

	Mesh
	|
	+-- in_geometry
	|
	+-- receiver ( not visible & to control arm.lookAt )
		|
		+-- SphereGeometry
		|
		+-- PlaneGeometry
*/

class cPart extends THREE.Mesh {
	// to draw this layer, camera.layers.enable must be called
	static receiverLayer = 1;
	static #receiverWidenRatio = (DEBUG ? 4 : 1000);
	static #receiverMaterial = new THREE.MeshNormalMaterial({transparent: true, opacity: 0.5});
	static #cacheKeys = {
		frontvec : Symbol(),
		receiver : Symbol(),
		raycastn : Symbol()
	};
	#getCache(in_key) {
		return this.userData[cPart.#cacheKeys[in_key]];
	}
	#setCache(in_key, in_value) {
		this.userData[cPart.#cacheKeys[in_key]] = in_value;
	}
	constructor(in_length, in_geometry, in_material) {
		/*
			default object :

			     y    
			     |   -z : front (0, 0, -1)
			     |  /
			     | /
			    ###
			    #*#-------x
			    /##
			   /
			  /
			 /
			z : obj.lookAt(0, 0, 1)

			converted object :

			     y : front (0, 1, 0)
			     |
			     |  /
			     | /
			     |/
			    #*#-------x
			   ###
			  ###
			  /
			 /
			z : obj.lookAt(0, 0, 1)
		*/
		const angle = Math.PI / 2;
		const front = new THREE.Vector3(0, 0, -1);
		super(in_geometry.rotateX(angle).translate(0, 0, in_length / 2), in_material);
		if (false) {
			this.castShadow = true;
			this.receiveShadow = true;
		}
		this.#setCache('frontvec', front.applyMatrix4(new THREE.Matrix4().makeRotationX(angle)));
		// receive intersection from raycast
		const receivers = [];
		const thin = 0.01;
		const wide = in_length * cPart.#receiverWidenRatio;
		/*
			*** NOTE #2 ***
			As PlaneGeometry can't catch raycast from opposite side,
			use thin BoxGeometry instead of PlaneGeometry.
		*/
		receivers.push(new THREE.BoxGeometry(wide, wide, thin));
		receivers.push(new THREE.SphereGeometry(in_length));
		const merged = new THREE.Mesh(UTILS.mergeGeometries(receivers), cPart.#receiverMaterial);
		receivers.forEach(in_geo => {
			in_geo.dispose();
		});
		this.#setCache('receiver', merged);
		merged.layers.set(cPart.receiverLayer);
		if (DEBUG) {
			merged.visible = true;
		} else {
			merged.visible = false;
		}
	}
	receiverStart(in_vec3 = null) {
		const recv = this.#getCache('receiver');
		if (in_vec3) {
			// in_vec3 : assume raycaster.ray.direction.negate()
			this.#setCache('raycastn', in_vec3);
			recv.lookAt(in_vec3);
		}
		this.add(recv);
	}
	receiverStop() {
		this.#setCache('raycastn', null);
		this.remove(this.#getCache('receiver'));
	}
	#lookAtWithoutRotation(in_vec3) {
		// target direction
		const dstVec3 = in_vec3.clone().normalize();
		/*
			*** NOTE #3 ***
			Cached current frontvec should be cloned before applyQuaternion.
			Without it cached will be broken.
		*/
		const srcVec3 = (this.#getCache('frontvec')).clone().applyQuaternion(this.quaternion);
		// get quaternion to rotate from srcVec3 to dstVec3
		const quat = (new THREE.Quaternion()).setFromUnitVectors(srcVec3, dstVec3);
		this.quaternion.multiplyQuaternions(quat, this.quaternion);
	}
	lookAt(in_vec3, in_normal = null) {
		if (in_normal) {
			in_vec3.projectOnPlane(in_normal);
			this.#lookAtWithoutRotation(in_vec3);
		} else {
			super.lookAt(in_vec3);
		}
		const direction = this.#getCache('raycastn');
		if (direction) {
			this.#getCache('receiver').lookAt(direction);
		}
	}
}

/*
	(4) cArm

	cArm
	|
	+-- CapsuleGeometry
	|
	+-- cArm
		|
		+-- CapsuleGeometry
		|
		+-- cArm ...
*/

class cArm extends cPart {
	static create(in_length, in_circumference, in_material, in_pathCnt, in_recurse = false) {
		if (in_pathCnt == 0) {
			return null;
		}
		const curr = new cArm(in_length, in_circumference, in_material);
		const next = cArm.create(in_length, in_circumference, in_material, in_pathCnt - 1, true);
		if (next) {
			curr.add(next);
		}
		if (in_recurse) {
			// local position of parent
			curr.position.z = in_length - in_circumference * 2;
		}
		return curr;
	}
	constructor(in_length, in_circumference, in_material) {
		/*
			++-----++ : arm + joint = in_length
			  -----   : arm = in_length - in_circumference * 2
		*/
		const receiverRadius = in_length - in_circumference * 2;
		const geometry = new CustomCapsule(in_circumference, receiverRadius);
		super(receiverRadius, geometry, in_material);
	}
	addToEdge(in_obj) {
		const scale = 1.1;
		let edge = this;
		let isEdge = false;
		while (!isEdge) {
			isEdge = !edge.children.some(in_child => {
				if (in_child instanceof cArm) {
					edge = in_child;
					return true;
				}
				return false;
			});
		}
		const box = (new THREE.Box3()).setFromObject(edge);
		const sphere = new THREE.Sphere();
		box.getBoundingSphere(sphere);
		in_obj.position.z = sphere.radius * scale;
		edge.add(in_obj);
	}
}

class cHead extends cPart {
	constructor(in_radius, in_material) {
		const receiverRadius = in_radius * 2;
		const geometry = new CustomSphere(in_radius);
		super(receiverRadius, geometry, in_material);
	}
}

class cSmartPhone extends cPart {
	constructor(in_width, in_height, in_radius, in_material) {
		const receiverRadius = in_height;
		const geometry = trapezoidGeometry(in_width, in_width, in_height, in_radius);
		super(receiverRadius, geometry, in_material);
	}
}

class cLightSaber extends cPart {
	constructor(in_length, in_radius, in_material) {
		const receiverRadius = in_length;
		const geometry = new CustomCapsule(in_radius, in_length);
		super(receiverRadius, geometry, in_material);
		const grip = new THREE.Mesh(new CustomCapsule(in_radius * 1.5, in_length * 0.2), in_material);
		grip.rotateX(Math.PI/2)
		this.add(grip);
	}
}

/*
	(5) cBody

	Object3D
	|
	+-- cPart ( chest )
	|	|
	|	+-- trapezoidGeometry
	|	|
	|	+-- cHead
	|	|
	|	+-- cArm ( r-arm )
	|	|
	|	+-- cArm ( l-arm )
	|
	+-- cPart ( waist )
		|
		+-- trapezoidGeometry
		|
		+-- cArm ( r-leg )
		|
		+-- cArm ( l-leg )
*/

function trapezoidGeometryUtil(in_tXLen, in_tZLen, in_bXLen, in_bZLen, in_YLen, in_Rad = 0) {
	const parts = [];
	const DEG90 = Math.PI * 1 / 2;
	/*
			 (+)
			  |
			  0-----1
			 /|    /|
			3-----2 |
			| |   | |
		   -|-4---|-5---(+)
			|/|   |/
			7-----6
		   /  |
		 (+)
	*/
	const baseVertices = {
		v0 : VEC3(in_tXLen / 2 * -1, in_YLen / 2 * +1, in_tZLen / 2 * -1),
		v1 : VEC3(in_tXLen / 2 * +1, in_YLen / 2 * +1, in_tZLen / 2 * -1),
		v2 : VEC3(in_tXLen / 2 * +1, in_YLen / 2 * +1, in_tZLen / 2 * +1),
		v3 : VEC3(in_tXLen / 2 * -1, in_YLen / 2 * +1, in_tZLen / 2 * +1),
		v4 : VEC3(in_bXLen / 2 * -1, in_YLen / 2 * -1, in_bZLen / 2 * -1),
		v5 : VEC3(in_bXLen / 2 * +1, in_YLen / 2 * -1, in_bZLen / 2 * -1),
		v6 : VEC3(in_bXLen / 2 * +1, in_YLen / 2 * -1, in_bZLen / 2 * +1),
		v7 : VEC3(in_bXLen / 2 * -1, in_YLen / 2 * -1, in_bZLen / 2 * +1)
	};
	/*
		1. Surface (BufferGeometry)
			even you can also make surface using PlaneGeometry,
			it is a little complicated to decide position before rotation.
	*/
	const surfaceMap = new Map([
		[DIRECTION.XP, [baseVertices.v1, baseVertices.v2, baseVertices.v6, baseVertices.v5]],
		[DIRECTION.XN, [baseVertices.v0, baseVertices.v4, baseVertices.v7, baseVertices.v3]],
		[DIRECTION.YP, [baseVertices.v3, baseVertices.v2, baseVertices.v1, baseVertices.v0]],
		[DIRECTION.YN, [baseVertices.v6, baseVertices.v7, baseVertices.v4, baseVertices.v5]],
		[DIRECTION.ZP, [baseVertices.v7, baseVertices.v6, baseVertices.v2, baseVertices.v3]],
		[DIRECTION.ZN, [baseVertices.v5, baseVertices.v4, baseVertices.v0, baseVertices.v1]]
	]);
	const translatedSurfaceMap = new Map();
	const equal = (in_vec, ...in_vecArr) => in_vecArr.some(vec => in_vec.equals(vec));
	surfaceMap.forEach((in_val, in_key) => {
		let translate;
		if (equal(in_key, DIRECTION.YP, DIRECTION.YN)) {
			// top or bottom
			translate = in_key.clone().multiplyScalar(in_Rad);
		} else {
			const normal = VEC3();
			in_val[forEachCombination](3, (a, b, c) => {
				let v1 = (VEC3()).subVectors(a, b);
				let v2 = (VEC3()).subVectors(b, c);
				if ((v1.lengthSq() > 0) && (v2.lengthSq() > 0)) {
					normal.crossVectors(v1, v2);
					if (normal.lengthSq() > 0) {
						normal.normalize();
						return true;
					}
				}
				return false;
			});
			translate = normal.multiplyScalar(in_Rad);
		}
		const vertices = [];
		in_val.forEach(in_vertex => {
			vertices.push(in_vertex.clone().add(translate));
		});
		translatedSurfaceMap.set(in_key, vertices);
	});
	for (const vertices of translatedSurfaceMap.values()) {
		const uniqueFilter = (in_vertices) => {
			const unique = [];
			in_vertices.forEach(in_vertex => {
				if (unique.some(in_v => in_v.equals(in_vertex))) {
					return;
				}
				unique.push(in_vertex);
			});
		    return unique;
		};
		const unique = uniqueFilter(vertices);
		if (unique.length < 3) {
			continue;
		}
		const geometry = new THREE.BufferGeometry();
		const flat = [];
		unique.forEach(in_vec3 => {
			flat.push(in_vec3.x, in_vec3.y, in_vec3.z);
		});
		geometry.setAttribute('position', new THREE.Float32BufferAttribute(flat, 3));
		let ix, uv;
		if (unique.length === 3) {
			ix = [0, 1, 2];
			uv = [0, 0, 1, 0, 0.5, 1];
		} else {
			ix = [0, 1, 2, 0, 2, 3];
			uv = [0, 0, 1, 0, 1, 1, 0, 1];
		}
		geometry.setIndex(ix);
		geometry.setAttribute('uv', new THREE.Float32BufferAttribute(new Float32Array(uv), 2));
		geometry.computeVertexNormals();
		geometry.userData.surface = true;
		parts.push(geometry);
	}
	/*
		2. Edge (CylinderGeometry)
			2.1. Edge for top & bottom surface (applying rotation by prepared setting)
			2.2. Edge for sloped side surface (applying rotation automatically)
	*/
	const makeEdgeCylinder = (in_height, in_start, in_theta) => {
		const defaultRadialSegments = 32;
		const defaultHeightSegments = 1;
		const openEnded = true;
		return new THREE.CylinderGeometry(
			in_Rad,
			in_Rad,
			in_height,
			defaultRadialSegments,
			defaultHeightSegments,
			openEnded,
			in_start,
			in_theta
		);
	};
	const rotate = (in_geo, in_vec) => {
		const rotateAxes = {x : 'rotateX', y : 'rotateY', z : 'rotateZ'};
		for (const [axis, method] of Object.entries(rotateAxes)) {
			in_geo[method](in_vec[axis]);
		}
	};
	const centroid = (in_vecArr) => {
		const ret = new THREE.Vector3();
		in_vecArr.forEach(in_vector => {
			ret.add(in_vector);
		});
		return ret.divideScalar(in_vecArr.length);
	};
	const theta = (a, b) => Math.atan(Math.abs(a - b) / 2 / in_YLen) * (a > b ? +1 : -1);
	const thetaX = theta(in_tXLen, in_bXLen);
	const thetaZ = theta(in_tZLen, in_bZLen);
	const edgeConfigSet1 = [
		/*
			E : Edge (Vector3 x2)
			R : Rotation from Vector3(0, 1, 0)
			P : Parameter for THREE.CylinderGeometry
		*/
		{E : [baseVertices.v2, baseVertices.v3], R : VEC3(0, 0, DEG90 * -1), P : [DEG90 * 3, DEG90 + thetaZ]},
		{E : [baseVertices.v3, baseVertices.v0], R : VEC3(DEG90 * +1, 0, 0), P : [DEG90 * 2, DEG90 + thetaX]},
		{E : [baseVertices.v0, baseVertices.v1], R : VEC3(0, 0, DEG90 * +1), P : [DEG90 * 1, DEG90 + thetaZ]},
		{E : [baseVertices.v1, baseVertices.v2], R : VEC3(DEG90 * -1, 0, 0), P : [DEG90 * 0, DEG90 + thetaX]},
		{E : [baseVertices.v6, baseVertices.v7], R : VEC3(0, 0, DEG90 * +1), P : [DEG90 * 3, DEG90 - thetaZ]},
		{E : [baseVertices.v7, baseVertices.v4], R : VEC3(DEG90 * -1, 0, 0), P : [DEG90 * 2, DEG90 - thetaX]},
		{E : [baseVertices.v4, baseVertices.v5], R : VEC3(0, 0, DEG90 * -1), P : [DEG90 * 1, DEG90 - thetaZ]},
		{E : [baseVertices.v5, baseVertices.v6], R : VEC3(DEG90 * +1, 0, 0), P : [DEG90 * 0, DEG90 - thetaX]}
	];
	const edgeConfigSet2 = [
		{E : [baseVertices.v3, baseVertices.v7], P : [DEG90 * 3, DEG90]},
		{E : [baseVertices.v0, baseVertices.v4], P : [DEG90 * 2, DEG90]},
		{E : [baseVertices.v1, baseVertices.v5], P : [DEG90 * 1, DEG90]},
		{E : [baseVertices.v2, baseVertices.v6], P : [DEG90 * 0, DEG90]}
	];
	edgeConfigSet1.forEach(in_conf => {
		const length = in_conf.E[0].distanceTo(in_conf.E[1]);
		if (length === 0) {
			return;
		}
		const geometry = makeEdgeCylinder(length, in_conf.P[0], in_conf.P[1]);
		rotate(geometry, in_conf.R);
		geometry.translate(centroid(in_conf.E));
		geometry.userData.surface = false;
		parts.push(geometry);
	});
	const vertical = VEC3(0, 1, 0);
	edgeConfigSet2.forEach(in_conf => {
		const length = in_conf.E[0].distanceTo(in_conf.E[1]);
		const geometry = makeEdgeCylinder(length, in_conf.P[0], in_conf.P[1]);
		/*
			at first, I mistook it for the opposite direction.
			( in_conf.E[0] --> in_conf.E[1] )
			because of it, parameter of theta couldn't be stable.
		*/
		const slope = in_conf.E[0].clone().sub(in_conf.E[1]).normalize();
		const quaternion = new THREE.Quaternion();
		quaternion.setFromUnitVectors(vertical, slope);
		geometry.applyQuaternion(quaternion);
		geometry.translate(centroid(in_conf.E));
		geometry.userData.surface = false;
		parts.push(geometry);
	});
	/*
		3. Corner (SphereGeometry)
	*/
	const makeCornerSphere = (in_phi_start, in_theta_start, in_theta) => {
		const error = 0.01;
		const widthSegments = 32;
		const heightSegments = 16;
		return new THREE.SphereGeometry(
			in_Rad,
			widthSegments,
			heightSegments,
			in_phi_start - error,
			DEG90 + error * 2,
			in_theta_start - error,
			in_theta + error * 2
		);
	};
	const uTheta = (in_tXLen > in_bXLen) || (in_tZLen > in_bZLen) ? DEG90 * 2 : DEG90 * 1;
	const bTheta = (in_tXLen < in_bXLen) || (in_tZLen < in_bZLen) ? DEG90 * 2 : DEG90 * 1;
	const cornerConfigSet = [
		/*
			C : Corner (Vector3 x1)
			P : Parameter for THREE.SphereGeometry
		*/
		{C : baseVertices.v0, P : [DEG90 * 3, 0, uTheta]},
		{C : baseVertices.v1, P : [DEG90 * 2, 0, uTheta]},
		{C : baseVertices.v2, P : [DEG90 * 1, 0, uTheta]},
		{C : baseVertices.v3, P : [DEG90 * 0, 0, uTheta]},
		{C : baseVertices.v4, P : [DEG90 * 3, DEG90 * 2 - bTheta, bTheta]},
		{C : baseVertices.v5, P : [DEG90 * 2, DEG90 * 2 - bTheta, bTheta]},
		{C : baseVertices.v6, P : [DEG90 * 1, DEG90 * 2 - bTheta, bTheta]},
		{C : baseVertices.v7, P : [DEG90 * 0, DEG90 * 2 - bTheta, bTheta]}
	];
	cornerConfigSet.forEach(in_conf => {
		const geometry = makeCornerSphere(...in_conf.P);
		geometry.translate(in_conf.C);
		geometry.userData.surface = false;
		parts.push(geometry);
	});
	// assume order of groups ( BufferGeometry x6, other geometries ... )
	const groups = [];
	let edgeGroup = 0;
	const mergedGeometry = UTILS.mergeGeometries(parts);
	parts.forEach(in_part => {
		if (in_part.userData.surface) {
			groups.push(in_part.index.count);
		} else {
			edgeGroup += in_part.index.count;
		}
		in_part.dispose();
	});
	groups.push(edgeGroup);
	let start = 0;
	for (let i = 0; i < groups.length; i++) {
		mergedGeometry.addGroup(start, groups[i], i);
		start += groups[i];
	}
	return mergedGeometry;
}

function roundBoxGeometry(in_xlen, in_ylen, in_zlen, in_rad) {
	return trapezoidGeometryUtil(in_xlen, in_zlen, in_xlen, in_zlen, in_ylen, in_rad);
}

function roundRegularBoxGeometry(in_len, in_rad) {
	return trapezoidGeometryUtil(in_len, in_len, in_len, in_len, in_len, in_rad);
}

function trapezoidGeometry(in_tLen, in_bLen, in_height, in_thickness) {
	return trapezoidGeometryUtil(in_tLen, 0, in_bLen, 0, in_height, in_thickness);
}

class cBody extends THREE.Object3D {
	static #cacheKeys = {
		chest : Symbol(),
		waist : Symbol(),
		headRoot : Symbol(),
		armNRoot : Symbol(),
		armPRoot : Symbol(),
		legNRoot : Symbol(),
		legPRoot : Symbol()
	};
	#getCache(in_key) {
		return this.userData[cBody.#cacheKeys[in_key]];
	}
	#setCache(in_key, in_value) {
		this.userData[cBody.#cacheKeys[in_key]] = in_value;
	}
	constructor(in_tLen, in_bLen, in_height, in_thickness, in_material) {
		super();
		const chest = new cPart(
			in_height / 2,
			/*
				z : moved side : in_tLen
				0 : fixed side : (in_tLen + in_bLen) / 2
			*/
			trapezoidGeometry(in_tLen, (in_tLen + in_bLen) / 2, in_height / 2, in_thickness / 2),
			in_material
		);
		this.add(chest);
		this.#setCache('chest', chest);
		this.#setCache('headRoot', new THREE.Vector3(0, 0, in_height / 2 + in_thickness / 4));
		this.#setCache('armNRoot', new THREE.Vector3(in_tLen / 2 * -1, 0, in_height / 2));
		this.#setCache('armPRoot', new THREE.Vector3(in_tLen / 2 * +1, 0, in_height / 2));
		const waist = new cPart(
			in_height / 2,
			/*
				z : moved side : in_bLen 
				0 : fixed side : (in_tLen + in_bLen) / 2 
			*/
			trapezoidGeometry(in_bLen, (in_tLen + in_bLen) / 2, in_height / 2, in_thickness / 2),
			in_material
		);
		waist.rotateX(Math.PI);
		this.add(waist);
		this.#setCache('waist', waist);
		this.#setCache('legNRoot', new THREE.Vector3(in_bLen / 2 * -1, 0, in_height / 2));
		this.#setCache('legPRoot', new THREE.Vector3(in_bLen / 2 * +1, 0, in_height / 2));
		this.rotateX(Math.PI / 2 * -1);
	}
	#addObject(in_added, in_target, in_where, in_dx, in_dy, in_dirVec3) {
		if (in_dirVec3) {
			in_added.lookAt(in_dirVec3);
		} else {
			in_added.lookAt(this.#getCache(in_where));
		}
		in_added.position.copy(this.#getCache(in_where));
		in_added.position.x += in_dx;
		in_added.position.y += in_dy;
		this.#getCache(in_target).add(in_added);
	}
	addHead(in_added, in_dx = 0, in_dy = 0, in_dirVec3 = null) {
		this.#addObject(in_added, 'chest', 'headRoot', in_dx, in_dy, in_dirVec3);
	}
	addArmNegative(in_added, in_dx = 0, in_dy = 0, in_dirVec3 = null) {
		this.#addObject(in_added, 'chest', 'armNRoot', in_dx, in_dy, in_dirVec3);
	}
	addArmPositive(in_added, in_dx = 0, in_dy = 0, in_dirVec3 = null) {
		this.#addObject(in_added, 'chest', 'armPRoot', in_dx, in_dy, in_dirVec3);
	}
	addLegNegative(in_added, in_dx = 0, in_dy = 0, in_dirVec3 = null) {
		this.#addObject(in_added, 'waist', 'legNRoot', in_dx, in_dy, in_dirVec3);
	}
	addLegPositive(in_added, in_dx = 0, in_dy = 0, in_dirVec3 = null) {
		this.#addObject(in_added, 'waist', 'legPRoot', in_dx, in_dy, in_dirVec3);
	}
	#reset(in_callback) {
		const recursive = (in_obj) => {
			if (in_obj instanceof THREE.Mesh) {
				(in_callback)(in_obj);
			}
			in_obj.children.forEach(in_child => {
				(recursive)(in_child);
			});
		};
		(recursive)(this);
	}
	resetMaterial(in_material) {
		this.#reset(in_mesh => {
			in_mesh.material = in_material;
		});
	}
	cloneMergedGeometry() {
		const recursive = (in_obj) => {
			const tmpArr = [];
			if (in_obj instanceof THREE.Mesh) {
				const geoClone = in_obj.geometry.clone();
				geoClone.applyMatrix4(in_obj.matrixWorld);
				tmpArr.push(geoClone);
			}
			in_obj.children.forEach(in_child => {
				tmpArr.push(...(recursive)(in_child));
			});
			return tmpArr;
		};
		const geometries = (recursive)(this);
		const mergedGeometry = UTILS.mergeGeometries(geometries);
		geometries.forEach(in_geometry => {
			in_geometry.dispose();
		});
		return mergedGeometry;
	}
}

/*
	(6) dom setting : show canvas element as size of all over body element.
*/

const WORLD_RADIUS = 1000;

const gWorld = new cSphericalWorld(WORLD_RADIUS);

const TRANSPARENT_IMAGE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADBJREFUOE9jTEtL+8+ABxgbG+OTZmAcNWBYhMHMmTPxpoOzZ8/iTwejBjAwDv0wAADSgj/p4jinSwAAAABJRU5ErkJggg==';

document.addEventListener('DOMContentLoaded', (() => {
	let resizeWorld = (() => {
		gWorld.resize(
			window.innerWidth,
			window.innerHeight);
	});
	window.addEventListener('resize', resizeWorld);
	(resizeWorld)();
	if (!document.body) {
		document.documentElement.appendChild(document.createElement('BODY'));
	}
	document.body.style.margin = '0';
	document.body.appendChild(gWorld.canvas);
	Object.assign(document.body.style, {
		backgroundImage : 'url(' + TRANSPARENT_IMAGE + ')',
		backgroundRepeat : 'repeat',
		backgroundSize : 'auto'
	});
	gWorld.start();
}));

/*
	(7) figure setting : color, material, and figure
*/

class cCyclicValues extends Array {
	constructor(...args) {
		super(...args);
		this.currentIndex = 0;
	}
	currValue() {
		return this[this.currentIndex];
	}
	nextValue() {
		this.currentIndex = (this.currentIndex + 1) % this.length;
		return this.currValue();
	}
}

const COLORS = new cCyclicValues(
	// gold
	0xFFD700,
	// orangered
	0xFF4500,
	// pink
	0xEEBEC9,
	// green
	0x008000,
	// dodgerblue
	0x1E90FF,
	// royalblue
	0x4169E1,
	// darkgoldenrod
	0xB8860B,
	// lightgray
	0xD3D3D3,
	// gray
	0x808080
);

const ROUGHNESS = 0.3;

const initColor = COLORS.currValue();

const MATERIALS = new cCyclicValues(
	new THREE.MeshStandardMaterial({color: initColor, roughness: ROUGHNESS}),
	new THREE.MeshToonMaterial({color: initColor}),
	new THREE.MeshBasicMaterial({color: initColor})
);

const INITFUNCS = {
	ARM : {
		NEGATIVE : 'addArmNegative',
		POSITIVE : 'addArmPositive'
	},
	LEG : {
		NEGATIVE : 'addLegNegative',
		POSITIVE : 'addLegPositive'
	}
}

const FIGURES = new cCyclicValues(
	{
		HEAD_HIGHT : 100,
		THICKNESS : 50,
		BODY : {
			SHOULDER : 160,
			WAIST : 120,
			HEIGHT : 200
		},
		ARM : {
			LENGTH : 200,
			NEGATIVE : {
				DX : 0,
				DY : 0,
				DIR : null
			},
			POSITIVE : {
				DX : 0,
				DY : 0,
				DIR : null
			}
		},
		LEG : {
			LENGTH : 250,
			NEGATIVE : {
				DX : 0,
				DY : 0,
				DIR : null
			},
			POSITIVE : {
				DX : 0,
				DY : 0,
				DIR : null
			}
		},
		OBJECT : null,
		ITEMHOLDER : null
	},
	{
		HEAD_HIGHT : 100,
		THICKNESS : 45,
		BODY : {
			SHOULDER : 100,
			WAIST : 180,
			HEIGHT : 200
		},
		ARM : {
			LENGTH : 190,
			NEGATIVE : {
				DX : 0,
				DY : 0,
				DIR : new THREE.Vector3(-1, 0, -1)
			},
			POSITIVE : {
				DX : 0,
				DY : 0,
				DIR : new THREE.Vector3(+1, 0, -1)
			}
		},
		LEG : {
			LENGTH : 220,
			NEGATIVE : {
				DX : +35,
				DY : 0,
				DIR : new THREE.Vector3(0, 0, 1)
			},
			POSITIVE : {
				DX : -35,
				DY : 0,
				DIR : new THREE.Vector3(0, 0, 1)
			}
		},
		OBJECT : null,
		ITEMHOLDER : null
	},
	{
		HEAD_HIGHT : 100,
		THICKNESS : 45,
		BODY : {
			SHOULDER : 120,
			WAIST : 120,
			HEIGHT : 200
		},
		ARM : {
			LENGTH : 200,
			NEGATIVE : {
				DX : 0,
				DY : 0,
				DIR : new THREE.Vector3(-1, 0, -1)
			},
			POSITIVE : {
				DX : 0,
				DY : 0,
				DIR : new THREE.Vector3(+1, 0, -1)
			}
		},
		LEG : {
			LENGTH : 230,
			NEGATIVE : {
				DX : 0,
				DY : 0,
				DIR : new THREE.Vector3(0, 0, 1)
			},
			POSITIVE : {
				DX : 0,
				DY : 0,
				DIR : new THREE.Vector3(0, 0, 1)
			}
		},
		OBJECT : null,
		ITEMHOLDER : null
	}
);

const gInitMaterial = MATERIALS.currValue();

const gLightSaber = new cLightSaber(300, 10, gInitMaterial);
const gSmartPhone = new cSmartPhone(40, 80, 5, gInitMaterial);

FIGURES.forEach(in_fig => {
	// ugh! : this calculation should be hidden by class
	let thick = in_fig.THICKNESS;
	let head = in_fig.HEAD_HIGHT / 2;
	let shoulder = in_fig.BODY.SHOULDER - thick;
	let waist = in_fig.BODY.WAIST - thick;
	let height = in_fig.BODY.HEIGHT - thick;
	// body
	in_fig.OBJECT = new cBody(shoulder, waist, height, thick, gInitMaterial);
	// head
	in_fig.OBJECT.addHead(new cHead(head, gInitMaterial));
	// arm x2 + leg x2
	for (let part in INITFUNCS) {
		let length = (in_fig[part].LENGTH - thick) / 2 + thick;
		let circumference = thick / 2
		for (let subpart in INITFUNCS[part]) {
			let dx = in_fig[part][subpart].DX;
			let dy = in_fig[part][subpart].DY;
			let dir = in_fig[part][subpart].DIR;
			let obj = cArm.create(length, circumference, gInitMaterial, 2);
			if (part + '.' + subpart === 'ARM.NEGATIVE') {
				in_fig.ITEMHOLDER = obj;
			}
			(in_fig.OBJECT[INITFUNCS[part][subpart]])(obj, dx, dy, dir);
		}
	}
	/*
		*** NOTE #4 ***
		Adhoc!! without this process, morphing will be failed.
		Maybe some initializ process, which includs scene.add(), is required.
	*/
	gWorld.add(in_fig.OBJECT);
	gWorld.remove(in_fig.OBJECT);
});

gWorld.add((FIGURES.currValue()).OBJECT);

/*
	(8) ui setting
*/

function uiChangeColor() {
	const currColor = new THREE.Color(COLORS.currValue());
	const nextColor = new THREE.Color(COLORS.nextValue());
	let delta = 0.05;
	let interpolation = 0;
	const hook = () => {
		interpolation += delta;
		if (interpolation < 1) {
			let tempColor = currColor.clone().lerp(nextColor, interpolation);
			(MATERIALS.currValue()).color.setHex(tempColor.getHex());
		} else {
			gWorld.removeAnimationHook(hook);
			MATERIALS.forEach(in_material => {
				in_material.color.setHex(nextColor.getHex());
			});
		}
	};
	gWorld.addAnimationHook(hook);
}

function uiChangeMaterial() {
	const material = MATERIALS.nextValue();
	const color = 0xEEEEEE;
	gWorld.motionFog(color, 0, 100, 200).then(() => {
		FIGURES.forEach(in_fig => {
			in_fig.OBJECT.resetMaterial(material);
		});
		return gWorld.motionFog(color, 100, 50, 200);
	});
}

function uiChangeFigure() {
	const currFigure = FIGURES.currValue();
	const nextFigure = FIGURES.nextValue();
	const currItem = ITEMS.currValue();
	if (currItem) {
		currItem.parent.remove(currItem);
	}
	// use tempFigure only during morphing
	const begore = currFigure.OBJECT.cloneMergedGeometry();
	const after = nextFigure.OBJECT.cloneMergedGeometry();
	begore.morphAttributes.position = [after.attributes.position];
	const tempFigure = new THREE.Mesh(begore, MATERIALS.currValue());
	let morph = 0;
	const hook = () => {
		if (morph > 1) {
			gWorld.removeAnimationHook(hook);
			gWorld.remove(tempFigure);
			gWorld.add(nextFigure.OBJECT);
			begore.dispose();
			after.dispose();
			if (currItem) {
				nextFigure.ITEMHOLDER.addToEdge(currItem);
			}
		} else {
			morph += 0.05;
			tempFigure.morphTargetInfluences[0] = morph;
		}
	};
	gWorld.remove(currFigure.OBJECT);
	gWorld.add(tempFigure);
	gWorld.addAnimationHook(hook);
}

const ITEMS = new cCyclicValues(null, gSmartPhone, gLightSaber);

function uiChangeItem() {
	gWorld.motionKnock().then(() => {
		const currItem = ITEMS.currValue();
		const nextItem = ITEMS.nextValue();
		if (currItem) {
			currItem.parent.remove(currItem);
		}
		if (nextItem) {
			(FIGURES.currValue()).ITEMHOLDER.addToEdge(nextItem);
		}
	});
}

function uiDefaultView() {
	gWorld.motionDefaultView();
}

async function uiOneMoreFigure() {
	const currFigure = FIGURES.currValue();
	const geometry = currFigure.OBJECT.cloneMergedGeometry();
	const fixedMesh = new THREE.Mesh(geometry, MATERIALS.currValue());
	fixedMesh.raycast = () => {};
	gWorld.remove(currFigure.OBJECT);
	gWorld.add(fixedMesh);
	const rand = (min, max) => {
		return Math.random() * (max - min) + min;
	};
	gWorld.startRotation(new THREE.Vector3(
		rand(0.01, 0.005),
		rand(0.01, 0.005),
		rand(0.01, 0.005)
	));
	const vec3 = gWorld.getLookAt().normalize();
	await gWorld.easeOut(0, 400, 500, (in_currentValue) => {
		fixedMesh.position.copy(vec3.clone().multiplyScalar(in_currentValue));
	});
	gWorld.stopRotation();
	gWorld.add(currFigure.OBJECT);
}

const clipClearArea = Symbol();

HTMLCanvasElement.prototype[clipClearArea] = function(in_margin) {
	const w = this.width;
	const h = this.height;
	let ctx = this.getContext('2d');
	if (!ctx) {
		/*
			*** NOTE #5 ***
			Sometimes can't get 2D context ( ex. Three.js ).
			So, to get it, copy bitmap to alternative canvas.
		*/
		const alternative = document.createElement('canvas');
		alternative.width = w;
		alternative.height = h;
		ctx = alternative.getContext('2d');
		ctx.drawImage(this, 0, 0);
	}
	const rgbaMap = (ctx.getImageData(0, 0, w, h)).data;
	let l = Number.POSITIVE_INFINITY;
	let t = Number.POSITIVE_INFINITY;
	let r = Number.NEGATIVE_INFINITY;
	let b = Number.NEGATIVE_INFINITY;
	for (let y = 0; y < h; y++) {
		for (let x = 0; x < w; x++) {
			if (rgbaMap[(y * w + x) * 4 + 3] > 0) {
				if (x < l) {
					l = x;
				}
				if (y < t) {
					t = y;
				}
				if (x > r) {
					r = x;
				}
				if (y > b) {
					b = y;
				}
			}
		}
	}
	l = Math.max(l - in_margin, 0);
	t = Math.max(t - in_margin, 0);
	r = Math.min(r + in_margin, w - 1);
	b = Math.min(b + in_margin, h - 1);
	return {
		l : l,
		t : t,
		r : r,
		b : b,
		w : r - l + 1,
		h : b - t + 1
	};
};

const METACHAR1 = '@'
const METACHAR2 = ',';

function simpleCompress(input) {
	let output = '';
	let i = 0;
	while (i < input.length) {
		let count = 1;
		while (i + 1 < input.length && input[i] === input[i + 1]) {
			i++;
			count++;
		}
		if (count >= 4) {
			output += METACHAR1 + input[i] + count + METACHAR2;
		} else {
			output += input[i].repeat(count);
		}
		i++;
	}
	return output;
}

function simpleDecompress(input) {
	let output = '';
	let i = 0;
	while (i < input.length) {
		if (input[i] === METACHAR1) {
			let char = input[i + 1];
			let count = '';
			i += 2;
			while (i < input.length && input[i] !== METACHAR2) {
				count += input[i];
				i++;
			}
			output += char.repeat(parseInt(count, 10));
			// to skip METACHAR2
			i++;
		} else {
			output += input[i];
			i++;
		}
	}
	return output;
}

const SHUTTER = new Audio('data:audio/mpeg;base64,' + simpleDecompress('SUQzB@A7,alRQRTE@A4,KAAADT3RvTG9naWMAVElUMgAAABIAAANDYW1lcmEtUGhvbmUwMy0xAFRBTEI@A4,NAAADT3RvTG9naWMtU0UAVFNTRQ@A4,8AAANMYXZmNTguMjkuMTAw@A14,D/+1@A44,BJbmZv@A4,DwAAAEYAAB1iAAoOEREVGBgcHyMjJyoqLjExNTg8PD9DQ0dKSk5RVVVYXFxfY2Nnam5ucXV1eHx8gIOHh4qOjpGVlZicn5+jp6eqrq6xtbi4vL+/w8fHys7R0dXY2Nzg4OPn6uru8fH1+Pj8/w@A4,BMYXZjNTguNTQ@A8,gK@A6,kBK8@A8,dYmSaAZ8@A21,//sQZAAP8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,EISAf//l8TvqBBf/j/iYAzxZIGFK/gDJwGEAAIf24DAcDQDgbBANjn38DPiwxmVwAAQAAP//8oGAB8P6CQAACAAP1MNH/+xJkIg/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,QbCgnEoAtTFxDbFyJgRPI5S2qKyt/rVff6XfIS4AEQAADJ8wX3ud9CCZhmZmA8AAD+EaJxKHMAB+C3csAAAkgAD//ctX//+xBkRI/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,RKlAW2lEDJDwUMEDhceRWDJBZHTxdqlhJKO9/z9vvqYs3VA/sAAGwsl3ZhEJEG9K1Hrg2nC1aVqcv+dhgEYABNf/33+f/7EmRmjfAEAIAAIAAIAAANI@A4,QEgANR0AQAgAAA0goAABGSgDbMskTdUDnDBjQ6tCnoTUIAkDIa9NEx/ls3ESgAISACCKAAAUuk5MaLHnSZtpEzyAMUIQ1Ek6lQbI0aIqKitiiCBGf/7EGSEAAEmHVMGHoAACQAWZcAIAIUUYXd4dIAALQcZlwAgAFl0QH+jU+od/IkawPkABbCG2QXVLMoZA28mAhWuW3yRwinjtQAl/+Th4dUAWoEANqyiOhQqgS4FgI0xJkKxsE16f70A//sSZHUBkJoHZfcMIAwLoAY54AgBAqABdICERMApABfUIIjghIAB/7raPf1jxdoyiAgaObhgKBJgZXcPdyDbCiCyXtUzMVk11kHETpCVAJBmAAAMEakelCoHeFVVQj6AANco4HYlHXLw//sQZHgDEMoNWcAGGUIKgBZWAEIBAfwfcIAEYmAvAFfgAIgEZKuw6aidevtE2kAwAAA8h+KAYRsPbaFAbVlAAt7iUGH3bEHQZoh4PFsZT+q9fUY1C88CuS+9IkplFxlooIMVA/vsjIT/+xJkegGxRxhaaAZJ0glgBZEAQjiDHF1vAARkABkAG9AADASoAAEdptJ5sjwsbKKIkrvdrFOmewMsFZeuR6TcFiXLZPpYBdK6IYAQuGtgU5pTwNJKsoolbYzVfGxPbe+7rrCd5zQ3cAH/+xBkc4EwwBBaIAEZAgpAFyYAAwEEGGFroLBC0CiAK3gACAQAhQEOUzi9Uv5B3QTVAE1jgFqxSES2ddRxNvrQRGz/I6KgNawEBWCQDQepLij6r/SB/9bUsAvTDikJOle8/5sXndhGIv/7EmRugXDSCd/wCDAsDSAKaAAjOIMQOWCABMIIOgPhQFfolG2/RIEJfbk1zSUAe1EgQBJIOZxvm1bZQKnKry8do1U9IqABjgAA0kKbBMp7B/r7ngATDOqgCIoO4ftj+AWUgx3sUPyPlv/7EGRpgRC+B2FoATCMDuEocADPBQREQWvgISLINgAo7ACMAH7SKgCYZ0RAIg4AACGQZjTofTmBUMETdGz7PFR@A4,P5XXCAAgQgHiOOwAH/2g6pESkXGz6vy/GUy2AiNUiM8EtNQAK//sSZGABMKQO2yABQQAOoBq0ACMAAiwXi4AMIrgxARxACwgAggCWfEEqlSwzKAvywAQA/+QiBb/+KtV1mGFMBMGg89ru0RB2pgOB+WXEklSrZ2LV/DQdCVLiQhBofDXiargbYdBjaEVQ//sQZGIDcLsQW9gBQVIOgJr0AAYEAYAbocAMRHguAmmgAAwKFhgQXwYiQIwdoVd/iksCtyRa4LBjfwmkEGBJzTiFADwH/+3U8kSaSFgAAA///KmVC0ipYkAEgH+WIt/8tIs///wkFZ7/+xJkZQPwxgnkeAEwjA5jmQMA4rKBZAOYgABAMDGOYcANzwA6RUxBTUUzLjEwMF@V34,TEFNRTMuMTAw@V30,X/+xBkaAmQcxBaQAEasAmAFsUAIgGBvDdWAABkwC4AabAAjAB@V49,TEFNRTMuMTAw@V29,f/7EmRxDdBqAE+AARkwDgDm4FNVMQFQJRRAAEFQMwahBAAImF@V49,MQU1FMy4xMDB@V30,f/7EGR6CdBOAKsoAAAIC6AVYwACAQFIAJmgBEAgIIBSRACIBl@V49,MQU1FMy4xMDB@V29,//sSZIgP8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V30,//sQZKqP8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V28,X/+xJkzI/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V30,X/+xBk3Y/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V29,f/7EmTdD/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V30,f/7EGTdj/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V29,//sSZN0P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V30,//sQZN2P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V28,X/+xJk3Q/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V30,X/+xBk3Y/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V29,f/7EmTdD/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V30,f/7EGTdj/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V29,//sSZN0P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V30,//sQZN2P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V28,X/+xJk3Q/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V30,X/+xBk3Y/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V29,f/7EmTdD/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V30,f/7EGTdj/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V29,//sSZN0P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V30,//sQZN2P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V28,X/+xJk3Q/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V30,X/+xBk3Y/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V29,f/7EmTdD/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V30,f/7EGTdj/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V29,//sSZN0P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V30,//sQZN2P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V48,TEFNRTMuMTAw@V30,X/+xJk3Q/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V30,X/+xBk3Y/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V48,MQU1FMy4xMDB@V30,f/7EmTdD/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V30,f/7EGTdj/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V47,UxBTUUzLjEwMF@V30,//sSZN0P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V30,//sQZN2P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V48,TEFNRTMuMTAw@V30,X/+xBk3Y/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V29,f/7EmTdD/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V30,f/7EGTdj/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V29,//sSZN0P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V30,//sQZN2P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V28,X/+xJk3Q/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V30,X/+xBk3Y/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V29,f/7EmTdD/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V30,f/7EGTdj/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V29,//sSZN0P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V30,//sQZN2P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V49,UxBTUUzLjEwMF@V28,X/+xJk3Q/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V30,X/+xBk3Y/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V49,TEFNRTMuMTAw@V29,f/7EmTdD/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V49,MQU1FMy4xMDB@V30,f/7EGTdj/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V90,//sSZN0P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V92,//sQZN2P8AAAaQ@A4,gAAA0gAAABAAABp@A4,CAAADS@A4,E@V90,X/+xJk3Q/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V91,X/+xBk3Y/wAABp@A4,CAAADS@A4,EAAAGk@A4,IAAANI@A4,R@V90,f/7EmTdD/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V91,f/7EGTdj/AAAGk@A4,IAAANI@A4,QAAAaQ@A4,gAAA0gAAABF@V90'));

function setTransition(in_elem, in_shorthand, in_val1, in_val2) {
	const components = in_shorthand.split(/\s+/);
	in_elem.style.transition = in_shorthand;
	in_elem.style[components[0]] = in_val1;
	window.setTimeout(() => {
		/*
			*** NOTE #6 ***
			To fire the transition function,
			the final style should be set in the next event loop.
		*/
		in_elem.style[components[0]] = in_val2;
	}, 0);
}

function takeShotSound() {
	SHUTTER.play();
}

function takeShotFlash() {
	const flash = document.createElement('div');
	Object.assign(flash.style, {
		position : 'fixed',
		left : '0px',
		top : '0px',
		width : '100%',
		height : '100%',
		background : 'white',
		zIndex : 2 ** 31 - 1,
	});
	document.body.appendChild(flash);
	setTransition(flash, 'opacity 0.2s ease-out', 1, 0);
	flash.addEventListener('transitionend', () => {
		document.body.removeChild(flash);
	});
}

const CLIPMARGIN = 10;

async function uiGetScreenShot() {
	takeShotSound();
	takeShotFlash();
	/*
		*** NOTE #7 ***
		Before getting betmap, you need re-render.
		Without it, for example, you can't use canvas.toDataURL('image/png') etc. 
	*/
	gWorld.render();
	const box = gWorld.canvas[clipClearArea](CLIPMARGIN);
	const tmpElem = document.createElement('canvas');
	tmpElem.width = box.w;
	tmpElem.height = box.h;
	const ctx = tmpElem.getContext('2d');
	ctx.drawImage(gWorld.canvas, box.l, box.t, box.w, box.h, 0, 0, box.w, box.h);
	/*
		*** NOTE #8 ***
		The browser treats the data URL as a resource when using fetch.
		The fetch function retrieves the data and allows us to convert it into a Blob.
	*/
	const dataUrl = tmpElem.toDataURL('image/png');
	const response = await fetch(dataUrl);
	const blob = await response.blob();
	try {
		await navigator.clipboard.write([
			new ClipboardItem({'image/png': blob})
		]);
	} catch (err) {
		alert(err);
	}
}

function startDialog(in_element, in_callback = null) {
	const background = document.createElement('div');
	Object.assign(background.style, {
		position : 'fixed',
		left : '0px',
		top : '0px',
		width : '100%',
		height : '100%',
		zIndex : 2 ** 31 - 1
	});
	background.appendChild(in_element);
	Object.assign(in_element.style, {
		position : 'absolute',
		left : '50%',
		top : '50%',
		transform : 'translate(-50%, -50%)'
	});
	document.body.appendChild(background);
	const closeDialog = () => {
		document.body.removeChild(background);
		if (in_callback) {
			(in_callback)();
		}
	};
	background.addEventListener('mousedown', closeDialog);
	background.addEventListener('touchstart', closeDialog);
}

function uiHelp() {
	const dialog = document.createElement('div');
	Object.assign(dialog.style, {
		width : 'auto',
		height : 'auto',
		background : 'white',
		borderRadius : '1em',
		padding : '1em'
	});
	dialog.innerHTML += '<img src="./stick-figure-help.gif" />';
	startDialog(dialog);
}

function uiRights() {
	const dialog = document.createElement('dl');
	Object.assign(dialog.style, {
		width : '30%',
		height : 'auto',
		background : 'black',
		borderRadius : '1em',
		padding : '1.5em'
	});
	([
		'<dt>Image Usage Rights</dt>',
		'<dd>All images generated using this software are free for users to use as they see fit.</dd>',
		'<dd>This includes the rights to modify, distribute, and use the images for both personal and commercial purposes without any restrictions.</dd>',
		'<dt>Donations</dt>',
		'<dd>While the use of images generated by this software is completely free, donations are welcome and greatly appreciated.</dd>',
		'<dd>If you would like to support the development of this software, please consider making a donation using the QR code below (TBD).</dd>'
	]).forEach(in_fragment => {
		dialog.innerHTML += in_fragment;
	});
	setTransition(dialog, 'color 0.5s ease-out', 'gray', 'white')
	startDialog(dialog);
}

function setUpButtons() {
	const settings = [
		{
			text : 'next color',
			func : uiChangeColor
		},
		{
			text : 'next material',
			func : uiChangeMaterial
		},
		{
			text : 'next figure',
			func : uiChangeFigure
		},
		{
			text : 'next item',
			func : uiChangeItem
		},
		{
			text : 'default position',
			func : uiDefaultView
		},
		{
			text : 'one more figure',
			func : uiOneMoreFigure
		},
		{
			text : 'screenshot',
			func : uiGetScreenShot
		},
		{
			text : 'help',
			func : uiHelp
		},
		{
			text : 'rights',
			func : uiRights
		}
	];
	let container = document.createElement('div');
	Object.assign(container.style, {
		position : 'absolute',
		left : '5%',
		top : '5%'
	});
	document.body.appendChild(container);
	settings.forEach(in_setting => {
		let button = document.createElement('button');
		button.innerText = in_setting.text;
		button.addEventListener('click', in_setting.func);
		Object.assign(button.style, {
			margin : '1.5px 1.5px 1.5px 1.5px',
			borderRadius : '3px',
			border : '1px solid gray'
		});
		container.appendChild(button);
	});
}

setUpButtons();

/*
	(9) event handlers
*/

const gDrag = {
	vec : null,
	obj : null,
	far : false,
	isActive : function() {
		if (!this.vec) {
			return false;
		}
		if (!this.obj) {
			return false;
		}
		return true;
	}
};

gWorld.canvas.addEventListener('mousedown', in_ev => {
	let vec2 = eventPos2RaycasterPos(in_ev);
	let intersects = gWorld.intersectPositive(vec2);
	if (intersects.length > 0) {
		const rayHit = intersects[0];
		if (!(rayHit.object instanceof cPart)) {
			// uncontrollable object
			return;
		}
		const cameraPos = gWorld.copyCameraPosition();
		const objectPos = rayHit.object.getWorldPosition(new THREE.Vector3());
		gDrag.far = (rayHit.distance > cameraPos.distanceTo(objectPos));
		if (DEBUG) {
			console.log('drag ' + (gDrag.far ? 'far' : 'near') + '-side');
		}
		gDrag.vec = vec2;
		gDrag.obj = rayHit.object;
		// not lookAt(cameraPos), but lookAt(raycaster.ray.direction.negate())
		gDrag.obj.receiverStart(objectPos.add(cameraPos));
	}
});

function isMovable360Item(in_obj) {
	const classNames = [cArm, cHead, cSmartPhone, cLightSaber];
	return classNames.some(className => in_obj instanceof className);
}

gWorld.canvas.addEventListener('mousemove', in_ev => {
	if (!gDrag.isActive()) {
		return;
	}
	let vec2 = eventPos2RaycasterPos(in_ev);
	let delta = vec2.clone().sub(gDrag.vec);
	if (delta.length() < 0.01) {
		return;
	}
	let intersects;
	if (gDrag.far) {
		intersects = gWorld.intersectNegative(vec2, cPart.receiverLayer);
	} else {
		intersects = gWorld.intersectPositive(vec2, cPart.receiverLayer);
	}
	if (intersects.length > 0) {
		if (isMovable360Item(gDrag.obj)) {
			gDrag.obj.lookAt(intersects[0].point);
		} else {
			gDrag.obj.lookAt(intersects[0].point, new THREE.Vector3(1, 0, 0));
		}
		gDrag.vec = vec2;
	}
});

function dragstop() {
	if (!gDrag.isActive()) {
		return;
	}
	gDrag.obj.receiverStop();
	gDrag.vec = null;
	gDrag.obj = null;
}

gWorld.canvas.addEventListener('mouseleave', dragstop);
gWorld.canvas.addEventListener('mouseout', dragstop);
gWorld.canvas.addEventListener('mouseup', dragstop);

(() => {
	const EMULATETBL = [
		{
			src : 'touchstart',
			dst : 'mousedown'
		},
		{
			src : 'touchmove',
			dst : 'mousemove'
		},
		{
			src : 'touchleave',
			dst : 'mouseleave'
		},
		{
			src : 'touchend',
			dst : 'mouseup'
		}
	];
	let lastDistance = null;
	function createAltWheelEv(in_ev) {
		const t1 = in_ev.touches[0];
		const t2 = in_ev.touches[1];
		const currentDistance = Math.sqrt(Math.pow(t2.clientX - t1.clientX, 2) + Math.pow(t2.clientY - t1.clientY, 2));
		if (lastDistance === null) {
			lastDistance = currentDistance;
			return null;
		}
		const speed = 2;
		const delta = (lastDistance - currentDistance) * speed;
		lastDistance = currentDistance;
		return new WheelEvent('wheel', {
			deltaY : delta,
			clientX : (t1.clientX + t2.clientX) / 2,
			clientY : (t1.clientY + t2.clientY) / 2,
			ctrlKey : in_ev.ctrlKey,
			altKey : in_ev.altKey,
			shiftKey : in_ev.shiftKey,
			metaKey : in_ev.metaKey
		});
	}
	function createAltMouseEv(in_type, in_ev) {
		return new MouseEvent(in_type, {
			bubbles : true,
			cancelable : true,
			view : window,
			screenX : in_ev.changedTouches[0].screenX,
			screenY : in_ev.changedTouches[0].screenY,
			clientX : in_ev.changedTouches[0].clientX,
			clientY : in_ev.changedTouches[0].clientY,
			ctrlKey : in_ev.ctrlKey,
			altKey : in_ev.altKey,
			shiftKey : in_ev.shiftKey,
			metaKey : in_ev.metaKey,
			button : 0,
			relatedTarget : null
		});
	}
	EMULATETBL.forEach(in_pair => {
		gWorld.canvas.addEventListener(in_pair.src, in_ev => {
			in_ev.preventDefault();
			in_ev.stopPropagation();
			let alternative = null;
			if (in_ev.touches.length > 1) {
				if ((in_ev.touches.length === 2) && (in_pair.src === 'touchmove')) {
					alternative = createAltWheelEv(in_ev);
				} else {
					lastDistance = null;
				}
			} else {
				alternative = createAltMouseEv(in_pair.dst, in_ev);
			}
			if (alternative) {
				in_ev.target.dispatchEvent(alternative);
			}
		});
	});
})();

</script>
</body>
</html>
